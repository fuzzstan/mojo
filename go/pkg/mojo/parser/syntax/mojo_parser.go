// Code generated from MojoParser.g4 by ANTLR 4.13.0. DO NOT EDIT.

package syntax // MojoParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type MojoParser struct {
	*antlr.BaseParser
}

var MojoParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func mojoparserParserInit() {
	staticData := &MojoParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'and'", "'as'", "'attribute'", "'break'", "'const'", "'continue'",
		"'else'", "'enum'", "'false'", "'for'", "'func'", "'if'", "'import'",
		"'in'", "'interface'", "'is'", "'match'", "'not'", "'null'", "'or'",
		"'package'", "'return'", "'struct'", "'true'", "'type'", "'var'", "'while'",
		"'xor'", "'.'", "'{'", "'('", "'['", "'}'", "')'", "']'", "','", "':'",
		"';'", "'<'", "'>'", "'!'", "'?'", "'@'", "'&'", "'-'", "'='", "'|'",
		"'/'", "'+'", "'*'", "'%'", "'^'", "'~'", "'$'", "'`'", "'_'",
	}
	staticData.SymbolicNames = []string{
		"", "KEYWORD_AND", "KEYWORD_AS", "KEYWORD_ATTRIBUTE", "KEYWORD_BREAK",
		"KEYWORD_CONST", "KEYWORD_CONTINUE", "KEYWORD_ELSE", "KEYWORD_ENUM",
		"KEYWORD_FALSE", "KEYWORD_FOR", "KEYWORD_FUNC", "KEYWORD_IF", "KEYWORD_IMPORT",
		"KEYWORD_IN", "KEYWORD_INTERFACE", "KEYWORD_IS", "KEYWORD_MATCH", "KEYWORD_NOT",
		"KEYWORD_NULL", "KEYWORD_OR", "KEYWORD_PACKAGE", "KEYWORD_RETURN", "KEYWORD_STRUCT",
		"KEYWORD_TRUE", "KEYWORD_TYPE", "KEYWORD_VAR", "KEYWORD_WHILE", "KEYWORD_XOR",
		"DOT", "LCURLY", "LPAREN", "LBRACK", "RCURLY", "RPAREN", "RBRACK", "COMMA",
		"COLON", "SEMI", "LT", "GT", "BANG", "QUESTION", "AT", "AND", "MINUS",
		"EQUAL", "PIPE", "SLASH", "PLUS", "STAR", "PERCENT", "CARET", "TILDE",
		"DOLLER", "BACKTICK", "UNDERSCORE", "PLUS_PLUS", "MINUS_MINUS", "COLON_EQUAL",
		"RIGHT_RIGHT_ARROWS", "RIGHT_ARROW", "DOT_DOT", "DOT_DOT_LT", "ELLIPSIS",
		"GRAPH_RIGHT_PATH", "GRAPH_LEFT_PATH", "GRAPH_PATH", "GRAPH_CONSTRAINT_PATH_LEFT",
		"GRAPH_CONSTRAINT_PATH_LEFT_ARROW", "GRAPH_CONSTRAINT_PATH_RIGHT", "GRAPH_CONSTRAINT_PATH_RIGHT_ARROW",
		"TYPE_IDENTIFIER", "VALUE_IDENTIFIER", "OPERATOR_HEAD_OTHER", "IMPLICIT_PARAMETER_NAME",
		"BINARY_LITERAL", "OCTAL_LITERAL", "DECIMAL_LITERAL", "PURE_DECIMAL_DIGITS",
		"HEXADECIMAL_LITERAL", "FLOAT_LITERAL", "STATIC_STRING_LITERAL", "INTERPOLATED_STRING_LITERAL",
		"WS", "BLOCK_COMMENT", "LINE_COMMENT", "LINE_COMMENT_DISTINCT_DOCUMENT",
		"EOL", "LINE_DOCUMENT", "FOLLOWING_LINE_DOCUMENT", "INNER_LINE_DOCUMENT",
		"OPERATOR_FOLLOWING_CHARACTER",
	}
	staticData.RuleNames = []string{
		"mojoFile", "statement", "ifModifier", "whileModifier", "floatingStatement",
		"statements", "loopStatement", "forInStatement", "whileStatement", "conditions",
		"condition", "optionalBindingCondition", "branchStatement", "ifStatement",
		"elseClause", "matchStatement", "matchCases", "matchCase", "controlTransferStatement",
		"breakStatement", "continueStatement", "returnStatement", "genericParameterClause",
		"genericParameters", "genericParameter", "genericArgumentClause", "genericArguments",
		"genericArgument", "declaration", "codeBlock", "packageDeclaration",
		"packageIdentifier", "packageName", "importDeclaration", "importPath",
		"importPathIdentifier", "importAllClause", "importValueAsClause", "importTypeClause",
		"importTypeAsClause", "importGroupClause", "importGroup", "importValue",
		"importType", "constantDeclaration", "patternInitializers", "documentedPatternInitializer",
		"patternInitializer", "initializer", "variableDeclaration", "typeAliasDeclaration",
		"typeAliasName", "typeAliasAssignment", "functionDeclaration", "functionName",
		"functionSignature", "functionResult", "functionBody", "functionParameterClause",
		"functionParameters", "functionParameter", "enumDeclaration", "enumBody",
		"enumName", "enumMembers", "enumMember", "structDeclaration", "structName",
		"structType", "structBody", "structMembers", "structMember", "structMemberDeclaration",
		"interfaceDeclaration", "interfaceName", "interfaceType", "interfaceBody",
		"interfaceMembers", "interfaceMember", "interfaceMethodDeclaration",
		"attributeDeclaration", "attributeAliasDeclaration", "attributeAliasAssignment",
		"pattern", "wildcardPattern", "identifierPattern", "tuplePattern", "tuplePatternElementList",
		"tuplePatternElement", "optionalPattern", "expressionPattern", "attribute",
		"attributeIdentifier", "attributeName", "attributeArgumentClause", "attributeArgument",
		"attributeArguments", "attributes", "expression", "expressions", "prefixExpression",
		"binaryExpression", "binaryExpressions", "conditionalOperator", "typeCastingOperator",
		"primaryExpression", "literalExpression", "numericOperatorLiteral",
		"stringOperatorLiteral", "suffixLiteralOperator", "prefixLiteralOperator",
		"arrayLiteral", "arrayLiteralItems", "arrayLiteralItem", "mapLiteral",
		"mapLiteralItems", "mapLiteralItem", "objectLiteral", "objectLiteralItems",
		"objectLiteralItem", "structLiteral", "structConstructionExpression",
		"matchExprSuffix", "matchExprCases", "matchExprCase", "closureExpression",
		"closureParameters", "closureParameter", "implicitMemberExpression",
		"parenthesizedExpression", "tupleLiteralExpression", "tupleElement",
		"wildcardExpression", "postfixExpression", "suffixExpression", "explicitMemberSuffix",
		"subscriptSuffix", "functionCallSuffix", "functionCallArgumentClause",
		"functionCallArguments", "functionCallArgument", "trailingClosures",
		"labeledTrailingClosures", "labeledTrailingClosure", "argumentNames",
		"argumentName", "type_", "basicType", "primeType", "typeAnnotation",
		"typeIdentifier", "typeIdentifierClause", "typeName", "tupleType", "tupleTypeElements",
		"tupleTypeElement", "functionType", "arrayType", "mapType", "keyAttributes",
		"typeInheritanceClause", "typeInheritances", "typeInheritance", "declarationIdentifier",
		"labelIdentifier", "pathIdentifier", "identifier", "keywordAsIdentifierInDeclarations",
		"keywordAsIdentifierInLabels", "document", "followingDocument", "assignmentOperator",
		"negatePrefixOperator", "arrowOperator", "rangeOperator", "halfOpenRangeOperator",
		"binaryOperator", "prefixOperator", "postfixOperator", "operator", "operator_characters",
		"operator_character", "operator_head", "dot_operator_head", "dot_operator_character",
		"literal", "boolLiteral", "nullLiteral", "numericLiteral", "integerLiteral",
		"stringLiteral", "eos", "eov", "eosWithDocument", "eovWithDocument",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 92, 2438, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89,
		7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7,
		94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99,
		2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 104,
		7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 108,
		2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 113,
		7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 117,
		2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 122,
		7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 126,
		2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 131,
		7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 135,
		2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 140,
		7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 144,
		2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 149,
		7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7, 153,
		2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 158,
		7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 162,
		2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 167,
		7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7, 171,
		2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2, 176,
		7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 180,
		2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 185,
		7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7, 189,
		2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2, 194,
		7, 194, 1, 0, 5, 0, 392, 8, 0, 10, 0, 12, 0, 395, 9, 0, 1, 0, 3, 0, 398,
		8, 0, 1, 0, 5, 0, 401, 8, 0, 10, 0, 12, 0, 404, 9, 0, 1, 0, 1, 0, 1, 1,
		1, 1, 1, 1, 1, 1, 3, 1, 412, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 418, 8,
		1, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 5,
		5, 431, 8, 5, 10, 5, 12, 5, 434, 9, 5, 1, 5, 1, 5, 5, 5, 438, 8, 5, 10,
		5, 12, 5, 441, 9, 5, 1, 5, 3, 5, 444, 8, 5, 1, 6, 1, 6, 3, 6, 448, 8, 6,
		1, 7, 1, 7, 1, 7, 5, 7, 453, 8, 7, 10, 7, 12, 7, 456, 9, 7, 1, 7, 1, 7,
		1, 7, 5, 7, 461, 8, 7, 10, 7, 12, 7, 464, 9, 7, 1, 7, 1, 7, 1, 8, 1, 8,
		1, 8, 5, 8, 471, 8, 8, 10, 8, 12, 8, 474, 9, 8, 1, 8, 1, 8, 1, 9, 1, 9,
		1, 9, 5, 9, 481, 8, 9, 10, 9, 12, 9, 484, 9, 9, 1, 9, 1, 9, 5, 9, 488,
		8, 9, 10, 9, 12, 9, 491, 9, 9, 1, 10, 1, 10, 3, 10, 495, 8, 10, 1, 11,
		1, 11, 1, 11, 5, 11, 500, 8, 11, 10, 11, 12, 11, 503, 9, 11, 1, 11, 1,
		11, 1, 12, 1, 12, 3, 12, 509, 8, 12, 1, 13, 1, 13, 1, 13, 5, 13, 514, 8,
		13, 10, 13, 12, 13, 517, 9, 13, 1, 13, 1, 13, 5, 13, 521, 8, 13, 10, 13,
		12, 13, 524, 9, 13, 1, 13, 3, 13, 527, 8, 13, 1, 14, 1, 14, 5, 14, 531,
		8, 14, 10, 14, 12, 14, 534, 9, 14, 1, 14, 1, 14, 1, 14, 5, 14, 539, 8,
		14, 10, 14, 12, 14, 542, 9, 14, 1, 14, 3, 14, 545, 8, 14, 1, 15, 1, 15,
		1, 15, 5, 15, 550, 8, 15, 10, 15, 12, 15, 553, 9, 15, 1, 15, 1, 15, 5,
		15, 557, 8, 15, 10, 15, 12, 15, 560, 9, 15, 1, 15, 3, 15, 563, 8, 15, 1,
		15, 5, 15, 566, 8, 15, 10, 15, 12, 15, 569, 9, 15, 1, 15, 1, 15, 1, 16,
		1, 16, 1, 16, 5, 16, 576, 8, 16, 10, 16, 12, 16, 579, 9, 16, 1, 16, 1,
		16, 5, 16, 583, 8, 16, 10, 16, 12, 16, 586, 9, 16, 1, 16, 3, 16, 589, 8,
		16, 1, 17, 1, 17, 3, 17, 593, 8, 17, 1, 17, 5, 17, 596, 8, 17, 10, 17,
		12, 17, 599, 9, 17, 1, 17, 1, 17, 5, 17, 603, 8, 17, 10, 17, 12, 17, 606,
		9, 17, 1, 17, 1, 17, 3, 17, 610, 8, 17, 1, 18, 1, 18, 1, 18, 3, 18, 615,
		8, 18, 1, 19, 1, 19, 1, 20, 1, 20, 1, 21, 1, 21, 3, 21, 623, 8, 21, 1,
		22, 1, 22, 5, 22, 627, 8, 22, 10, 22, 12, 22, 630, 9, 22, 1, 22, 1, 22,
		5, 22, 634, 8, 22, 10, 22, 12, 22, 637, 9, 22, 1, 22, 1, 22, 1, 23, 1,
		23, 1, 23, 5, 23, 644, 8, 23, 10, 23, 12, 23, 647, 9, 23, 1, 23, 1, 23,
		5, 23, 651, 8, 23, 10, 23, 12, 23, 654, 9, 23, 1, 23, 3, 23, 657, 8, 23,
		1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 666, 8, 24, 1,
		25, 1, 25, 5, 25, 670, 8, 25, 10, 25, 12, 25, 673, 9, 25, 1, 25, 1, 25,
		5, 25, 677, 8, 25, 10, 25, 12, 25, 680, 9, 25, 1, 25, 1, 25, 1, 26, 1,
		26, 1, 26, 5, 26, 687, 8, 26, 10, 26, 12, 26, 690, 9, 26, 1, 26, 1, 26,
		5, 26, 694, 8, 26, 10, 26, 12, 26, 697, 9, 26, 1, 27, 1, 27, 3, 27, 701,
		8, 27, 1, 28, 1, 28, 1, 28, 3, 28, 706, 8, 28, 1, 28, 1, 28, 5, 28, 710,
		8, 28, 10, 28, 12, 28, 713, 9, 28, 3, 28, 715, 8, 28, 1, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 728,
		8, 28, 1, 29, 1, 29, 5, 29, 732, 8, 29, 10, 29, 12, 29, 735, 9, 29, 1,
		29, 3, 29, 738, 8, 29, 1, 29, 5, 29, 741, 8, 29, 10, 29, 12, 29, 744, 9,
		29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 5, 30, 751, 8, 30, 10, 30, 12, 30,
		754, 9, 30, 1, 30, 3, 30, 757, 8, 30, 1, 31, 1, 31, 1, 31, 5, 31, 762,
		8, 31, 10, 31, 12, 31, 765, 9, 31, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 3, 33, 775, 8, 33, 1, 34, 1, 34, 1, 34, 5, 34, 780, 8,
		34, 10, 34, 12, 34, 783, 9, 34, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 37,
		1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 3, 38, 796, 8, 38, 1, 39, 1, 39, 1,
		39, 1, 40, 1, 40, 1, 40, 5, 40, 804, 8, 40, 10, 40, 12, 40, 807, 9, 40,
		1, 40, 1, 40, 5, 40, 811, 8, 40, 10, 40, 12, 40, 814, 9, 40, 1, 40, 1,
		40, 1, 41, 1, 41, 3, 41, 820, 8, 41, 1, 41, 1, 41, 5, 41, 824, 8, 41, 10,
		41, 12, 41, 827, 9, 41, 1, 41, 1, 41, 3, 41, 831, 8, 41, 5, 41, 833, 8,
		41, 10, 41, 12, 41, 836, 9, 41, 1, 41, 3, 41, 839, 8, 41, 1, 42, 1, 42,
		3, 42, 843, 8, 42, 1, 43, 1, 43, 3, 43, 847, 8, 43, 1, 44, 1, 44, 1, 44,
		1, 45, 1, 45, 1, 45, 5, 45, 855, 8, 45, 10, 45, 12, 45, 858, 9, 45, 1,
		45, 1, 45, 5, 45, 862, 8, 45, 10, 45, 12, 45, 865, 9, 45, 1, 45, 1, 45,
		5, 45, 869, 8, 45, 10, 45, 12, 45, 872, 9, 45, 1, 45, 1, 45, 1, 45, 5,
		45, 877, 8, 45, 10, 45, 12, 45, 880, 9, 45, 1, 45, 1, 45, 5, 45, 884, 8,
		45, 10, 45, 12, 45, 887, 9, 45, 1, 45, 3, 45, 890, 8, 45, 1, 45, 5, 45,
		893, 8, 45, 10, 45, 12, 45, 896, 9, 45, 1, 45, 1, 45, 3, 45, 900, 8, 45,
		1, 46, 1, 46, 1, 46, 3, 46, 905, 8, 46, 1, 46, 1, 46, 1, 46, 3, 46, 910,
		8, 46, 1, 46, 1, 46, 1, 47, 1, 47, 3, 47, 916, 8, 47, 1, 48, 1, 48, 5,
		48, 920, 8, 48, 10, 48, 12, 48, 923, 9, 48, 1, 48, 1, 48, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 933, 8, 49, 1, 50, 1, 50, 1, 50, 3,
		50, 938, 8, 50, 1, 50, 5, 50, 941, 8, 50, 10, 50, 12, 50, 944, 9, 50, 1,
		50, 1, 50, 1, 51, 1, 51, 1, 52, 1, 52, 5, 52, 952, 8, 52, 10, 52, 12, 52,
		955, 9, 52, 1, 52, 1, 52, 3, 52, 959, 8, 52, 1, 52, 3, 52, 962, 8, 52,
		1, 53, 1, 53, 1, 53, 3, 53, 967, 8, 53, 1, 53, 1, 53, 5, 53, 971, 8, 53,
		10, 53, 12, 53, 974, 9, 53, 1, 53, 3, 53, 977, 8, 53, 1, 54, 1, 54, 3,
		54, 981, 8, 54, 1, 55, 1, 55, 3, 55, 985, 8, 55, 1, 55, 5, 55, 988, 8,
		55, 10, 55, 12, 55, 991, 9, 55, 1, 55, 3, 55, 994, 8, 55, 1, 56, 1, 56,
		1, 56, 3, 56, 999, 8, 56, 3, 56, 1001, 8, 56, 1, 56, 1, 56, 3, 56, 1005,
		8, 56, 1, 56, 5, 56, 1008, 8, 56, 10, 56, 12, 56, 1011, 9, 56, 1, 56, 3,
		56, 1014, 8, 56, 1, 57, 1, 57, 3, 57, 1018, 8, 57, 1, 57, 5, 57, 1021,
		8, 57, 10, 57, 12, 57, 1024, 9, 57, 1, 57, 3, 57, 1027, 8, 57, 1, 57, 5,
		57, 1030, 8, 57, 10, 57, 12, 57, 1033, 9, 57, 1, 57, 1, 57, 1, 58, 1, 58,
		1, 58, 1, 58, 5, 58, 1041, 8, 58, 10, 58, 12, 58, 1044, 9, 58, 1, 58, 1,
		58, 5, 58, 1048, 8, 58, 10, 58, 12, 58, 1051, 9, 58, 1, 58, 1, 58, 3, 58,
		1055, 8, 58, 1, 59, 1, 59, 1, 59, 5, 59, 1060, 8, 59, 10, 59, 12, 59, 1063,
		9, 59, 1, 59, 1, 59, 5, 59, 1067, 8, 59, 10, 59, 12, 59, 1070, 9, 59, 1,
		59, 3, 59, 1073, 8, 59, 1, 60, 1, 60, 1, 60, 5, 60, 1078, 8, 60, 10, 60,
		12, 60, 1081, 9, 60, 1, 60, 3, 60, 1084, 8, 60, 1, 60, 1, 60, 3, 60, 1088,
		8, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1093, 8, 60, 3, 60, 1095, 8, 60, 1,
		61, 1, 61, 1, 61, 3, 61, 1100, 8, 61, 1, 61, 5, 61, 1103, 8, 61, 10, 61,
		12, 61, 1106, 9, 61, 1, 61, 3, 61, 1109, 8, 61, 1, 61, 5, 61, 1112, 8,
		61, 10, 61, 12, 61, 1115, 9, 61, 1, 61, 1, 61, 1, 62, 1, 62, 3, 62, 1121,
		8, 62, 1, 62, 5, 62, 1124, 8, 62, 10, 62, 12, 62, 1127, 9, 62, 1, 62, 3,
		62, 1130, 8, 62, 1, 62, 5, 62, 1133, 8, 62, 10, 62, 12, 62, 1136, 9, 62,
		1, 62, 1, 62, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 5, 64, 1145, 8, 64, 10,
		64, 12, 64, 1148, 9, 64, 1, 64, 1, 64, 5, 64, 1152, 8, 64, 10, 64, 12,
		64, 1155, 9, 64, 1, 64, 3, 64, 1158, 8, 64, 1, 65, 1, 65, 1, 65, 3, 65,
		1163, 8, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1168, 8, 65, 1, 65, 1, 65, 3,
		65, 1172, 8, 65, 1, 65, 5, 65, 1175, 8, 65, 10, 65, 12, 65, 1178, 9, 65,
		1, 65, 3, 65, 1181, 8, 65, 1, 65, 3, 65, 1184, 8, 65, 1, 66, 1, 66, 1,
		66, 3, 66, 1189, 8, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 68, 5, 68, 1196,
		8, 68, 10, 68, 12, 68, 1199, 9, 68, 1, 68, 3, 68, 1202, 8, 68, 1, 68, 5,
		68, 1205, 8, 68, 10, 68, 12, 68, 1208, 9, 68, 1, 68, 3, 68, 1211, 8, 68,
		1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 1217, 8, 69, 1, 69, 5, 69, 1220, 8,
		69, 10, 69, 12, 69, 1223, 9, 69, 1, 69, 3, 69, 1226, 8, 69, 1, 69, 5, 69,
		1229, 8, 69, 10, 69, 12, 69, 1232, 9, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1,
		70, 5, 70, 1239, 8, 70, 10, 70, 12, 70, 1242, 9, 70, 1, 70, 1, 70, 5, 70,
		1246, 8, 70, 10, 70, 12, 70, 1249, 9, 70, 1, 70, 3, 70, 1252, 8, 70, 1,
		71, 1, 71, 1, 71, 3, 71, 1257, 8, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1262,
		8, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1269, 8, 71, 1, 71, 3,
		71, 1272, 8, 71, 1, 72, 1, 72, 1, 72, 5, 72, 1277, 8, 72, 10, 72, 12, 72,
		1280, 9, 72, 1, 72, 3, 72, 1283, 8, 72, 1, 73, 1, 73, 1, 73, 3, 73, 1288,
		8, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 75, 5, 75, 1295, 8, 75, 10, 75, 12,
		75, 1298, 9, 75, 1, 75, 3, 75, 1301, 8, 75, 1, 75, 5, 75, 1304, 8, 75,
		10, 75, 12, 75, 1307, 9, 75, 1, 75, 1, 75, 1, 76, 1, 76, 3, 76, 1313, 8,
		76, 1, 76, 5, 76, 1316, 8, 76, 10, 76, 12, 76, 1319, 9, 76, 1, 76, 3, 76,
		1322, 8, 76, 1, 76, 5, 76, 1325, 8, 76, 10, 76, 12, 76, 1328, 9, 76, 1,
		76, 1, 76, 1, 77, 1, 77, 1, 77, 5, 77, 1335, 8, 77, 10, 77, 12, 77, 1338,
		9, 77, 1, 77, 1, 77, 5, 77, 1342, 8, 77, 10, 77, 12, 77, 1345, 9, 77, 1,
		77, 3, 77, 1348, 8, 77, 1, 78, 1, 78, 1, 78, 3, 78, 1353, 8, 78, 1, 78,
		1, 78, 1, 78, 3, 78, 1358, 8, 78, 1, 78, 1, 78, 3, 78, 1362, 8, 78, 1,
		78, 3, 78, 1365, 8, 78, 1, 79, 1, 79, 3, 79, 1369, 8, 79, 1, 79, 5, 79,
		1372, 8, 79, 10, 79, 12, 79, 1375, 9, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1,
		80, 3, 80, 1382, 8, 80, 1, 80, 1, 80, 1, 80, 5, 80, 1387, 8, 80, 10, 80,
		12, 80, 1390, 9, 80, 1, 80, 3, 80, 1393, 8, 80, 1, 80, 3, 80, 1396, 8,
		80, 3, 80, 1398, 8, 80, 1, 81, 1, 81, 1, 81, 3, 81, 1403, 8, 81, 1, 81,
		5, 81, 1406, 8, 81, 10, 81, 12, 81, 1409, 9, 81, 1, 81, 1, 81, 1, 82, 1,
		82, 5, 82, 1415, 8, 82, 10, 82, 12, 82, 1418, 9, 82, 1, 82, 1, 82, 1, 82,
		3, 82, 1423, 8, 82, 1, 82, 1, 82, 3, 82, 1427, 8, 82, 1, 82, 3, 82, 1430,
		8, 82, 1, 83, 1, 83, 1, 83, 3, 83, 1435, 8, 83, 1, 83, 1, 83, 3, 83, 1439,
		8, 83, 1, 83, 1, 83, 3, 83, 1443, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3,
		83, 1449, 8, 83, 1, 83, 1, 83, 1, 83, 5, 83, 1454, 8, 83, 10, 83, 12, 83,
		1457, 9, 83, 1, 84, 1, 84, 1, 85, 1, 85, 1, 86, 1, 86, 3, 86, 1465, 8,
		86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 5, 87, 1472, 8, 87, 10, 87, 12,
		87, 1475, 9, 87, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 91,
		1, 91, 1, 91, 1, 91, 1, 91, 3, 91, 1489, 8, 91, 1, 91, 3, 91, 1492, 8,
		91, 3, 91, 1494, 8, 91, 1, 92, 1, 92, 1, 92, 3, 92, 1499, 8, 92, 1, 92,
		1, 92, 1, 93, 1, 93, 1, 94, 1, 94, 5, 94, 1507, 8, 94, 10, 94, 12, 94,
		1510, 9, 94, 1, 94, 3, 94, 1513, 8, 94, 1, 94, 5, 94, 1516, 8, 94, 10,
		94, 12, 94, 1519, 9, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 3, 95, 1526,
		8, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 5, 96, 1533, 8, 96, 10, 96, 12,
		96, 1536, 9, 96, 1, 96, 1, 96, 5, 96, 1540, 8, 96, 10, 96, 12, 96, 1543,
		9, 96, 1, 96, 3, 96, 1546, 8, 96, 1, 97, 1, 97, 3, 97, 1550, 8, 97, 1,
		97, 5, 97, 1553, 8, 97, 10, 97, 12, 97, 1556, 9, 97, 1, 98, 1, 98, 3, 98,
		1560, 8, 98, 1, 99, 1, 99, 1, 99, 5, 99, 1565, 8, 99, 10, 99, 12, 99, 1568,
		9, 99, 1, 99, 1, 99, 5, 99, 1572, 8, 99, 10, 99, 12, 99, 1575, 9, 99, 1,
		99, 3, 99, 1578, 8, 99, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1584, 8,
		100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 3, 101, 1596, 8, 101, 1, 102, 4, 102, 1599, 8, 102, 11, 102,
		12, 102, 1600, 1, 103, 1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104,
		1, 104, 3, 104, 1611, 8, 104, 1, 105, 1, 105, 1, 105, 3, 105, 1616, 8,
		105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 1622, 8, 105, 1, 105, 1, 105,
		1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 1630, 8, 105, 1, 106, 1, 106, 1,
		106, 1, 106, 1, 106, 1, 106, 1, 106, 3, 106, 1639, 8, 106, 1, 107, 1, 107,
		1, 107, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1648, 8, 108, 1, 108, 1,
		108, 1, 108, 3, 108, 1653, 8, 108, 1, 109, 1, 109, 1, 109, 1, 110, 1, 110,
		1, 111, 1, 111, 5, 111, 1662, 8, 111, 10, 111, 12, 111, 1665, 9, 111, 1,
		111, 3, 111, 1668, 8, 111, 1, 111, 5, 111, 1671, 8, 111, 10, 111, 12, 111,
		1674, 9, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112, 5, 112, 1681, 8,
		112, 10, 112, 12, 112, 1684, 9, 112, 1, 112, 1, 112, 5, 112, 1688, 8, 112,
		10, 112, 12, 112, 1691, 9, 112, 1, 112, 3, 112, 1694, 8, 112, 1, 113, 1,
		113, 3, 113, 1698, 8, 113, 1, 114, 1, 114, 5, 114, 1702, 8, 114, 10, 114,
		12, 114, 1705, 9, 114, 1, 114, 3, 114, 1708, 8, 114, 1, 114, 5, 114, 1711,
		8, 114, 10, 114, 12, 114, 1714, 9, 114, 1, 114, 1, 114, 1, 115, 1, 115,
		1, 115, 5, 115, 1721, 8, 115, 10, 115, 12, 115, 1724, 9, 115, 1, 115, 1,
		115, 5, 115, 1728, 8, 115, 10, 115, 12, 115, 1731, 9, 115, 1, 115, 3, 115,
		1734, 8, 115, 1, 116, 1, 116, 3, 116, 1738, 8, 116, 1, 116, 1, 116, 1,
		116, 1, 117, 1, 117, 5, 117, 1745, 8, 117, 10, 117, 12, 117, 1748, 9, 117,
		1, 117, 3, 117, 1751, 8, 117, 1, 117, 5, 117, 1754, 8, 117, 10, 117, 12,
		117, 1757, 9, 117, 1, 117, 1, 117, 1, 118, 1, 118, 1, 118, 5, 118, 1764,
		8, 118, 10, 118, 12, 118, 1767, 9, 118, 1, 118, 1, 118, 5, 118, 1771, 8,
		118, 10, 118, 12, 118, 1774, 9, 118, 1, 118, 3, 118, 1777, 8, 118, 1, 119,
		1, 119, 1, 119, 3, 119, 1782, 8, 119, 1, 120, 1, 120, 1, 120, 1, 121, 1,
		121, 1, 121, 1, 122, 1, 122, 5, 122, 1792, 8, 122, 10, 122, 12, 122, 1795,
		9, 122, 1, 122, 1, 122, 5, 122, 1799, 8, 122, 10, 122, 12, 122, 1802, 9,
		122, 1, 122, 3, 122, 1805, 8, 122, 1, 122, 5, 122, 1808, 8, 122, 10, 122,
		12, 122, 1811, 9, 122, 1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 5, 123,
		1818, 8, 123, 10, 123, 12, 123, 1821, 9, 123, 1, 123, 1, 123, 5, 123, 1825,
		8, 123, 10, 123, 12, 123, 1828, 9, 123, 1, 123, 3, 123, 1831, 8, 123, 1,
		124, 1, 124, 5, 124, 1835, 8, 124, 10, 124, 12, 124, 1838, 9, 124, 1, 124,
		1, 124, 5, 124, 1842, 8, 124, 10, 124, 12, 124, 1845, 9, 124, 1, 124, 1,
		124, 1, 125, 1, 125, 5, 125, 1851, 8, 125, 10, 125, 12, 125, 1854, 9, 125,
		1, 125, 1, 125, 5, 125, 1858, 8, 125, 10, 125, 12, 125, 1861, 9, 125, 1,
		125, 1, 125, 1, 125, 1, 125, 1, 125, 5, 125, 1868, 8, 125, 10, 125, 12,
		125, 1871, 9, 125, 1, 125, 1, 125, 5, 125, 1875, 8, 125, 10, 125, 12, 125,
		1878, 9, 125, 1, 125, 3, 125, 1881, 8, 125, 1, 125, 5, 125, 1884, 8, 125,
		10, 125, 12, 125, 1887, 9, 125, 1, 125, 1, 125, 1, 125, 3, 125, 1892, 8,
		125, 1, 126, 1, 126, 1, 126, 5, 126, 1897, 8, 126, 10, 126, 12, 126, 1900,
		9, 126, 1, 126, 1, 126, 5, 126, 1904, 8, 126, 10, 126, 12, 126, 1907, 9,
		126, 1, 126, 3, 126, 1910, 8, 126, 1, 127, 1, 127, 3, 127, 1914, 8, 127,
		1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 5, 129, 1921, 8, 129, 10, 129,
		12, 129, 1924, 9, 129, 1, 129, 1, 129, 5, 129, 1928, 8, 129, 10, 129, 12,
		129, 1931, 9, 129, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130,
		1, 130, 4, 130, 1941, 8, 130, 11, 130, 12, 130, 1942, 1, 130, 1, 130, 3,
		130, 1947, 8, 130, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 3, 131,
		1955, 8, 131, 1, 132, 1, 132, 1, 133, 1, 133, 5, 133, 1961, 8, 133, 10,
		133, 12, 133, 1964, 9, 133, 1, 133, 3, 133, 1967, 8, 133, 1, 134, 1, 134,
		1, 134, 1, 134, 1, 134, 3, 134, 1974, 8, 134, 1, 135, 1, 135, 1, 135, 1,
		135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 1984, 8, 135, 3, 135, 1986,
		8, 135, 1, 136, 1, 136, 1, 136, 1, 136, 1, 137, 3, 137, 1993, 8, 137, 1,
		137, 1, 137, 3, 137, 1997, 8, 137, 1, 138, 1, 138, 5, 138, 2001, 8, 138,
		10, 138, 12, 138, 2004, 9, 138, 1, 138, 1, 138, 1, 138, 5, 138, 2009, 8,
		138, 10, 138, 12, 138, 2012, 9, 138, 1, 138, 1, 138, 5, 138, 2016, 8, 138,
		10, 138, 12, 138, 2019, 9, 138, 1, 138, 1, 138, 3, 138, 2023, 8, 138, 1,
		139, 1, 139, 1, 139, 5, 139, 2028, 8, 139, 10, 139, 12, 139, 2031, 9, 139,
		1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 3, 140, 2038, 8, 140, 1, 141, 1,
		141, 3, 141, 2042, 8, 141, 1, 142, 4, 142, 2045, 8, 142, 11, 142, 12, 142,
		2046, 1, 143, 1, 143, 1, 143, 1, 143, 1, 144, 1, 144, 5, 144, 2055, 8,
		144, 10, 144, 12, 144, 2058, 9, 144, 1, 145, 1, 145, 1, 145, 1, 146, 1,
		146, 1, 146, 3, 146, 2066, 8, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146,
		1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 5, 146, 2080, 8,
		146, 10, 146, 12, 146, 2083, 9, 146, 1, 147, 1, 147, 1, 147, 1, 147, 1,
		147, 3, 147, 2090, 8, 147, 1, 147, 1, 147, 1, 147, 3, 147, 2095, 8, 147,
		1, 147, 5, 147, 2098, 8, 147, 10, 147, 12, 147, 2101, 9, 147, 1, 147, 1,
		147, 5, 147, 2105, 8, 147, 10, 147, 12, 147, 2108, 9, 147, 1, 147, 1, 147,
		3, 147, 2112, 8, 147, 1, 147, 1, 147, 1, 147, 3, 147, 2117, 8, 147, 1,
		147, 1, 147, 3, 147, 2121, 8, 147, 1, 147, 1, 147, 1, 147, 3, 147, 2126,
		8, 147, 1, 147, 5, 147, 2129, 8, 147, 10, 147, 12, 147, 2132, 9, 147, 1,
		147, 1, 147, 5, 147, 2136, 8, 147, 10, 147, 12, 147, 2139, 9, 147, 1, 147,
		1, 147, 3, 147, 2143, 8, 147, 1, 147, 1, 147, 1, 147, 3, 147, 2148, 8,
		147, 5, 147, 2150, 8, 147, 10, 147, 12, 147, 2153, 9, 147, 1, 148, 1, 148,
		1, 148, 1, 148, 3, 148, 2159, 8, 148, 1, 149, 3, 149, 2162, 8, 149, 1,
		149, 1, 149, 3, 149, 2166, 8, 149, 1, 150, 1, 150, 1, 150, 3, 150, 2171,
		8, 150, 1, 150, 1, 150, 1, 150, 5, 150, 2176, 8, 150, 10, 150, 12, 150,
		2179, 9, 150, 1, 151, 1, 151, 3, 151, 2183, 8, 151, 1, 152, 1, 152, 1,
		153, 1, 153, 5, 153, 2189, 8, 153, 10, 153, 12, 153, 2192, 9, 153, 1, 153,
		3, 153, 2195, 8, 153, 1, 153, 5, 153, 2198, 8, 153, 10, 153, 12, 153, 2201,
		9, 153, 1, 153, 1, 153, 1, 154, 1, 154, 1, 154, 5, 154, 2208, 8, 154, 10,
		154, 12, 154, 2211, 9, 154, 1, 154, 1, 154, 5, 154, 2215, 8, 154, 10, 154,
		12, 154, 2218, 9, 154, 1, 154, 3, 154, 2221, 8, 154, 1, 155, 1, 155, 3,
		155, 2225, 8, 155, 3, 155, 2227, 8, 155, 1, 155, 1, 155, 3, 155, 2231,
		8, 155, 1, 156, 1, 156, 1, 156, 1, 156, 3, 156, 2237, 8, 156, 1, 157, 1,
		157, 1, 157, 3, 157, 2242, 8, 157, 1, 157, 1, 157, 1, 158, 1, 158, 1, 158,
		3, 158, 2249, 8, 158, 1, 158, 3, 158, 2252, 8, 158, 1, 158, 1, 158, 3,
		158, 2256, 8, 158, 1, 158, 1, 158, 1, 159, 1, 159, 1, 160, 1, 160, 5, 160,
		2264, 8, 160, 10, 160, 12, 160, 2267, 9, 160, 1, 160, 1, 160, 1, 161, 1,
		161, 1, 161, 5, 161, 2274, 8, 161, 10, 161, 12, 161, 2277, 9, 161, 1, 161,
		1, 161, 5, 161, 2281, 8, 161, 10, 161, 12, 161, 2284, 9, 161, 1, 161, 3,
		161, 2287, 8, 161, 1, 162, 1, 162, 3, 162, 2291, 8, 162, 1, 163, 1, 163,
		3, 163, 2295, 8, 163, 1, 164, 1, 164, 3, 164, 2299, 8, 164, 1, 165, 1,
		165, 1, 165, 5, 165, 2304, 8, 165, 10, 165, 12, 165, 2307, 9, 165, 1, 166,
		1, 166, 1, 167, 1, 167, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 5, 169,
		2318, 8, 169, 10, 169, 12, 169, 2321, 9, 169, 1, 170, 1, 170, 1, 170, 5,
		170, 2326, 8, 170, 10, 170, 12, 170, 2329, 9, 170, 1, 171, 1, 171, 1, 172,
		1, 172, 1, 173, 1, 173, 1, 174, 1, 174, 1, 175, 1, 175, 1, 176, 1, 176,
		1, 176, 1, 176, 1, 176, 3, 176, 2346, 8, 176, 1, 177, 1, 177, 3, 177, 2350,
		8, 177, 1, 178, 1, 178, 1, 179, 1, 179, 3, 179, 2356, 8, 179, 1, 179, 1,
		179, 4, 179, 2360, 8, 179, 11, 179, 12, 179, 2361, 3, 179, 2364, 8, 179,
		1, 180, 1, 180, 4, 180, 2368, 8, 180, 11, 180, 12, 180, 2369, 1, 181, 1,
		181, 3, 181, 2374, 8, 181, 1, 182, 1, 182, 3, 182, 2378, 8, 182, 1, 183,
		1, 183, 1, 184, 1, 184, 3, 184, 2384, 8, 184, 1, 185, 1, 185, 1, 185, 1,
		185, 3, 185, 2390, 8, 185, 1, 186, 1, 186, 1, 187, 1, 187, 1, 188, 3, 188,
		2397, 8, 188, 1, 188, 1, 188, 3, 188, 2401, 8, 188, 1, 188, 3, 188, 2404,
		8, 188, 1, 189, 1, 189, 1, 190, 1, 190, 1, 191, 1, 191, 1, 192, 1, 192,
		1, 193, 1, 193, 1, 193, 1, 193, 3, 193, 2418, 8, 193, 1, 193, 3, 193, 2421,
		8, 193, 1, 193, 3, 193, 2424, 8, 193, 1, 194, 1, 194, 1, 194, 1, 194, 3,
		194, 2430, 8, 194, 1, 194, 3, 194, 2433, 8, 194, 1, 194, 3, 194, 2436,
		8, 194, 1, 194, 0, 3, 166, 292, 294, 195, 0, 2, 4, 6, 8, 10, 12, 14, 16,
		18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
		54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
		90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
		122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
		152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
		182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210,
		212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240,
		242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270,
		272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300,
		302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330,
		332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360,
		362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 0,
		11, 1, 0, 72, 73, 2, 0, 73, 73, 75, 75, 5, 0, 1, 9, 11, 11, 13, 21, 23,
		25, 28, 28, 2, 0, 1, 11, 13, 28, 2, 0, 57, 58, 64, 64, 2, 0, 39, 42, 44,
		53, 2, 0, 9, 9, 24, 24, 1, 0, 76, 80, 1, 0, 82, 83, 2, 0, 38, 38, 88, 88,
		2, 0, 36, 36, 88, 88, 2637, 0, 393, 1, 0, 0, 0, 2, 417, 1, 0, 0, 0, 4,
		419, 1, 0, 0, 0, 6, 422, 1, 0, 0, 0, 8, 425, 1, 0, 0, 0, 10, 427, 1, 0,
		0, 0, 12, 447, 1, 0, 0, 0, 14, 449, 1, 0, 0, 0, 16, 467, 1, 0, 0, 0, 18,
		477, 1, 0, 0, 0, 20, 494, 1, 0, 0, 0, 22, 496, 1, 0, 0, 0, 24, 508, 1,
		0, 0, 0, 26, 510, 1, 0, 0, 0, 28, 544, 1, 0, 0, 0, 30, 546, 1, 0, 0, 0,
		32, 572, 1, 0, 0, 0, 34, 590, 1, 0, 0, 0, 36, 614, 1, 0, 0, 0, 38, 616,
		1, 0, 0, 0, 40, 618, 1, 0, 0, 0, 42, 620, 1, 0, 0, 0, 44, 624, 1, 0, 0,
		0, 46, 640, 1, 0, 0, 0, 48, 665, 1, 0, 0, 0, 50, 667, 1, 0, 0, 0, 52, 683,
		1, 0, 0, 0, 54, 698, 1, 0, 0, 0, 56, 705, 1, 0, 0, 0, 58, 729, 1, 0, 0,
		0, 60, 747, 1, 0, 0, 0, 62, 758, 1, 0, 0, 0, 64, 766, 1, 0, 0, 0, 66, 768,
		1, 0, 0, 0, 68, 776, 1, 0, 0, 0, 70, 784, 1, 0, 0, 0, 72, 786, 1, 0, 0,
		0, 74, 789, 1, 0, 0, 0, 76, 792, 1, 0, 0, 0, 78, 797, 1, 0, 0, 0, 80, 800,
		1, 0, 0, 0, 82, 819, 1, 0, 0, 0, 84, 840, 1, 0, 0, 0, 86, 844, 1, 0, 0,
		0, 88, 848, 1, 0, 0, 0, 90, 899, 1, 0, 0, 0, 92, 904, 1, 0, 0, 0, 94, 913,
		1, 0, 0, 0, 96, 917, 1, 0, 0, 0, 98, 932, 1, 0, 0, 0, 100, 934, 1, 0, 0,
		0, 102, 947, 1, 0, 0, 0, 104, 949, 1, 0, 0, 0, 106, 963, 1, 0, 0, 0, 108,
		980, 1, 0, 0, 0, 110, 982, 1, 0, 0, 0, 112, 995, 1, 0, 0, 0, 114, 1015,
		1, 0, 0, 0, 116, 1054, 1, 0, 0, 0, 118, 1056, 1, 0, 0, 0, 120, 1094, 1,
		0, 0, 0, 122, 1096, 1, 0, 0, 0, 124, 1118, 1, 0, 0, 0, 126, 1139, 1, 0,
		0, 0, 128, 1141, 1, 0, 0, 0, 130, 1183, 1, 0, 0, 0, 132, 1185, 1, 0, 0,
		0, 134, 1192, 1, 0, 0, 0, 136, 1201, 1, 0, 0, 0, 138, 1212, 1, 0, 0, 0,
		140, 1235, 1, 0, 0, 0, 142, 1271, 1, 0, 0, 0, 144, 1273, 1, 0, 0, 0, 146,
		1284, 1, 0, 0, 0, 148, 1291, 1, 0, 0, 0, 150, 1300, 1, 0, 0, 0, 152, 1310,
		1, 0, 0, 0, 154, 1331, 1, 0, 0, 0, 156, 1364, 1, 0, 0, 0, 158, 1366, 1,
		0, 0, 0, 160, 1378, 1, 0, 0, 0, 162, 1399, 1, 0, 0, 0, 164, 1412, 1, 0,
		0, 0, 166, 1448, 1, 0, 0, 0, 168, 1458, 1, 0, 0, 0, 170, 1460, 1, 0, 0,
		0, 172, 1462, 1, 0, 0, 0, 174, 1468, 1, 0, 0, 0, 176, 1476, 1, 0, 0, 0,
		178, 1478, 1, 0, 0, 0, 180, 1481, 1, 0, 0, 0, 182, 1493, 1, 0, 0, 0, 184,
		1498, 1, 0, 0, 0, 186, 1502, 1, 0, 0, 0, 188, 1504, 1, 0, 0, 0, 190, 1525,
		1, 0, 0, 0, 192, 1529, 1, 0, 0, 0, 194, 1547, 1, 0, 0, 0, 196, 1557, 1,
		0, 0, 0, 198, 1561, 1, 0, 0, 0, 200, 1583, 1, 0, 0, 0, 202, 1595, 1, 0,
		0, 0, 204, 1598, 1, 0, 0, 0, 206, 1602, 1, 0, 0, 0, 208, 1610, 1, 0, 0,
		0, 210, 1629, 1, 0, 0, 0, 212, 1638, 1, 0, 0, 0, 214, 1640, 1, 0, 0, 0,
		216, 1652, 1, 0, 0, 0, 218, 1654, 1, 0, 0, 0, 220, 1657, 1, 0, 0, 0, 222,
		1659, 1, 0, 0, 0, 224, 1677, 1, 0, 0, 0, 226, 1697, 1, 0, 0, 0, 228, 1699,
		1, 0, 0, 0, 230, 1717, 1, 0, 0, 0, 232, 1737, 1, 0, 0, 0, 234, 1742, 1,
		0, 0, 0, 236, 1760, 1, 0, 0, 0, 238, 1778, 1, 0, 0, 0, 240, 1783, 1, 0,
		0, 0, 242, 1786, 1, 0, 0, 0, 244, 1789, 1, 0, 0, 0, 246, 1814, 1, 0, 0,
		0, 248, 1832, 1, 0, 0, 0, 250, 1891, 1, 0, 0, 0, 252, 1893, 1, 0, 0, 0,
		254, 1913, 1, 0, 0, 0, 256, 1915, 1, 0, 0, 0, 258, 1918, 1, 0, 0, 0, 260,
		1946, 1, 0, 0, 0, 262, 1954, 1, 0, 0, 0, 264, 1956, 1, 0, 0, 0, 266, 1958,
		1, 0, 0, 0, 268, 1973, 1, 0, 0, 0, 270, 1975, 1, 0, 0, 0, 272, 1987, 1,
		0, 0, 0, 274, 1996, 1, 0, 0, 0, 276, 2022, 1, 0, 0, 0, 278, 2024, 1, 0,
		0, 0, 280, 2037, 1, 0, 0, 0, 282, 2039, 1, 0, 0, 0, 284, 2044, 1, 0, 0,
		0, 286, 2048, 1, 0, 0, 0, 288, 2052, 1, 0, 0, 0, 290, 2059, 1, 0, 0, 0,
		292, 2065, 1, 0, 0, 0, 294, 2084, 1, 0, 0, 0, 296, 2158, 1, 0, 0, 0, 298,
		2161, 1, 0, 0, 0, 300, 2170, 1, 0, 0, 0, 302, 2180, 1, 0, 0, 0, 304, 2184,
		1, 0, 0, 0, 306, 2186, 1, 0, 0, 0, 308, 2204, 1, 0, 0, 0, 310, 2226, 1,
		0, 0, 0, 312, 2232, 1, 0, 0, 0, 314, 2238, 1, 0, 0, 0, 316, 2245, 1, 0,
		0, 0, 318, 2259, 1, 0, 0, 0, 320, 2261, 1, 0, 0, 0, 322, 2270, 1, 0, 0,
		0, 324, 2288, 1, 0, 0, 0, 326, 2294, 1, 0, 0, 0, 328, 2298, 1, 0, 0, 0,
		330, 2300, 1, 0, 0, 0, 332, 2308, 1, 0, 0, 0, 334, 2310, 1, 0, 0, 0, 336,
		2312, 1, 0, 0, 0, 338, 2314, 1, 0, 0, 0, 340, 2322, 1, 0, 0, 0, 342, 2330,
		1, 0, 0, 0, 344, 2332, 1, 0, 0, 0, 346, 2334, 1, 0, 0, 0, 348, 2336, 1,
		0, 0, 0, 350, 2338, 1, 0, 0, 0, 352, 2345, 1, 0, 0, 0, 354, 2349, 1, 0,
		0, 0, 356, 2351, 1, 0, 0, 0, 358, 2363, 1, 0, 0, 0, 360, 2367, 1, 0, 0,
		0, 362, 2373, 1, 0, 0, 0, 364, 2377, 1, 0, 0, 0, 366, 2379, 1, 0, 0, 0,
		368, 2383, 1, 0, 0, 0, 370, 2389, 1, 0, 0, 0, 372, 2391, 1, 0, 0, 0, 374,
		2393, 1, 0, 0, 0, 376, 2403, 1, 0, 0, 0, 378, 2405, 1, 0, 0, 0, 380, 2407,
		1, 0, 0, 0, 382, 2409, 1, 0, 0, 0, 384, 2411, 1, 0, 0, 0, 386, 2423, 1,
		0, 0, 0, 388, 2435, 1, 0, 0, 0, 390, 392, 5, 88, 0, 0, 391, 390, 1, 0,
		0, 0, 392, 395, 1, 0, 0, 0, 393, 391, 1, 0, 0, 0, 393, 394, 1, 0, 0, 0,
		394, 397, 1, 0, 0, 0, 395, 393, 1, 0, 0, 0, 396, 398, 3, 10, 5, 0, 397,
		396, 1, 0, 0, 0, 397, 398, 1, 0, 0, 0, 398, 402, 1, 0, 0, 0, 399, 401,
		5, 88, 0, 0, 400, 399, 1, 0, 0, 0, 401, 404, 1, 0, 0, 0, 402, 400, 1, 0,
		0, 0, 402, 403, 1, 0, 0, 0, 403, 405, 1, 0, 0, 0, 404, 402, 1, 0, 0, 0,
		405, 406, 5, 0, 0, 1, 406, 1, 1, 0, 0, 0, 407, 418, 3, 56, 28, 0, 408,
		411, 3, 196, 98, 0, 409, 412, 3, 4, 2, 0, 410, 412, 3, 6, 3, 0, 411, 409,
		1, 0, 0, 0, 411, 410, 1, 0, 0, 0, 411, 412, 1, 0, 0, 0, 412, 418, 1, 0,
		0, 0, 413, 418, 3, 12, 6, 0, 414, 418, 3, 24, 12, 0, 415, 418, 3, 36, 18,
		0, 416, 418, 3, 8, 4, 0, 417, 407, 1, 0, 0, 0, 417, 408, 1, 0, 0, 0, 417,
		413, 1, 0, 0, 0, 417, 414, 1, 0, 0, 0, 417, 415, 1, 0, 0, 0, 417, 416,
		1, 0, 0, 0, 418, 3, 1, 0, 0, 0, 419, 420, 5, 12, 0, 0, 420, 421, 3, 196,
		98, 0, 421, 5, 1, 0, 0, 0, 422, 423, 5, 27, 0, 0, 423, 424, 3, 196, 98,
		0, 424, 7, 1, 0, 0, 0, 425, 426, 3, 338, 169, 0, 426, 9, 1, 0, 0, 0, 427,
		439, 3, 2, 1, 0, 428, 432, 3, 382, 191, 0, 429, 431, 5, 88, 0, 0, 430,
		429, 1, 0, 0, 0, 431, 434, 1, 0, 0, 0, 432, 430, 1, 0, 0, 0, 432, 433,
		1, 0, 0, 0, 433, 435, 1, 0, 0, 0, 434, 432, 1, 0, 0, 0, 435, 436, 3, 2,
		1, 0, 436, 438, 1, 0, 0, 0, 437, 428, 1, 0, 0, 0, 438, 441, 1, 0, 0, 0,
		439, 437, 1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 443, 1, 0, 0, 0, 441,
		439, 1, 0, 0, 0, 442, 444, 5, 38, 0, 0, 443, 442, 1, 0, 0, 0, 443, 444,
		1, 0, 0, 0, 444, 11, 1, 0, 0, 0, 445, 448, 3, 14, 7, 0, 446, 448, 3, 16,
		8, 0, 447, 445, 1, 0, 0, 0, 447, 446, 1, 0, 0, 0, 448, 13, 1, 0, 0, 0,
		449, 450, 5, 10, 0, 0, 450, 454, 3, 166, 83, 0, 451, 453, 5, 88, 0, 0,
		452, 451, 1, 0, 0, 0, 453, 456, 1, 0, 0, 0, 454, 452, 1, 0, 0, 0, 454,
		455, 1, 0, 0, 0, 455, 457, 1, 0, 0, 0, 456, 454, 1, 0, 0, 0, 457, 458,
		5, 14, 0, 0, 458, 462, 3, 196, 98, 0, 459, 461, 5, 88, 0, 0, 460, 459,
		1, 0, 0, 0, 461, 464, 1, 0, 0, 0, 462, 460, 1, 0, 0, 0, 462, 463, 1, 0,
		0, 0, 463, 465, 1, 0, 0, 0, 464, 462, 1, 0, 0, 0, 465, 466, 3, 58, 29,
		0, 466, 15, 1, 0, 0, 0, 467, 468, 5, 27, 0, 0, 468, 472, 3, 18, 9, 0, 469,
		471, 5, 88, 0, 0, 470, 469, 1, 0, 0, 0, 471, 474, 1, 0, 0, 0, 472, 470,
		1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473, 475, 1, 0, 0, 0, 474, 472, 1, 0,
		0, 0, 475, 476, 3, 58, 29, 0, 476, 17, 1, 0, 0, 0, 477, 489, 3, 20, 10,
		0, 478, 482, 3, 384, 192, 0, 479, 481, 5, 88, 0, 0, 480, 479, 1, 0, 0,
		0, 481, 484, 1, 0, 0, 0, 482, 480, 1, 0, 0, 0, 482, 483, 1, 0, 0, 0, 483,
		485, 1, 0, 0, 0, 484, 482, 1, 0, 0, 0, 485, 486, 3, 20, 10, 0, 486, 488,
		1, 0, 0, 0, 487, 478, 1, 0, 0, 0, 488, 491, 1, 0, 0, 0, 489, 487, 1, 0,
		0, 0, 489, 490, 1, 0, 0, 0, 490, 19, 1, 0, 0, 0, 491, 489, 1, 0, 0, 0,
		492, 495, 3, 196, 98, 0, 493, 495, 3, 22, 11, 0, 494, 492, 1, 0, 0, 0,
		494, 493, 1, 0, 0, 0, 495, 21, 1, 0, 0, 0, 496, 497, 5, 26, 0, 0, 497,
		501, 3, 166, 83, 0, 498, 500, 5, 88, 0, 0, 499, 498, 1, 0, 0, 0, 500, 503,
		1, 0, 0, 0, 501, 499, 1, 0, 0, 0, 501, 502, 1, 0, 0, 0, 502, 504, 1, 0,
		0, 0, 503, 501, 1, 0, 0, 0, 504, 505, 3, 96, 48, 0, 505, 23, 1, 0, 0, 0,
		506, 509, 3, 26, 13, 0, 507, 509, 3, 30, 15, 0, 508, 506, 1, 0, 0, 0, 508,
		507, 1, 0, 0, 0, 509, 25, 1, 0, 0, 0, 510, 511, 5, 12, 0, 0, 511, 515,
		3, 18, 9, 0, 512, 514, 5, 88, 0, 0, 513, 512, 1, 0, 0, 0, 514, 517, 1,
		0, 0, 0, 515, 513, 1, 0, 0, 0, 515, 516, 1, 0, 0, 0, 516, 518, 1, 0, 0,
		0, 517, 515, 1, 0, 0, 0, 518, 522, 3, 58, 29, 0, 519, 521, 5, 88, 0, 0,
		520, 519, 1, 0, 0, 0, 521, 524, 1, 0, 0, 0, 522, 520, 1, 0, 0, 0, 522,
		523, 1, 0, 0, 0, 523, 526, 1, 0, 0, 0, 524, 522, 1, 0, 0, 0, 525, 527,
		3, 28, 14, 0, 526, 525, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 27, 1, 0,
		0, 0, 528, 532, 5, 7, 0, 0, 529, 531, 5, 88, 0, 0, 530, 529, 1, 0, 0, 0,
		531, 534, 1, 0, 0, 0, 532, 530, 1, 0, 0, 0, 532, 533, 1, 0, 0, 0, 533,
		535, 1, 0, 0, 0, 534, 532, 1, 0, 0, 0, 535, 545, 3, 58, 29, 0, 536, 540,
		5, 7, 0, 0, 537, 539, 5, 88, 0, 0, 538, 537, 1, 0, 0, 0, 539, 542, 1, 0,
		0, 0, 540, 538, 1, 0, 0, 0, 540, 541, 1, 0, 0, 0, 541, 543, 1, 0, 0, 0,
		542, 540, 1, 0, 0, 0, 543, 545, 3, 26, 13, 0, 544, 528, 1, 0, 0, 0, 544,
		536, 1, 0, 0, 0, 545, 29, 1, 0, 0, 0, 546, 547, 5, 17, 0, 0, 547, 551,
		3, 196, 98, 0, 548, 550, 5, 88, 0, 0, 549, 548, 1, 0, 0, 0, 550, 553, 1,
		0, 0, 0, 551, 549, 1, 0, 0, 0, 551, 552, 1, 0, 0, 0, 552, 554, 1, 0, 0,
		0, 553, 551, 1, 0, 0, 0, 554, 562, 5, 30, 0, 0, 555, 557, 5, 88, 0, 0,
		556, 555, 1, 0, 0, 0, 557, 560, 1, 0, 0, 0, 558, 556, 1, 0, 0, 0, 558,
		559, 1, 0, 0, 0, 559, 561, 1, 0, 0, 0, 560, 558, 1, 0, 0, 0, 561, 563,
		3, 32, 16, 0, 562, 558, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 567, 1,
		0, 0, 0, 564, 566, 5, 88, 0, 0, 565, 564, 1, 0, 0, 0, 566, 569, 1, 0, 0,
		0, 567, 565, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 570, 1, 0, 0, 0, 569,
		567, 1, 0, 0, 0, 570, 571, 5, 33, 0, 0, 571, 31, 1, 0, 0, 0, 572, 584,
		3, 34, 17, 0, 573, 577, 3, 382, 191, 0, 574, 576, 5, 88, 0, 0, 575, 574,
		1, 0, 0, 0, 576, 579, 1, 0, 0, 0, 577, 575, 1, 0, 0, 0, 577, 578, 1, 0,
		0, 0, 578, 580, 1, 0, 0, 0, 579, 577, 1, 0, 0, 0, 580, 581, 3, 34, 17,
		0, 581, 583, 1, 0, 0, 0, 582, 573, 1, 0, 0, 0, 583, 586, 1, 0, 0, 0, 584,
		582, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 588, 1, 0, 0, 0, 586, 584,
		1, 0, 0, 0, 587, 589, 3, 382, 191, 0, 588, 587, 1, 0, 0, 0, 588, 589, 1,
		0, 0, 0, 589, 33, 1, 0, 0, 0, 590, 592, 3, 166, 83, 0, 591, 593, 3, 4,
		2, 0, 592, 591, 1, 0, 0, 0, 592, 593, 1, 0, 0, 0, 593, 597, 1, 0, 0, 0,
		594, 596, 5, 88, 0, 0, 595, 594, 1, 0, 0, 0, 596, 599, 1, 0, 0, 0, 597,
		595, 1, 0, 0, 0, 597, 598, 1, 0, 0, 0, 598, 600, 1, 0, 0, 0, 599, 597,
		1, 0, 0, 0, 600, 604, 5, 60, 0, 0, 601, 603, 5, 88, 0, 0, 602, 601, 1,
		0, 0, 0, 603, 606, 1, 0, 0, 0, 604, 602, 1, 0, 0, 0, 604, 605, 1, 0, 0,
		0, 605, 609, 1, 0, 0, 0, 606, 604, 1, 0, 0, 0, 607, 610, 3, 58, 29, 0,
		608, 610, 3, 196, 98, 0, 609, 607, 1, 0, 0, 0, 609, 608, 1, 0, 0, 0, 610,
		35, 1, 0, 0, 0, 611, 615, 3, 38, 19, 0, 612, 615, 3, 40, 20, 0, 613, 615,
		3, 42, 21, 0, 614, 611, 1, 0, 0, 0, 614, 612, 1, 0, 0, 0, 614, 613, 1,
		0, 0, 0, 615, 37, 1, 0, 0, 0, 616, 617, 5, 4, 0, 0, 617, 39, 1, 0, 0, 0,
		618, 619, 5, 6, 0, 0, 619, 41, 1, 0, 0, 0, 620, 622, 5, 22, 0, 0, 621,
		623, 3, 196, 98, 0, 622, 621, 1, 0, 0, 0, 622, 623, 1, 0, 0, 0, 623, 43,
		1, 0, 0, 0, 624, 628, 5, 39, 0, 0, 625, 627, 5, 88, 0, 0, 626, 625, 1,
		0, 0, 0, 627, 630, 1, 0, 0, 0, 628, 626, 1, 0, 0, 0, 628, 629, 1, 0, 0,
		0, 629, 631, 1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 631, 635, 3, 46, 23, 0,
		632, 634, 5, 88, 0, 0, 633, 632, 1, 0, 0, 0, 634, 637, 1, 0, 0, 0, 635,
		633, 1, 0, 0, 0, 635, 636, 1, 0, 0, 0, 636, 638, 1, 0, 0, 0, 637, 635,
		1, 0, 0, 0, 638, 639, 5, 40, 0, 0, 639, 45, 1, 0, 0, 0, 640, 652, 3, 48,
		24, 0, 641, 645, 3, 388, 194, 0, 642, 644, 5, 88, 0, 0, 643, 642, 1, 0,
		0, 0, 644, 647, 1, 0, 0, 0, 645, 643, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0,
		646, 648, 1, 0, 0, 0, 647, 645, 1, 0, 0, 0, 648, 649, 3, 48, 24, 0, 649,
		651, 1, 0, 0, 0, 650, 641, 1, 0, 0, 0, 651, 654, 1, 0, 0, 0, 652, 650,
		1, 0, 0, 0, 652, 653, 1, 0, 0, 0, 653, 656, 1, 0, 0, 0, 654, 652, 1, 0,
		0, 0, 655, 657, 3, 388, 194, 0, 656, 655, 1, 0, 0, 0, 656, 657, 1, 0, 0,
		0, 657, 47, 1, 0, 0, 0, 658, 666, 3, 304, 152, 0, 659, 660, 3, 304, 152,
		0, 660, 661, 5, 64, 0, 0, 661, 666, 1, 0, 0, 0, 662, 663, 3, 304, 152,
		0, 663, 664, 3, 298, 149, 0, 664, 666, 1, 0, 0, 0, 665, 658, 1, 0, 0, 0,
		665, 659, 1, 0, 0, 0, 665, 662, 1, 0, 0, 0, 666, 49, 1, 0, 0, 0, 667, 671,
		5, 39, 0, 0, 668, 670, 5, 88, 0, 0, 669, 668, 1, 0, 0, 0, 670, 673, 1,
		0, 0, 0, 671, 669, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 674, 1, 0, 0,
		0, 673, 671, 1, 0, 0, 0, 674, 678, 3, 52, 26, 0, 675, 677, 5, 88, 0, 0,
		676, 675, 1, 0, 0, 0, 677, 680, 1, 0, 0, 0, 678, 676, 1, 0, 0, 0, 678,
		679, 1, 0, 0, 0, 679, 681, 1, 0, 0, 0, 680, 678, 1, 0, 0, 0, 681, 682,
		5, 40, 0, 0, 682, 51, 1, 0, 0, 0, 683, 695, 3, 54, 27, 0, 684, 688, 3,
		384, 192, 0, 685, 687, 5, 88, 0, 0, 686, 685, 1, 0, 0, 0, 687, 690, 1,
		0, 0, 0, 688, 686, 1, 0, 0, 0, 688, 689, 1, 0, 0, 0, 689, 691, 1, 0, 0,
		0, 690, 688, 1, 0, 0, 0, 691, 692, 3, 54, 27, 0, 692, 694, 1, 0, 0, 0,
		693, 684, 1, 0, 0, 0, 694, 697, 1, 0, 0, 0, 695, 693, 1, 0, 0, 0, 695,
		696, 1, 0, 0, 0, 696, 53, 1, 0, 0, 0, 697, 695, 1, 0, 0, 0, 698, 700, 3,
		292, 146, 0, 699, 701, 3, 194, 97, 0, 700, 699, 1, 0, 0, 0, 700, 701, 1,
		0, 0, 0, 701, 55, 1, 0, 0, 0, 702, 703, 3, 338, 169, 0, 703, 704, 5, 88,
		0, 0, 704, 706, 1, 0, 0, 0, 705, 702, 1, 0, 0, 0, 705, 706, 1, 0, 0, 0,
		706, 714, 1, 0, 0, 0, 707, 711, 3, 194, 97, 0, 708, 710, 5, 88, 0, 0, 709,
		708, 1, 0, 0, 0, 710, 713, 1, 0, 0, 0, 711, 709, 1, 0, 0, 0, 711, 712,
		1, 0, 0, 0, 712, 715, 1, 0, 0, 0, 713, 711, 1, 0, 0, 0, 714, 707, 1, 0,
		0, 0, 714, 715, 1, 0, 0, 0, 715, 727, 1, 0, 0, 0, 716, 728, 3, 60, 30,
		0, 717, 728, 3, 66, 33, 0, 718, 728, 3, 88, 44, 0, 719, 728, 3, 98, 49,
		0, 720, 728, 3, 100, 50, 0, 721, 728, 3, 106, 53, 0, 722, 728, 3, 122,
		61, 0, 723, 728, 3, 132, 66, 0, 724, 728, 3, 146, 73, 0, 725, 728, 3, 160,
		80, 0, 726, 728, 3, 162, 81, 0, 727, 716, 1, 0, 0, 0, 727, 717, 1, 0, 0,
		0, 727, 718, 1, 0, 0, 0, 727, 719, 1, 0, 0, 0, 727, 720, 1, 0, 0, 0, 727,
		721, 1, 0, 0, 0, 727, 722, 1, 0, 0, 0, 727, 723, 1, 0, 0, 0, 727, 724,
		1, 0, 0, 0, 727, 725, 1, 0, 0, 0, 727, 726, 1, 0, 0, 0, 728, 57, 1, 0,
		0, 0, 729, 737, 5, 30, 0, 0, 730, 732, 5, 88, 0, 0, 731, 730, 1, 0, 0,
		0, 732, 735, 1, 0, 0, 0, 733, 731, 1, 0, 0, 0, 733, 734, 1, 0, 0, 0, 734,
		736, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 736, 738, 3, 10, 5, 0, 737, 733,
		1, 0, 0, 0, 737, 738, 1, 0, 0, 0, 738, 742, 1, 0, 0, 0, 739, 741, 5, 88,
		0, 0, 740, 739, 1, 0, 0, 0, 741, 744, 1, 0, 0, 0, 742, 740, 1, 0, 0, 0,
		742, 743, 1, 0, 0, 0, 743, 745, 1, 0, 0, 0, 744, 742, 1, 0, 0, 0, 745,
		746, 5, 33, 0, 0, 746, 59, 1, 0, 0, 0, 747, 748, 5, 21, 0, 0, 748, 756,
		3, 62, 31, 0, 749, 751, 5, 88, 0, 0, 750, 749, 1, 0, 0, 0, 751, 754, 1,
		0, 0, 0, 752, 750, 1, 0, 0, 0, 752, 753, 1, 0, 0, 0, 753, 755, 1, 0, 0,
		0, 754, 752, 1, 0, 0, 0, 755, 757, 3, 234, 117, 0, 756, 752, 1, 0, 0, 0,
		756, 757, 1, 0, 0, 0, 757, 61, 1, 0, 0, 0, 758, 763, 3, 64, 32, 0, 759,
		760, 5, 29, 0, 0, 760, 762, 3, 64, 32, 0, 761, 759, 1, 0, 0, 0, 762, 765,
		1, 0, 0, 0, 763, 761, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 63, 1, 0,
		0, 0, 765, 763, 1, 0, 0, 0, 766, 767, 5, 73, 0, 0, 767, 65, 1, 0, 0, 0,
		768, 769, 5, 13, 0, 0, 769, 774, 3, 68, 34, 0, 770, 775, 3, 72, 36, 0,
		771, 775, 3, 74, 37, 0, 772, 775, 3, 76, 38, 0, 773, 775, 3, 80, 40, 0,
		774, 770, 1, 0, 0, 0, 774, 771, 1, 0, 0, 0, 774, 772, 1, 0, 0, 0, 774,
		773, 1, 0, 0, 0, 774, 775, 1, 0, 0, 0, 775, 67, 1, 0, 0, 0, 776, 781, 3,
		70, 35, 0, 777, 778, 5, 29, 0, 0, 778, 780, 3, 70, 35, 0, 779, 777, 1,
		0, 0, 0, 780, 783, 1, 0, 0, 0, 781, 779, 1, 0, 0, 0, 781, 782, 1, 0, 0,
		0, 782, 69, 1, 0, 0, 0, 783, 781, 1, 0, 0, 0, 784, 785, 3, 326, 163, 0,
		785, 71, 1, 0, 0, 0, 786, 787, 5, 29, 0, 0, 787, 788, 5, 50, 0, 0, 788,
		73, 1, 0, 0, 0, 789, 790, 5, 2, 0, 0, 790, 791, 3, 326, 163, 0, 791, 75,
		1, 0, 0, 0, 792, 793, 5, 29, 0, 0, 793, 795, 3, 304, 152, 0, 794, 796,
		3, 78, 39, 0, 795, 794, 1, 0, 0, 0, 795, 796, 1, 0, 0, 0, 796, 77, 1, 0,
		0, 0, 797, 798, 5, 2, 0, 0, 798, 799, 3, 304, 152, 0, 799, 79, 1, 0, 0,
		0, 800, 801, 5, 29, 0, 0, 801, 805, 5, 30, 0, 0, 802, 804, 5, 88, 0, 0,
		803, 802, 1, 0, 0, 0, 804, 807, 1, 0, 0, 0, 805, 803, 1, 0, 0, 0, 805,
		806, 1, 0, 0, 0, 806, 808, 1, 0, 0, 0, 807, 805, 1, 0, 0, 0, 808, 812,
		3, 82, 41, 0, 809, 811, 5, 88, 0, 0, 810, 809, 1, 0, 0, 0, 811, 814, 1,
		0, 0, 0, 812, 810, 1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813, 815, 1, 0, 0,
		0, 814, 812, 1, 0, 0, 0, 815, 816, 5, 33, 0, 0, 816, 81, 1, 0, 0, 0, 817,
		820, 3, 84, 42, 0, 818, 820, 3, 86, 43, 0, 819, 817, 1, 0, 0, 0, 819, 818,
		1, 0, 0, 0, 820, 834, 1, 0, 0, 0, 821, 825, 3, 384, 192, 0, 822, 824, 5,
		88, 0, 0, 823, 822, 1, 0, 0, 0, 824, 827, 1, 0, 0, 0, 825, 823, 1, 0, 0,
		0, 825, 826, 1, 0, 0, 0, 826, 830, 1, 0, 0, 0, 827, 825, 1, 0, 0, 0, 828,
		831, 3, 84, 42, 0, 829, 831, 3, 86, 43, 0, 830, 828, 1, 0, 0, 0, 830, 829,
		1, 0, 0, 0, 831, 833, 1, 0, 0, 0, 832, 821, 1, 0, 0, 0, 833, 836, 1, 0,
		0, 0, 834, 832, 1, 0, 0, 0, 834, 835, 1, 0, 0, 0, 835, 838, 1, 0, 0, 0,
		836, 834, 1, 0, 0, 0, 837, 839, 3, 384, 192, 0, 838, 837, 1, 0, 0, 0, 838,
		839, 1, 0, 0, 0, 839, 83, 1, 0, 0, 0, 840, 842, 3, 326, 163, 0, 841, 843,
		3, 74, 37, 0, 842, 841, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 843, 85, 1, 0,
		0, 0, 844, 846, 3, 304, 152, 0, 845, 847, 3, 78, 39, 0, 846, 845, 1, 0,
		0, 0, 846, 847, 1, 0, 0, 0, 847, 87, 1, 0, 0, 0, 848, 849, 5, 5, 0, 0,
		849, 850, 3, 90, 45, 0, 850, 89, 1, 0, 0, 0, 851, 863, 3, 94, 47, 0, 852,
		856, 3, 384, 192, 0, 853, 855, 5, 88, 0, 0, 854, 853, 1, 0, 0, 0, 855,
		858, 1, 0, 0, 0, 856, 854, 1, 0, 0, 0, 856, 857, 1, 0, 0, 0, 857, 859,
		1, 0, 0, 0, 858, 856, 1, 0, 0, 0, 859, 860, 3, 94, 47, 0, 860, 862, 1,
		0, 0, 0, 861, 852, 1, 0, 0, 0, 862, 865, 1, 0, 0, 0, 863, 861, 1, 0, 0,
		0, 863, 864, 1, 0, 0, 0, 864, 900, 1, 0, 0, 0, 865, 863, 1, 0, 0, 0, 866,
		870, 5, 30, 0, 0, 867, 869, 5, 88, 0, 0, 868, 867, 1, 0, 0, 0, 869, 872,
		1, 0, 0, 0, 870, 868, 1, 0, 0, 0, 870, 871, 1, 0, 0, 0, 871, 873, 1, 0,
		0, 0, 872, 870, 1, 0, 0, 0, 873, 885, 3, 92, 46, 0, 874, 878, 3, 384, 192,
		0, 875, 877, 5, 88, 0, 0, 876, 875, 1, 0, 0, 0, 877, 880, 1, 0, 0, 0, 878,
		876, 1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879, 881, 1, 0, 0, 0, 880, 878,
		1, 0, 0, 0, 881, 882, 3, 92, 46, 0, 882, 884, 1, 0, 0, 0, 883, 874, 1,
		0, 0, 0, 884, 887, 1, 0, 0, 0, 885, 883, 1, 0, 0, 0, 885, 886, 1, 0, 0,
		0, 886, 889, 1, 0, 0, 0, 887, 885, 1, 0, 0, 0, 888, 890, 3, 384, 192, 0,
		889, 888, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890, 894, 1, 0, 0, 0, 891,
		893, 5, 88, 0, 0, 892, 891, 1, 0, 0, 0, 893, 896, 1, 0, 0, 0, 894, 892,
		1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895, 897, 1, 0, 0, 0, 896, 894, 1, 0,
		0, 0, 897, 898, 5, 33, 0, 0, 898, 900, 1, 0, 0, 0, 899, 851, 1, 0, 0, 0,
		899, 866, 1, 0, 0, 0, 900, 91, 1, 0, 0, 0, 901, 902, 3, 338, 169, 0, 902,
		903, 5, 88, 0, 0, 903, 905, 1, 0, 0, 0, 904, 901, 1, 0, 0, 0, 904, 905,
		1, 0, 0, 0, 905, 909, 1, 0, 0, 0, 906, 907, 3, 194, 97, 0, 907, 908, 5,
		88, 0, 0, 908, 910, 1, 0, 0, 0, 909, 906, 1, 0, 0, 0, 909, 910, 1, 0, 0,
		0, 910, 911, 1, 0, 0, 0, 911, 912, 3, 94, 47, 0, 912, 93, 1, 0, 0, 0, 913,
		915, 3, 166, 83, 0, 914, 916, 3, 96, 48, 0, 915, 914, 1, 0, 0, 0, 915,
		916, 1, 0, 0, 0, 916, 95, 1, 0, 0, 0, 917, 921, 3, 342, 171, 0, 918, 920,
		5, 88, 0, 0, 919, 918, 1, 0, 0, 0, 920, 923, 1, 0, 0, 0, 921, 919, 1, 0,
		0, 0, 921, 922, 1, 0, 0, 0, 922, 924, 1, 0, 0, 0, 923, 921, 1, 0, 0, 0,
		924, 925, 3, 196, 98, 0, 925, 97, 1, 0, 0, 0, 926, 927, 5, 26, 0, 0, 927,
		933, 3, 90, 45, 0, 928, 929, 3, 170, 85, 0, 929, 930, 5, 59, 0, 0, 930,
		931, 3, 196, 98, 0, 931, 933, 1, 0, 0, 0, 932, 926, 1, 0, 0, 0, 932, 928,
		1, 0, 0, 0, 933, 99, 1, 0, 0, 0, 934, 935, 5, 25, 0, 0, 935, 937, 3, 102,
		51, 0, 936, 938, 3, 44, 22, 0, 937, 936, 1, 0, 0, 0, 937, 938, 1, 0, 0,
		0, 938, 942, 1, 0, 0, 0, 939, 941, 5, 88, 0, 0, 940, 939, 1, 0, 0, 0, 941,
		944, 1, 0, 0, 0, 942, 940, 1, 0, 0, 0, 942, 943, 1, 0, 0, 0, 943, 945,
		1, 0, 0, 0, 944, 942, 1, 0, 0, 0, 945, 946, 3, 104, 52, 0, 946, 101, 1,
		0, 0, 0, 947, 948, 3, 304, 152, 0, 948, 103, 1, 0, 0, 0, 949, 953, 3, 342,
		171, 0, 950, 952, 5, 88, 0, 0, 951, 950, 1, 0, 0, 0, 952, 955, 1, 0, 0,
		0, 953, 951, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954, 956, 1, 0, 0, 0, 955,
		953, 1, 0, 0, 0, 956, 958, 3, 292, 146, 0, 957, 959, 3, 194, 97, 0, 958,
		957, 1, 0, 0, 0, 958, 959, 1, 0, 0, 0, 959, 961, 1, 0, 0, 0, 960, 962,
		3, 340, 170, 0, 961, 960, 1, 0, 0, 0, 961, 962, 1, 0, 0, 0, 962, 105, 1,
		0, 0, 0, 963, 964, 5, 11, 0, 0, 964, 966, 3, 108, 54, 0, 965, 967, 3, 44,
		22, 0, 966, 965, 1, 0, 0, 0, 966, 967, 1, 0, 0, 0, 967, 968, 1, 0, 0, 0,
		968, 976, 3, 110, 55, 0, 969, 971, 5, 88, 0, 0, 970, 969, 1, 0, 0, 0, 971,
		974, 1, 0, 0, 0, 972, 970, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0, 973, 975,
		1, 0, 0, 0, 974, 972, 1, 0, 0, 0, 975, 977, 3, 114, 57, 0, 976, 972, 1,
		0, 0, 0, 976, 977, 1, 0, 0, 0, 977, 107, 1, 0, 0, 0, 978, 981, 3, 326,
		163, 0, 979, 981, 3, 358, 179, 0, 980, 978, 1, 0, 0, 0, 980, 979, 1, 0,
		0, 0, 981, 109, 1, 0, 0, 0, 982, 984, 3, 116, 58, 0, 983, 985, 3, 340,
		170, 0, 984, 983, 1, 0, 0, 0, 984, 985, 1, 0, 0, 0, 985, 993, 1, 0, 0,
		0, 986, 988, 5, 88, 0, 0, 987, 986, 1, 0, 0, 0, 988, 991, 1, 0, 0, 0, 989,
		987, 1, 0, 0, 0, 989, 990, 1, 0, 0, 0, 990, 992, 1, 0, 0, 0, 991, 989,
		1, 0, 0, 0, 992, 994, 3, 112, 56, 0, 993, 989, 1, 0, 0, 0, 993, 994, 1,
		0, 0, 0, 994, 111, 1, 0, 0, 0, 995, 1000, 3, 346, 173, 0, 996, 998, 3,
		328, 164, 0, 997, 999, 5, 37, 0, 0, 998, 997, 1, 0, 0, 0, 998, 999, 1,
		0, 0, 0, 999, 1001, 1, 0, 0, 0, 1000, 996, 1, 0, 0, 0, 1000, 1001, 1, 0,
		0, 0, 1001, 1002, 1, 0, 0, 0, 1002, 1004, 3, 292, 146, 0, 1003, 1005, 3,
		194, 97, 0, 1004, 1003, 1, 0, 0, 0, 1004, 1005, 1, 0, 0, 0, 1005, 1013,
		1, 0, 0, 0, 1006, 1008, 5, 88, 0, 0, 1007, 1006, 1, 0, 0, 0, 1008, 1011,
		1, 0, 0, 0, 1009, 1007, 1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 1012,
		1, 0, 0, 0, 1011, 1009, 1, 0, 0, 0, 1012, 1014, 3, 340, 170, 0, 1013, 1009,
		1, 0, 0, 0, 1013, 1014, 1, 0, 0, 0, 1014, 113, 1, 0, 0, 0, 1015, 1017,
		5, 30, 0, 0, 1016, 1018, 3, 340, 170, 0, 1017, 1016, 1, 0, 0, 0, 1017,
		1018, 1, 0, 0, 0, 1018, 1026, 1, 0, 0, 0, 1019, 1021, 5, 88, 0, 0, 1020,
		1019, 1, 0, 0, 0, 1021, 1024, 1, 0, 0, 0, 1022, 1020, 1, 0, 0, 0, 1022,
		1023, 1, 0, 0, 0, 1023, 1025, 1, 0, 0, 0, 1024, 1022, 1, 0, 0, 0, 1025,
		1027, 3, 10, 5, 0, 1026, 1022, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027,
		1031, 1, 0, 0, 0, 1028, 1030, 5, 88, 0, 0, 1029, 1028, 1, 0, 0, 0, 1030,
		1033, 1, 0, 0, 0, 1031, 1029, 1, 0, 0, 0, 1031, 1032, 1, 0, 0, 0, 1032,
		1034, 1, 0, 0, 0, 1033, 1031, 1, 0, 0, 0, 1034, 1035, 5, 33, 0, 0, 1035,
		115, 1, 0, 0, 0, 1036, 1037, 5, 31, 0, 0, 1037, 1055, 5, 34, 0, 0, 1038,
		1042, 5, 31, 0, 0, 1039, 1041, 5, 88, 0, 0, 1040, 1039, 1, 0, 0, 0, 1041,
		1044, 1, 0, 0, 0, 1042, 1040, 1, 0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043,
		1045, 1, 0, 0, 0, 1044, 1042, 1, 0, 0, 0, 1045, 1049, 3, 118, 59, 0, 1046,
		1048, 5, 88, 0, 0, 1047, 1046, 1, 0, 0, 0, 1048, 1051, 1, 0, 0, 0, 1049,
		1047, 1, 0, 0, 0, 1049, 1050, 1, 0, 0, 0, 1050, 1052, 1, 0, 0, 0, 1051,
		1049, 1, 0, 0, 0, 1052, 1053, 5, 34, 0, 0, 1053, 1055, 1, 0, 0, 0, 1054,
		1036, 1, 0, 0, 0, 1054, 1038, 1, 0, 0, 0, 1055, 117, 1, 0, 0, 0, 1056,
		1068, 3, 120, 60, 0, 1057, 1061, 3, 388, 194, 0, 1058, 1060, 5, 88, 0,
		0, 1059, 1058, 1, 0, 0, 0, 1060, 1063, 1, 0, 0, 0, 1061, 1059, 1, 0, 0,
		0, 1061, 1062, 1, 0, 0, 0, 1062, 1064, 1, 0, 0, 0, 1063, 1061, 1, 0, 0,
		0, 1064, 1065, 3, 120, 60, 0, 1065, 1067, 1, 0, 0, 0, 1066, 1057, 1, 0,
		0, 0, 1067, 1070, 1, 0, 0, 0, 1068, 1066, 1, 0, 0, 0, 1068, 1069, 1, 0,
		0, 0, 1069, 1072, 1, 0, 0, 0, 1070, 1068, 1, 0, 0, 0, 1071, 1073, 3, 388,
		194, 0, 1072, 1071, 1, 0, 0, 0, 1072, 1073, 1, 0, 0, 0, 1073, 119, 1, 0,
		0, 0, 1074, 1075, 3, 328, 164, 0, 1075, 1083, 3, 298, 149, 0, 1076, 1078,
		5, 88, 0, 0, 1077, 1076, 1, 0, 0, 0, 1078, 1081, 1, 0, 0, 0, 1079, 1077,
		1, 0, 0, 0, 1079, 1080, 1, 0, 0, 0, 1080, 1082, 1, 0, 0, 0, 1081, 1079,
		1, 0, 0, 0, 1082, 1084, 3, 96, 48, 0, 1083, 1079, 1, 0, 0, 0, 1083, 1084,
		1, 0, 0, 0, 1084, 1095, 1, 0, 0, 0, 1085, 1087, 3, 328, 164, 0, 1086, 1088,
		5, 37, 0, 0, 1087, 1086, 1, 0, 0, 0, 1087, 1088, 1, 0, 0, 0, 1088, 1089,
		1, 0, 0, 0, 1089, 1090, 3, 292, 146, 0, 1090, 1092, 5, 64, 0, 0, 1091,
		1093, 3, 194, 97, 0, 1092, 1091, 1, 0, 0, 0, 1092, 1093, 1, 0, 0, 0, 1093,
		1095, 1, 0, 0, 0, 1094, 1074, 1, 0, 0, 0, 1094, 1085, 1, 0, 0, 0, 1095,
		121, 1, 0, 0, 0, 1096, 1097, 5, 8, 0, 0, 1097, 1099, 3, 126, 63, 0, 1098,
		1100, 3, 44, 22, 0, 1099, 1098, 1, 0, 0, 0, 1099, 1100, 1, 0, 0, 0, 1100,
		1108, 1, 0, 0, 0, 1101, 1103, 5, 88, 0, 0, 1102, 1101, 1, 0, 0, 0, 1103,
		1106, 1, 0, 0, 0, 1104, 1102, 1, 0, 0, 0, 1104, 1105, 1, 0, 0, 0, 1105,
		1107, 1, 0, 0, 0, 1106, 1104, 1, 0, 0, 0, 1107, 1109, 3, 320, 160, 0, 1108,
		1104, 1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0, 1109, 1113, 1, 0, 0, 0, 1110,
		1112, 5, 88, 0, 0, 1111, 1110, 1, 0, 0, 0, 1112, 1115, 1, 0, 0, 0, 1113,
		1111, 1, 0, 0, 0, 1113, 1114, 1, 0, 0, 0, 1114, 1116, 1, 0, 0, 0, 1115,
		1113, 1, 0, 0, 0, 1116, 1117, 3, 124, 62, 0, 1117, 123, 1, 0, 0, 0, 1118,
		1120, 5, 30, 0, 0, 1119, 1121, 3, 340, 170, 0, 1120, 1119, 1, 0, 0, 0,
		1120, 1121, 1, 0, 0, 0, 1121, 1129, 1, 0, 0, 0, 1122, 1124, 5, 88, 0, 0,
		1123, 1122, 1, 0, 0, 0, 1124, 1127, 1, 0, 0, 0, 1125, 1123, 1, 0, 0, 0,
		1125, 1126, 1, 0, 0, 0, 1126, 1128, 1, 0, 0, 0, 1127, 1125, 1, 0, 0, 0,
		1128, 1130, 3, 128, 64, 0, 1129, 1125, 1, 0, 0, 0, 1129, 1130, 1, 0, 0,
		0, 1130, 1134, 1, 0, 0, 0, 1131, 1133, 5, 88, 0, 0, 1132, 1131, 1, 0, 0,
		0, 1133, 1136, 1, 0, 0, 0, 1134, 1132, 1, 0, 0, 0, 1134, 1135, 1, 0, 0,
		0, 1135, 1137, 1, 0, 0, 0, 1136, 1134, 1, 0, 0, 0, 1137, 1138, 5, 33, 0,
		0, 1138, 125, 1, 0, 0, 0, 1139, 1140, 3, 304, 152, 0, 1140, 127, 1, 0,
		0, 0, 1141, 1153, 3, 130, 65, 0, 1142, 1146, 3, 388, 194, 0, 1143, 1145,
		5, 88, 0, 0, 1144, 1143, 1, 0, 0, 0, 1145, 1148, 1, 0, 0, 0, 1146, 1144,
		1, 0, 0, 0, 1146, 1147, 1, 0, 0, 0, 1147, 1149, 1, 0, 0, 0, 1148, 1146,
		1, 0, 0, 0, 1149, 1150, 3, 130, 65, 0, 1150, 1152, 1, 0, 0, 0, 1151, 1142,
		1, 0, 0, 0, 1152, 1155, 1, 0, 0, 0, 1153, 1151, 1, 0, 0, 0, 1153, 1154,
		1, 0, 0, 0, 1154, 1157, 1, 0, 0, 0, 1155, 1153, 1, 0, 0, 0, 1156, 1158,
		3, 388, 194, 0, 1157, 1156, 1, 0, 0, 0, 1157, 1158, 1, 0, 0, 0, 1158, 129,
		1, 0, 0, 0, 1159, 1160, 3, 338, 169, 0, 1160, 1161, 5, 88, 0, 0, 1161,
		1163, 1, 0, 0, 0, 1162, 1159, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163,
		1167, 1, 0, 0, 0, 1164, 1165, 3, 194, 97, 0, 1165, 1166, 5, 88, 0, 0, 1166,
		1168, 1, 0, 0, 0, 1167, 1164, 1, 0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168,
		1169, 1, 0, 0, 0, 1169, 1171, 3, 326, 163, 0, 1170, 1172, 3, 194, 97, 0,
		1171, 1170, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 1180, 1, 0, 0, 0,
		1173, 1175, 5, 88, 0, 0, 1174, 1173, 1, 0, 0, 0, 1175, 1178, 1, 0, 0, 0,
		1176, 1174, 1, 0, 0, 0, 1176, 1177, 1, 0, 0, 0, 1177, 1179, 1, 0, 0, 0,
		1178, 1176, 1, 0, 0, 0, 1179, 1181, 3, 96, 48, 0, 1180, 1176, 1, 0, 0,
		0, 1180, 1181, 1, 0, 0, 0, 1181, 1184, 1, 0, 0, 0, 1182, 1184, 3, 8, 4,
		0, 1183, 1162, 1, 0, 0, 0, 1183, 1182, 1, 0, 0, 0, 1184, 131, 1, 0, 0,
		0, 1185, 1186, 5, 25, 0, 0, 1186, 1188, 3, 134, 67, 0, 1187, 1189, 3, 44,
		22, 0, 1188, 1187, 1, 0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 1190, 1, 0,
		0, 0, 1190, 1191, 3, 136, 68, 0, 1191, 133, 1, 0, 0, 0, 1192, 1193, 3,
		304, 152, 0, 1193, 135, 1, 0, 0, 0, 1194, 1196, 5, 88, 0, 0, 1195, 1194,
		1, 0, 0, 0, 1196, 1199, 1, 0, 0, 0, 1197, 1195, 1, 0, 0, 0, 1197, 1198,
		1, 0, 0, 0, 1198, 1200, 1, 0, 0, 0, 1199, 1197, 1, 0, 0, 0, 1200, 1202,
		3, 320, 160, 0, 1201, 1197, 1, 0, 0, 0, 1201, 1202, 1, 0, 0, 0, 1202, 1210,
		1, 0, 0, 0, 1203, 1205, 5, 88, 0, 0, 1204, 1203, 1, 0, 0, 0, 1205, 1208,
		1, 0, 0, 0, 1206, 1204, 1, 0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207, 1209,
		1, 0, 0, 0, 1208, 1206, 1, 0, 0, 0, 1209, 1211, 3, 138, 69, 0, 1210, 1206,
		1, 0, 0, 0, 1210, 1211, 1, 0, 0, 0, 1211, 137, 1, 0, 0, 0, 1212, 1216,
		5, 30, 0, 0, 1213, 1214, 3, 340, 170, 0, 1214, 1215, 5, 88, 0, 0, 1215,
		1217, 1, 0, 0, 0, 1216, 1213, 1, 0, 0, 0, 1216, 1217, 1, 0, 0, 0, 1217,
		1225, 1, 0, 0, 0, 1218, 1220, 5, 88, 0, 0, 1219, 1218, 1, 0, 0, 0, 1220,
		1223, 1, 0, 0, 0, 1221, 1219, 1, 0, 0, 0, 1221, 1222, 1, 0, 0, 0, 1222,
		1224, 1, 0, 0, 0, 1223, 1221, 1, 0, 0, 0, 1224, 1226, 3, 140, 70, 0, 1225,
		1221, 1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226, 1230, 1, 0, 0, 0, 1227,
		1229, 5, 88, 0, 0, 1228, 1227, 1, 0, 0, 0, 1229, 1232, 1, 0, 0, 0, 1230,
		1228, 1, 0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231, 1233, 1, 0, 0, 0, 1232,
		1230, 1, 0, 0, 0, 1233, 1234, 5, 33, 0, 0, 1234, 139, 1, 0, 0, 0, 1235,
		1247, 3, 142, 71, 0, 1236, 1240, 3, 386, 193, 0, 1237, 1239, 5, 88, 0,
		0, 1238, 1237, 1, 0, 0, 0, 1239, 1242, 1, 0, 0, 0, 1240, 1238, 1, 0, 0,
		0, 1240, 1241, 1, 0, 0, 0, 1241, 1243, 1, 0, 0, 0, 1242, 1240, 1, 0, 0,
		0, 1243, 1244, 3, 142, 71, 0, 1244, 1246, 1, 0, 0, 0, 1245, 1236, 1, 0,
		0, 0, 1246, 1249, 1, 0, 0, 0, 1247, 1245, 1, 0, 0, 0, 1247, 1248, 1, 0,
		0, 0, 1248, 1251, 1, 0, 0, 0, 1249, 1247, 1, 0, 0, 0, 1250, 1252, 3, 386,
		193, 0, 1251, 1250, 1, 0, 0, 0, 1251, 1252, 1, 0, 0, 0, 1252, 141, 1, 0,
		0, 0, 1253, 1254, 3, 338, 169, 0, 1254, 1255, 5, 88, 0, 0, 1255, 1257,
		1, 0, 0, 0, 1256, 1253, 1, 0, 0, 0, 1256, 1257, 1, 0, 0, 0, 1257, 1261,
		1, 0, 0, 0, 1258, 1259, 3, 194, 97, 0, 1259, 1260, 5, 88, 0, 0, 1260, 1262,
		1, 0, 0, 0, 1261, 1258, 1, 0, 0, 0, 1261, 1262, 1, 0, 0, 0, 1262, 1268,
		1, 0, 0, 0, 1263, 1269, 3, 132, 66, 0, 1264, 1269, 3, 122, 61, 0, 1265,
		1269, 3, 88, 44, 0, 1266, 1269, 3, 100, 50, 0, 1267, 1269, 3, 144, 72,
		0, 1268, 1263, 1, 0, 0, 0, 1268, 1264, 1, 0, 0, 0, 1268, 1265, 1, 0, 0,
		0, 1268, 1266, 1, 0, 0, 0, 1268, 1267, 1, 0, 0, 0, 1269, 1272, 1, 0, 0,
		0, 1270, 1272, 3, 8, 4, 0, 1271, 1256, 1, 0, 0, 0, 1271, 1270, 1, 0, 0,
		0, 1272, 143, 1, 0, 0, 0, 1273, 1274, 3, 326, 163, 0, 1274, 1282, 3, 298,
		149, 0, 1275, 1277, 5, 88, 0, 0, 1276, 1275, 1, 0, 0, 0, 1277, 1280, 1,
		0, 0, 0, 1278, 1276, 1, 0, 0, 0, 1278, 1279, 1, 0, 0, 0, 1279, 1281, 1,
		0, 0, 0, 1280, 1278, 1, 0, 0, 0, 1281, 1283, 3, 96, 48, 0, 1282, 1278,
		1, 0, 0, 0, 1282, 1283, 1, 0, 0, 0, 1283, 145, 1, 0, 0, 0, 1284, 1285,
		5, 15, 0, 0, 1285, 1287, 3, 148, 74, 0, 1286, 1288, 3, 44, 22, 0, 1287,
		1286, 1, 0, 0, 0, 1287, 1288, 1, 0, 0, 0, 1288, 1289, 1, 0, 0, 0, 1289,
		1290, 3, 150, 75, 0, 1290, 147, 1, 0, 0, 0, 1291, 1292, 3, 304, 152, 0,
		1292, 149, 1, 0, 0, 0, 1293, 1295, 5, 88, 0, 0, 1294, 1293, 1, 0, 0, 0,
		1295, 1298, 1, 0, 0, 0, 1296, 1294, 1, 0, 0, 0, 1296, 1297, 1, 0, 0, 0,
		1297, 1299, 1, 0, 0, 0, 1298, 1296, 1, 0, 0, 0, 1299, 1301, 3, 320, 160,
		0, 1300, 1296, 1, 0, 0, 0, 1300, 1301, 1, 0, 0, 0, 1301, 1305, 1, 0, 0,
		0, 1302, 1304, 5, 88, 0, 0, 1303, 1302, 1, 0, 0, 0, 1304, 1307, 1, 0, 0,
		0, 1305, 1303, 1, 0, 0, 0, 1305, 1306, 1, 0, 0, 0, 1306, 1308, 1, 0, 0,
		0, 1307, 1305, 1, 0, 0, 0, 1308, 1309, 3, 152, 76, 0, 1309, 151, 1, 0,
		0, 0, 1310, 1312, 5, 30, 0, 0, 1311, 1313, 3, 340, 170, 0, 1312, 1311,
		1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1321, 1, 0, 0, 0, 1314, 1316,
		5, 88, 0, 0, 1315, 1314, 1, 0, 0, 0, 1316, 1319, 1, 0, 0, 0, 1317, 1315,
		1, 0, 0, 0, 1317, 1318, 1, 0, 0, 0, 1318, 1320, 1, 0, 0, 0, 1319, 1317,
		1, 0, 0, 0, 1320, 1322, 3, 154, 77, 0, 1321, 1317, 1, 0, 0, 0, 1321, 1322,
		1, 0, 0, 0, 1322, 1326, 1, 0, 0, 0, 1323, 1325, 5, 88, 0, 0, 1324, 1323,
		1, 0, 0, 0, 1325, 1328, 1, 0, 0, 0, 1326, 1324, 1, 0, 0, 0, 1326, 1327,
		1, 0, 0, 0, 1327, 1329, 1, 0, 0, 0, 1328, 1326, 1, 0, 0, 0, 1329, 1330,
		5, 33, 0, 0, 1330, 153, 1, 0, 0, 0, 1331, 1343, 3, 156, 78, 0, 1332, 1336,
		3, 386, 193, 0, 1333, 1335, 5, 88, 0, 0, 1334, 1333, 1, 0, 0, 0, 1335,
		1338, 1, 0, 0, 0, 1336, 1334, 1, 0, 0, 0, 1336, 1337, 1, 0, 0, 0, 1337,
		1339, 1, 0, 0, 0, 1338, 1336, 1, 0, 0, 0, 1339, 1340, 3, 156, 78, 0, 1340,
		1342, 1, 0, 0, 0, 1341, 1332, 1, 0, 0, 0, 1342, 1345, 1, 0, 0, 0, 1343,
		1341, 1, 0, 0, 0, 1343, 1344, 1, 0, 0, 0, 1344, 1347, 1, 0, 0, 0, 1345,
		1343, 1, 0, 0, 0, 1346, 1348, 3, 386, 193, 0, 1347, 1346, 1, 0, 0, 0, 1347,
		1348, 1, 0, 0, 0, 1348, 155, 1, 0, 0, 0, 1349, 1350, 3, 338, 169, 0, 1350,
		1351, 5, 88, 0, 0, 1351, 1353, 1, 0, 0, 0, 1352, 1349, 1, 0, 0, 0, 1352,
		1353, 1, 0, 0, 0, 1353, 1357, 1, 0, 0, 0, 1354, 1355, 3, 194, 97, 0, 1355,
		1356, 5, 88, 0, 0, 1356, 1358, 1, 0, 0, 0, 1357, 1354, 1, 0, 0, 0, 1357,
		1358, 1, 0, 0, 0, 1358, 1361, 1, 0, 0, 0, 1359, 1362, 3, 100, 50, 0, 1360,
		1362, 3, 158, 79, 0, 1361, 1359, 1, 0, 0, 0, 1361, 1360, 1, 0, 0, 0, 1362,
		1365, 1, 0, 0, 0, 1363, 1365, 3, 8, 4, 0, 1364, 1352, 1, 0, 0, 0, 1364,
		1363, 1, 0, 0, 0, 1365, 157, 1, 0, 0, 0, 1366, 1368, 3, 108, 54, 0, 1367,
		1369, 3, 44, 22, 0, 1368, 1367, 1, 0, 0, 0, 1368, 1369, 1, 0, 0, 0, 1369,
		1373, 1, 0, 0, 0, 1370, 1372, 5, 88, 0, 0, 1371, 1370, 1, 0, 0, 0, 1372,
		1375, 1, 0, 0, 0, 1373, 1371, 1, 0, 0, 0, 1373, 1374, 1, 0, 0, 0, 1374,
		1376, 1, 0, 0, 0, 1375, 1373, 1, 0, 0, 0, 1376, 1377, 3, 110, 55, 0, 1377,
		159, 1, 0, 0, 0, 1378, 1379, 5, 3, 0, 0, 1379, 1381, 3, 186, 93, 0, 1380,
		1382, 3, 44, 22, 0, 1381, 1380, 1, 0, 0, 0, 1381, 1382, 1, 0, 0, 0, 1382,
		1397, 1, 0, 0, 0, 1383, 1398, 3, 138, 69, 0, 1384, 1392, 3, 298, 149, 0,
		1385, 1387, 5, 88, 0, 0, 1386, 1385, 1, 0, 0, 0, 1387, 1390, 1, 0, 0, 0,
		1388, 1386, 1, 0, 0, 0, 1388, 1389, 1, 0, 0, 0, 1389, 1391, 1, 0, 0, 0,
		1390, 1388, 1, 0, 0, 0, 1391, 1393, 3, 96, 48, 0, 1392, 1388, 1, 0, 0,
		0, 1392, 1393, 1, 0, 0, 0, 1393, 1395, 1, 0, 0, 0, 1394, 1396, 3, 340,
		170, 0, 1395, 1394, 1, 0, 0, 0, 1395, 1396, 1, 0, 0, 0, 1396, 1398, 1,
		0, 0, 0, 1397, 1383, 1, 0, 0, 0, 1397, 1384, 1, 0, 0, 0, 1398, 161, 1,
		0, 0, 0, 1399, 1400, 5, 3, 0, 0, 1400, 1402, 3, 186, 93, 0, 1401, 1403,
		3, 44, 22, 0, 1402, 1401, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0, 1403, 1407,
		1, 0, 0, 0, 1404, 1406, 5, 88, 0, 0, 1405, 1404, 1, 0, 0, 0, 1406, 1409,
		1, 0, 0, 0, 1407, 1405, 1, 0, 0, 0, 1407, 1408, 1, 0, 0, 0, 1408, 1410,
		1, 0, 0, 0, 1409, 1407, 1, 0, 0, 0, 1410, 1411, 3, 164, 82, 0, 1411, 163,
		1, 0, 0, 0, 1412, 1416, 3, 342, 171, 0, 1413, 1415, 5, 88, 0, 0, 1414,
		1413, 1, 0, 0, 0, 1415, 1418, 1, 0, 0, 0, 1416, 1414, 1, 0, 0, 0, 1416,
		1417, 1, 0, 0, 0, 1417, 1422, 1, 0, 0, 0, 1418, 1416, 1, 0, 0, 0, 1419,
		1420, 3, 62, 31, 0, 1420, 1421, 5, 29, 0, 0, 1421, 1423, 1, 0, 0, 0, 1422,
		1419, 1, 0, 0, 0, 1422, 1423, 1, 0, 0, 0, 1423, 1424, 1, 0, 0, 0, 1424,
		1426, 3, 186, 93, 0, 1425, 1427, 3, 50, 25, 0, 1426, 1425, 1, 0, 0, 0,
		1426, 1427, 1, 0, 0, 0, 1427, 1429, 1, 0, 0, 0, 1428, 1430, 3, 340, 170,
		0, 1429, 1428, 1, 0, 0, 0, 1429, 1430, 1, 0, 0, 0, 1430, 165, 1, 0, 0,
		0, 1431, 1432, 6, 83, -1, 0, 1432, 1434, 3, 168, 84, 0, 1433, 1435, 3,
		298, 149, 0, 1434, 1433, 1, 0, 0, 0, 1434, 1435, 1, 0, 0, 0, 1435, 1449,
		1, 0, 0, 0, 1436, 1438, 3, 170, 85, 0, 1437, 1439, 3, 298, 149, 0, 1438,
		1437, 1, 0, 0, 0, 1438, 1439, 1, 0, 0, 0, 1439, 1449, 1, 0, 0, 0, 1440,
		1442, 3, 172, 86, 0, 1441, 1443, 3, 298, 149, 0, 1442, 1441, 1, 0, 0, 0,
		1442, 1443, 1, 0, 0, 0, 1443, 1449, 1, 0, 0, 0, 1444, 1449, 3, 178, 89,
		0, 1445, 1446, 5, 16, 0, 0, 1446, 1449, 3, 292, 146, 0, 1447, 1449, 3,
		180, 90, 0, 1448, 1431, 1, 0, 0, 0, 1448, 1436, 1, 0, 0, 0, 1448, 1440,
		1, 0, 0, 0, 1448, 1444, 1, 0, 0, 0, 1448, 1445, 1, 0, 0, 0, 1448, 1447,
		1, 0, 0, 0, 1449, 1455, 1, 0, 0, 0, 1450, 1451, 10, 2, 0, 0, 1451, 1452,
		5, 2, 0, 0, 1452, 1454, 3, 292, 146, 0, 1453, 1450, 1, 0, 0, 0, 1454, 1457,
		1, 0, 0, 0, 1455, 1453, 1, 0, 0, 0, 1455, 1456, 1, 0, 0, 0, 1456, 167,
		1, 0, 0, 0, 1457, 1455, 1, 0, 0, 0, 1458, 1459, 5, 56, 0, 0, 1459, 169,
		1, 0, 0, 0, 1460, 1461, 3, 326, 163, 0, 1461, 171, 1, 0, 0, 0, 1462, 1464,
		5, 31, 0, 0, 1463, 1465, 3, 174, 87, 0, 1464, 1463, 1, 0, 0, 0, 1464, 1465,
		1, 0, 0, 0, 1465, 1466, 1, 0, 0, 0, 1466, 1467, 5, 34, 0, 0, 1467, 173,
		1, 0, 0, 0, 1468, 1473, 3, 176, 88, 0, 1469, 1470, 5, 36, 0, 0, 1470, 1472,
		3, 176, 88, 0, 1471, 1469, 1, 0, 0, 0, 1472, 1475, 1, 0, 0, 0, 1473, 1471,
		1, 0, 0, 0, 1473, 1474, 1, 0, 0, 0, 1474, 175, 1, 0, 0, 0, 1475, 1473,
		1, 0, 0, 0, 1476, 1477, 3, 166, 83, 0, 1477, 177, 1, 0, 0, 0, 1478, 1479,
		3, 170, 85, 0, 1479, 1480, 5, 42, 0, 0, 1480, 179, 1, 0, 0, 0, 1481, 1482,
		3, 196, 98, 0, 1482, 181, 1, 0, 0, 0, 1483, 1484, 5, 43, 0, 0, 1484, 1494,
		5, 78, 0, 0, 1485, 1486, 5, 43, 0, 0, 1486, 1488, 3, 184, 92, 0, 1487,
		1489, 3, 50, 25, 0, 1488, 1487, 1, 0, 0, 0, 1488, 1489, 1, 0, 0, 0, 1489,
		1491, 1, 0, 0, 0, 1490, 1492, 3, 188, 94, 0, 1491, 1490, 1, 0, 0, 0, 1491,
		1492, 1, 0, 0, 0, 1492, 1494, 1, 0, 0, 0, 1493, 1483, 1, 0, 0, 0, 1493,
		1485, 1, 0, 0, 0, 1494, 183, 1, 0, 0, 0, 1495, 1496, 3, 62, 31, 0, 1496,
		1497, 5, 29, 0, 0, 1497, 1499, 1, 0, 0, 0, 1498, 1495, 1, 0, 0, 0, 1498,
		1499, 1, 0, 0, 0, 1499, 1500, 1, 0, 0, 0, 1500, 1501, 3, 186, 93, 0, 1501,
		185, 1, 0, 0, 0, 1502, 1503, 3, 328, 164, 0, 1503, 187, 1, 0, 0, 0, 1504,
		1512, 5, 31, 0, 0, 1505, 1507, 5, 88, 0, 0, 1506, 1505, 1, 0, 0, 0, 1507,
		1510, 1, 0, 0, 0, 1508, 1506, 1, 0, 0, 0, 1508, 1509, 1, 0, 0, 0, 1509,
		1511, 1, 0, 0, 0, 1510, 1508, 1, 0, 0, 0, 1511, 1513, 3, 192, 96, 0, 1512,
		1508, 1, 0, 0, 0, 1512, 1513, 1, 0, 0, 0, 1513, 1517, 1, 0, 0, 0, 1514,
		1516, 5, 88, 0, 0, 1515, 1514, 1, 0, 0, 0, 1516, 1519, 1, 0, 0, 0, 1517,
		1515, 1, 0, 0, 0, 1517, 1518, 1, 0, 0, 0, 1518, 1520, 1, 0, 0, 0, 1519,
		1517, 1, 0, 0, 0, 1520, 1521, 5, 34, 0, 0, 1521, 189, 1, 0, 0, 0, 1522,
		1523, 3, 328, 164, 0, 1523, 1524, 5, 37, 0, 0, 1524, 1526, 1, 0, 0, 0,
		1525, 1522, 1, 0, 0, 0, 1525, 1526, 1, 0, 0, 0, 1526, 1527, 1, 0, 0, 0,
		1527, 1528, 3, 196, 98, 0, 1528, 191, 1, 0, 0, 0, 1529, 1541, 3, 190, 95,
		0, 1530, 1534, 3, 384, 192, 0, 1531, 1533, 5, 88, 0, 0, 1532, 1531, 1,
		0, 0, 0, 1533, 1536, 1, 0, 0, 0, 1534, 1532, 1, 0, 0, 0, 1534, 1535, 1,
		0, 0, 0, 1535, 1537, 1, 0, 0, 0, 1536, 1534, 1, 0, 0, 0, 1537, 1538, 3,
		190, 95, 0, 1538, 1540, 1, 0, 0, 0, 1539, 1530, 1, 0, 0, 0, 1540, 1543,
		1, 0, 0, 0, 1541, 1539, 1, 0, 0, 0, 1541, 1542, 1, 0, 0, 0, 1542, 1545,
		1, 0, 0, 0, 1543, 1541, 1, 0, 0, 0, 1544, 1546, 3, 384, 192, 0, 1545, 1544,
		1, 0, 0, 0, 1545, 1546, 1, 0, 0, 0, 1546, 193, 1, 0, 0, 0, 1547, 1554,
		3, 182, 91, 0, 1548, 1550, 5, 88, 0, 0, 1549, 1548, 1, 0, 0, 0, 1549, 1550,
		1, 0, 0, 0, 1550, 1551, 1, 0, 0, 0, 1551, 1553, 3, 182, 91, 0, 1552, 1549,
		1, 0, 0, 0, 1553, 1556, 1, 0, 0, 0, 1554, 1552, 1, 0, 0, 0, 1554, 1555,
		1, 0, 0, 0, 1555, 195, 1, 0, 0, 0, 1556, 1554, 1, 0, 0, 0, 1557, 1559,
		3, 200, 100, 0, 1558, 1560, 3, 204, 102, 0, 1559, 1558, 1, 0, 0, 0, 1559,
		1560, 1, 0, 0, 0, 1560, 197, 1, 0, 0, 0, 1561, 1573, 3, 196, 98, 0, 1562,
		1566, 3, 384, 192, 0, 1563, 1565, 5, 88, 0, 0, 1564, 1563, 1, 0, 0, 0,
		1565, 1568, 1, 0, 0, 0, 1566, 1564, 1, 0, 0, 0, 1566, 1567, 1, 0, 0, 0,
		1567, 1569, 1, 0, 0, 0, 1568, 1566, 1, 0, 0, 0, 1569, 1570, 3, 196, 98,
		0, 1570, 1572, 1, 0, 0, 0, 1571, 1562, 1, 0, 0, 0, 1572, 1575, 1, 0, 0,
		0, 1573, 1571, 1, 0, 0, 0, 1573, 1574, 1, 0, 0, 0, 1574, 1577, 1, 0, 0,
		0, 1575, 1573, 1, 0, 0, 0, 1576, 1578, 3, 384, 192, 0, 1577, 1576, 1, 0,
		0, 0, 1577, 1578, 1, 0, 0, 0, 1578, 199, 1, 0, 0, 0, 1579, 1580, 3, 354,
		177, 0, 1580, 1581, 3, 266, 133, 0, 1581, 1584, 1, 0, 0, 0, 1582, 1584,
		3, 266, 133, 0, 1583, 1579, 1, 0, 0, 0, 1583, 1582, 1, 0, 0, 0, 1584, 201,
		1, 0, 0, 0, 1585, 1586, 3, 352, 176, 0, 1586, 1587, 3, 200, 100, 0, 1587,
		1596, 1, 0, 0, 0, 1588, 1589, 3, 342, 171, 0, 1589, 1590, 3, 200, 100,
		0, 1590, 1596, 1, 0, 0, 0, 1591, 1592, 3, 206, 103, 0, 1592, 1593, 3, 200,
		100, 0, 1593, 1596, 1, 0, 0, 0, 1594, 1596, 3, 208, 104, 0, 1595, 1585,
		1, 0, 0, 0, 1595, 1588, 1, 0, 0, 0, 1595, 1591, 1, 0, 0, 0, 1595, 1594,
		1, 0, 0, 0, 1596, 203, 1, 0, 0, 0, 1597, 1599, 3, 202, 101, 0, 1598, 1597,
		1, 0, 0, 0, 1599, 1600, 1, 0, 0, 0, 1600, 1598, 1, 0, 0, 0, 1600, 1601,
		1, 0, 0, 0, 1601, 205, 1, 0, 0, 0, 1602, 1603, 5, 42, 0, 0, 1603, 1604,
		3, 196, 98, 0, 1604, 1605, 5, 37, 0, 0, 1605, 207, 1, 0, 0, 0, 1606, 1607,
		5, 16, 0, 0, 1607, 1611, 3, 292, 146, 0, 1608, 1609, 5, 2, 0, 0, 1609,
		1611, 3, 292, 146, 0, 1610, 1606, 1, 0, 0, 0, 1610, 1608, 1, 0, 0, 0, 1611,
		209, 1, 0, 0, 0, 1612, 1630, 3, 212, 106, 0, 1613, 1615, 3, 326, 163, 0,
		1614, 1616, 3, 50, 25, 0, 1615, 1614, 1, 0, 0, 0, 1615, 1616, 1, 0, 0,
		0, 1616, 1630, 1, 0, 0, 0, 1617, 1618, 3, 300, 150, 0, 1618, 1619, 5, 29,
		0, 0, 1619, 1621, 3, 326, 163, 0, 1620, 1622, 3, 50, 25, 0, 1621, 1620,
		1, 0, 0, 0, 1621, 1622, 1, 0, 0, 0, 1622, 1630, 1, 0, 0, 0, 1623, 1630,
		3, 250, 125, 0, 1624, 1630, 3, 260, 130, 0, 1625, 1630, 3, 258, 129, 0,
		1626, 1630, 3, 256, 128, 0, 1627, 1630, 3, 264, 132, 0, 1628, 1630, 3,
		242, 121, 0, 1629, 1612, 1, 0, 0, 0, 1629, 1613, 1, 0, 0, 0, 1629, 1617,
		1, 0, 0, 0, 1629, 1623, 1, 0, 0, 0, 1629, 1624, 1, 0, 0, 0, 1629, 1625,
		1, 0, 0, 0, 1629, 1626, 1, 0, 0, 0, 1629, 1627, 1, 0, 0, 0, 1629, 1628,
		1, 0, 0, 0, 1630, 211, 1, 0, 0, 0, 1631, 1639, 3, 214, 107, 0, 1632, 1639,
		3, 216, 108, 0, 1633, 1639, 3, 240, 120, 0, 1634, 1639, 3, 370, 185, 0,
		1635, 1639, 3, 222, 111, 0, 1636, 1639, 3, 228, 114, 0, 1637, 1639, 3,
		234, 117, 0, 1638, 1631, 1, 0, 0, 0, 1638, 1632, 1, 0, 0, 0, 1638, 1633,
		1, 0, 0, 0, 1638, 1634, 1, 0, 0, 0, 1638, 1635, 1, 0, 0, 0, 1638, 1636,
		1, 0, 0, 0, 1638, 1637, 1, 0, 0, 0, 1639, 213, 1, 0, 0, 0, 1640, 1641,
		3, 376, 188, 0, 1641, 1642, 3, 218, 109, 0, 1642, 215, 1, 0, 0, 0, 1643,
		1644, 3, 220, 110, 0, 1644, 1645, 4, 108, 1, 0, 1645, 1647, 3, 380, 190,
		0, 1646, 1648, 3, 218, 109, 0, 1647, 1646, 1, 0, 0, 0, 1647, 1648, 1, 0,
		0, 0, 1648, 1653, 1, 0, 0, 0, 1649, 1650, 3, 380, 190, 0, 1650, 1651, 3,
		218, 109, 0, 1651, 1653, 1, 0, 0, 0, 1652, 1643, 1, 0, 0, 0, 1652, 1649,
		1, 0, 0, 0, 1653, 217, 1, 0, 0, 0, 1654, 1655, 4, 109, 2, 0, 1655, 1656,
		7, 0, 0, 0, 1656, 219, 1, 0, 0, 0, 1657, 1658, 5, 73, 0, 0, 1658, 221,
		1, 0, 0, 0, 1659, 1667, 5, 32, 0, 0, 1660, 1662, 5, 88, 0, 0, 1661, 1660,
		1, 0, 0, 0, 1662, 1665, 1, 0, 0, 0, 1663, 1661, 1, 0, 0, 0, 1663, 1664,
		1, 0, 0, 0, 1664, 1666, 1, 0, 0, 0, 1665, 1663, 1, 0, 0, 0, 1666, 1668,
		3, 224, 112, 0, 1667, 1663, 1, 0, 0, 0, 1667, 1668, 1, 0, 0, 0, 1668, 1672,
		1, 0, 0, 0, 1669, 1671, 5, 88, 0, 0, 1670, 1669, 1, 0, 0, 0, 1671, 1674,
		1, 0, 0, 0, 1672, 1670, 1, 0, 0, 0, 1672, 1673, 1, 0, 0, 0, 1673, 1675,
		1, 0, 0, 0, 1674, 1672, 1, 0, 0, 0, 1675, 1676, 5, 35, 0, 0, 1676, 223,
		1, 0, 0, 0, 1677, 1689, 3, 226, 113, 0, 1678, 1682, 3, 384, 192, 0, 1679,
		1681, 5, 88, 0, 0, 1680, 1679, 1, 0, 0, 0, 1681, 1684, 1, 0, 0, 0, 1682,
		1680, 1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683, 1685, 1, 0, 0, 0, 1684,
		1682, 1, 0, 0, 0, 1685, 1686, 3, 226, 113, 0, 1686, 1688, 1, 0, 0, 0, 1687,
		1678, 1, 0, 0, 0, 1688, 1691, 1, 0, 0, 0, 1689, 1687, 1, 0, 0, 0, 1689,
		1690, 1, 0, 0, 0, 1690, 1693, 1, 0, 0, 0, 1691, 1689, 1, 0, 0, 0, 1692,
		1694, 3, 384, 192, 0, 1693, 1692, 1, 0, 0, 0, 1693, 1694, 1, 0, 0, 0, 1694,
		225, 1, 0, 0, 0, 1695, 1698, 3, 196, 98, 0, 1696, 1698, 5, 64, 0, 0, 1697,
		1695, 1, 0, 0, 0, 1697, 1696, 1, 0, 0, 0, 1698, 227, 1, 0, 0, 0, 1699,
		1707, 5, 30, 0, 0, 1700, 1702, 5, 88, 0, 0, 1701, 1700, 1, 0, 0, 0, 1702,
		1705, 1, 0, 0, 0, 1703, 1701, 1, 0, 0, 0, 1703, 1704, 1, 0, 0, 0, 1704,
		1706, 1, 0, 0, 0, 1705, 1703, 1, 0, 0, 0, 1706, 1708, 3, 230, 115, 0, 1707,
		1703, 1, 0, 0, 0, 1707, 1708, 1, 0, 0, 0, 1708, 1712, 1, 0, 0, 0, 1709,
		1711, 5, 88, 0, 0, 1710, 1709, 1, 0, 0, 0, 1711, 1714, 1, 0, 0, 0, 1712,
		1710, 1, 0, 0, 0, 1712, 1713, 1, 0, 0, 0, 1713, 1715, 1, 0, 0, 0, 1714,
		1712, 1, 0, 0, 0, 1715, 1716, 5, 33, 0, 0, 1716, 229, 1, 0, 0, 0, 1717,
		1729, 3, 232, 116, 0, 1718, 1722, 3, 384, 192, 0, 1719, 1721, 5, 88, 0,
		0, 1720, 1719, 1, 0, 0, 0, 1721, 1724, 1, 0, 0, 0, 1722, 1720, 1, 0, 0,
		0, 1722, 1723, 1, 0, 0, 0, 1723, 1725, 1, 0, 0, 0, 1724, 1722, 1, 0, 0,
		0, 1725, 1726, 3, 232, 116, 0, 1726, 1728, 1, 0, 0, 0, 1727, 1718, 1, 0,
		0, 0, 1728, 1731, 1, 0, 0, 0, 1729, 1727, 1, 0, 0, 0, 1729, 1730, 1, 0,
		0, 0, 1730, 1733, 1, 0, 0, 0, 1731, 1729, 1, 0, 0, 0, 1732, 1734, 3, 384,
		192, 0, 1733, 1732, 1, 0, 0, 0, 1733, 1734, 1, 0, 0, 0, 1734, 231, 1, 0,
		0, 0, 1735, 1738, 3, 380, 190, 0, 1736, 1738, 3, 378, 189, 0, 1737, 1735,
		1, 0, 0, 0, 1737, 1736, 1, 0, 0, 0, 1738, 1739, 1, 0, 0, 0, 1739, 1740,
		5, 37, 0, 0, 1740, 1741, 3, 196, 98, 0, 1741, 233, 1, 0, 0, 0, 1742, 1750,
		5, 30, 0, 0, 1743, 1745, 5, 88, 0, 0, 1744, 1743, 1, 0, 0, 0, 1745, 1748,
		1, 0, 0, 0, 1746, 1744, 1, 0, 0, 0, 1746, 1747, 1, 0, 0, 0, 1747, 1749,
		1, 0, 0, 0, 1748, 1746, 1, 0, 0, 0, 1749, 1751, 3, 236, 118, 0, 1750, 1746,
		1, 0, 0, 0, 1750, 1751, 1, 0, 0, 0, 1751, 1755, 1, 0, 0, 0, 1752, 1754,
		5, 88, 0, 0, 1753, 1752, 1, 0, 0, 0, 1754, 1757, 1, 0, 0, 0, 1755, 1753,
		1, 0, 0, 0, 1755, 1756, 1, 0, 0, 0, 1756, 1758, 1, 0, 0, 0, 1757, 1755,
		1, 0, 0, 0, 1758, 1759, 5, 33, 0, 0, 1759, 235, 1, 0, 0, 0, 1760, 1772,
		3, 238, 119, 0, 1761, 1765, 3, 384, 192, 0, 1762, 1764, 5, 88, 0, 0, 1763,
		1762, 1, 0, 0, 0, 1764, 1767, 1, 0, 0, 0, 1765, 1763, 1, 0, 0, 0, 1765,
		1766, 1, 0, 0, 0, 1766, 1768, 1, 0, 0, 0, 1767, 1765, 1, 0, 0, 0, 1768,
		1769, 3, 238, 119, 0, 1769, 1771, 1, 0, 0, 0, 1770, 1761, 1, 0, 0, 0, 1771,
		1774, 1, 0, 0, 0, 1772, 1770, 1, 0, 0, 0, 1772, 1773, 1, 0, 0, 0, 1773,
		1776, 1, 0, 0, 0, 1774, 1772, 1, 0, 0, 0, 1775, 1777, 3, 384, 192, 0, 1776,
		1775, 1, 0, 0, 0, 1776, 1777, 1, 0, 0, 0, 1777, 237, 1, 0, 0, 0, 1778,
		1781, 3, 330, 165, 0, 1779, 1780, 5, 37, 0, 0, 1780, 1782, 3, 196, 98,
		0, 1781, 1779, 1, 0, 0, 0, 1781, 1782, 1, 0, 0, 0, 1782, 239, 1, 0, 0,
		0, 1783, 1784, 3, 300, 150, 0, 1784, 1785, 3, 234, 117, 0, 1785, 241, 1,
		0, 0, 0, 1786, 1787, 3, 300, 150, 0, 1787, 1788, 3, 274, 137, 0, 1788,
		243, 1, 0, 0, 0, 1789, 1793, 5, 17, 0, 0, 1790, 1792, 5, 88, 0, 0, 1791,
		1790, 1, 0, 0, 0, 1792, 1795, 1, 0, 0, 0, 1793, 1791, 1, 0, 0, 0, 1793,
		1794, 1, 0, 0, 0, 1794, 1796, 1, 0, 0, 0, 1795, 1793, 1, 0, 0, 0, 1796,
		1804, 5, 30, 0, 0, 1797, 1799, 5, 88, 0, 0, 1798, 1797, 1, 0, 0, 0, 1799,
		1802, 1, 0, 0, 0, 1800, 1798, 1, 0, 0, 0, 1800, 1801, 1, 0, 0, 0, 1801,
		1803, 1, 0, 0, 0, 1802, 1800, 1, 0, 0, 0, 1803, 1805, 3, 246, 123, 0, 1804,
		1800, 1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805, 1809, 1, 0, 0, 0, 1806,
		1808, 5, 88, 0, 0, 1807, 1806, 1, 0, 0, 0, 1808, 1811, 1, 0, 0, 0, 1809,
		1807, 1, 0, 0, 0, 1809, 1810, 1, 0, 0, 0, 1810, 1812, 1, 0, 0, 0, 1811,
		1809, 1, 0, 0, 0, 1812, 1813, 5, 33, 0, 0, 1813, 245, 1, 0, 0, 0, 1814,
		1826, 3, 248, 124, 0, 1815, 1819, 3, 382, 191, 0, 1816, 1818, 5, 88, 0,
		0, 1817, 1816, 1, 0, 0, 0, 1818, 1821, 1, 0, 0, 0, 1819, 1817, 1, 0, 0,
		0, 1819, 1820, 1, 0, 0, 0, 1820, 1822, 1, 0, 0, 0, 1821, 1819, 1, 0, 0,
		0, 1822, 1823, 3, 248, 124, 0, 1823, 1825, 1, 0, 0, 0, 1824, 1815, 1, 0,
		0, 0, 1825, 1828, 1, 0, 0, 0, 1826, 1824, 1, 0, 0, 0, 1826, 1827, 1, 0,
		0, 0, 1827, 1830, 1, 0, 0, 0, 1828, 1826, 1, 0, 0, 0, 1829, 1831, 3, 382,
		191, 0, 1830, 1829, 1, 0, 0, 0, 1830, 1831, 1, 0, 0, 0, 1831, 247, 1, 0,
		0, 0, 1832, 1836, 3, 166, 83, 0, 1833, 1835, 5, 88, 0, 0, 1834, 1833, 1,
		0, 0, 0, 1835, 1838, 1, 0, 0, 0, 1836, 1834, 1, 0, 0, 0, 1836, 1837, 1,
		0, 0, 0, 1837, 1839, 1, 0, 0, 0, 1838, 1836, 1, 0, 0, 0, 1839, 1843, 5,
		60, 0, 0, 1840, 1842, 5, 88, 0, 0, 1841, 1840, 1, 0, 0, 0, 1842, 1845,
		1, 0, 0, 0, 1843, 1841, 1, 0, 0, 0, 1843, 1844, 1, 0, 0, 0, 1844, 1846,
		1, 0, 0, 0, 1845, 1843, 1, 0, 0, 0, 1846, 1847, 3, 196, 98, 0, 1847, 249,
		1, 0, 0, 0, 1848, 1852, 5, 30, 0, 0, 1849, 1851, 5, 88, 0, 0, 1850, 1849,
		1, 0, 0, 0, 1851, 1854, 1, 0, 0, 0, 1852, 1850, 1, 0, 0, 0, 1852, 1853,
		1, 0, 0, 0, 1853, 1855, 1, 0, 0, 0, 1854, 1852, 1, 0, 0, 0, 1855, 1859,
		3, 10, 5, 0, 1856, 1858, 5, 88, 0, 0, 1857, 1856, 1, 0, 0, 0, 1858, 1861,
		1, 0, 0, 0, 1859, 1857, 1, 0, 0, 0, 1859, 1860, 1, 0, 0, 0, 1860, 1862,
		1, 0, 0, 0, 1861, 1859, 1, 0, 0, 0, 1862, 1863, 5, 33, 0, 0, 1863, 1892,
		1, 0, 0, 0, 1864, 1865, 5, 30, 0, 0, 1865, 1869, 3, 252, 126, 0, 1866,
		1868, 5, 88, 0, 0, 1867, 1866, 1, 0, 0, 0, 1868, 1871, 1, 0, 0, 0, 1869,
		1867, 1, 0, 0, 0, 1869, 1870, 1, 0, 0, 0, 1870, 1872, 1, 0, 0, 0, 1871,
		1869, 1, 0, 0, 0, 1872, 1880, 5, 61, 0, 0, 1873, 1875, 5, 88, 0, 0, 1874,
		1873, 1, 0, 0, 0, 1875, 1878, 1, 0, 0, 0, 1876, 1874, 1, 0, 0, 0, 1876,
		1877, 1, 0, 0, 0, 1877, 1879, 1, 0, 0, 0, 1878, 1876, 1, 0, 0, 0, 1879,
		1881, 3, 292, 146, 0, 1880, 1876, 1, 0, 0, 0, 1880, 1881, 1, 0, 0, 0, 1881,
		1885, 1, 0, 0, 0, 1882, 1884, 5, 88, 0, 0, 1883, 1882, 1, 0, 0, 0, 1884,
		1887, 1, 0, 0, 0, 1885, 1883, 1, 0, 0, 0, 1885, 1886, 1, 0, 0, 0, 1886,
		1888, 1, 0, 0, 0, 1887, 1885, 1, 0, 0, 0, 1888, 1889, 3, 10, 5, 0, 1889,
		1890, 5, 33, 0, 0, 1890, 1892, 1, 0, 0, 0, 1891, 1848, 1, 0, 0, 0, 1891,
		1864, 1, 0, 0, 0, 1892, 251, 1, 0, 0, 0, 1893, 1905, 3, 254, 127, 0, 1894,
		1898, 3, 384, 192, 0, 1895, 1897, 5, 88, 0, 0, 1896, 1895, 1, 0, 0, 0,
		1897, 1900, 1, 0, 0, 0, 1898, 1896, 1, 0, 0, 0, 1898, 1899, 1, 0, 0, 0,
		1899, 1901, 1, 0, 0, 0, 1900, 1898, 1, 0, 0, 0, 1901, 1902, 3, 254, 127,
		0, 1902, 1904, 1, 0, 0, 0, 1903, 1894, 1, 0, 0, 0, 1904, 1907, 1, 0, 0,
		0, 1905, 1903, 1, 0, 0, 0, 1905, 1906, 1, 0, 0, 0, 1906, 1909, 1, 0, 0,
		0, 1907, 1905, 1, 0, 0, 0, 1908, 1910, 3, 384, 192, 0, 1909, 1908, 1, 0,
		0, 0, 1909, 1910, 1, 0, 0, 0, 1910, 253, 1, 0, 0, 0, 1911, 1914, 3, 120,
		60, 0, 1912, 1914, 3, 328, 164, 0, 1913, 1911, 1, 0, 0, 0, 1913, 1912,
		1, 0, 0, 0, 1914, 255, 1, 0, 0, 0, 1915, 1916, 5, 29, 0, 0, 1916, 1917,
		3, 328, 164, 0, 1917, 257, 1, 0, 0, 0, 1918, 1922, 5, 31, 0, 0, 1919, 1921,
		5, 88, 0, 0, 1920, 1919, 1, 0, 0, 0, 1921, 1924, 1, 0, 0, 0, 1922, 1920,
		1, 0, 0, 0, 1922, 1923, 1, 0, 0, 0, 1923, 1925, 1, 0, 0, 0, 1924, 1922,
		1, 0, 0, 0, 1925, 1929, 3, 196, 98, 0, 1926, 1928, 5, 88, 0, 0, 1927, 1926,
		1, 0, 0, 0, 1928, 1931, 1, 0, 0, 0, 1929, 1927, 1, 0, 0, 0, 1929, 1930,
		1, 0, 0, 0, 1930, 1932, 1, 0, 0, 0, 1931, 1929, 1, 0, 0, 0, 1932, 1933,
		5, 34, 0, 0, 1933, 259, 1, 0, 0, 0, 1934, 1935, 5, 31, 0, 0, 1935, 1947,
		5, 34, 0, 0, 1936, 1937, 5, 31, 0, 0, 1937, 1940, 3, 262, 131, 0, 1938,
		1939, 5, 36, 0, 0, 1939, 1941, 3, 262, 131, 0, 1940, 1938, 1, 0, 0, 0,
		1941, 1942, 1, 0, 0, 0, 1942, 1940, 1, 0, 0, 0, 1942, 1943, 1, 0, 0, 0,
		1943, 1944, 1, 0, 0, 0, 1944, 1945, 5, 34, 0, 0, 1945, 1947, 1, 0, 0, 0,
		1946, 1934, 1, 0, 0, 0, 1946, 1936, 1, 0, 0, 0, 1947, 261, 1, 0, 0, 0,
		1948, 1955, 3, 196, 98, 0, 1949, 1950, 3, 328, 164, 0, 1950, 1951, 5, 37,
		0, 0, 1951, 1952, 3, 196, 98, 0, 1952, 1955, 1, 0, 0, 0, 1953, 1955, 5,
		64, 0, 0, 1954, 1948, 1, 0, 0, 0, 1954, 1949, 1, 0, 0, 0, 1954, 1953, 1,
		0, 0, 0, 1955, 263, 1, 0, 0, 0, 1956, 1957, 5, 56, 0, 0, 1957, 265, 1,
		0, 0, 0, 1958, 1962, 3, 210, 105, 0, 1959, 1961, 3, 268, 134, 0, 1960,
		1959, 1, 0, 0, 0, 1961, 1964, 1, 0, 0, 0, 1962, 1960, 1, 0, 0, 0, 1962,
		1963, 1, 0, 0, 0, 1963, 1966, 1, 0, 0, 0, 1964, 1962, 1, 0, 0, 0, 1965,
		1967, 3, 356, 178, 0, 1966, 1965, 1, 0, 0, 0, 1966, 1967, 1, 0, 0, 0, 1967,
		267, 1, 0, 0, 0, 1968, 1974, 3, 274, 137, 0, 1969, 1974, 3, 270, 135, 0,
		1970, 1974, 3, 272, 136, 0, 1971, 1974, 3, 244, 122, 0, 1972, 1974, 3,
		208, 104, 0, 1973, 1968, 1, 0, 0, 0, 1973, 1969, 1, 0, 0, 0, 1973, 1970,
		1, 0, 0, 0, 1973, 1971, 1, 0, 0, 0, 1973, 1972, 1, 0, 0, 0, 1974, 269,
		1, 0, 0, 0, 1975, 1985, 5, 29, 0, 0, 1976, 1986, 5, 79, 0, 0, 1977, 1983,
		3, 332, 166, 0, 1978, 1984, 3, 50, 25, 0, 1979, 1980, 5, 31, 0, 0, 1980,
		1981, 3, 288, 144, 0, 1981, 1982, 5, 34, 0, 0, 1982, 1984, 1, 0, 0, 0,
		1983, 1978, 1, 0, 0, 0, 1983, 1979, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0,
		1984, 1986, 1, 0, 0, 0, 1985, 1976, 1, 0, 0, 0, 1985, 1977, 1, 0, 0, 0,
		1986, 271, 1, 0, 0, 0, 1987, 1988, 5, 32, 0, 0, 1988, 1989, 3, 278, 139,
		0, 1989, 1990, 5, 35, 0, 0, 1990, 273, 1, 0, 0, 0, 1991, 1993, 3, 276,
		138, 0, 1992, 1991, 1, 0, 0, 0, 1992, 1993, 1, 0, 0, 0, 1993, 1994, 1,
		0, 0, 0, 1994, 1997, 3, 282, 141, 0, 1995, 1997, 3, 276, 138, 0, 1996,
		1992, 1, 0, 0, 0, 1996, 1995, 1, 0, 0, 0, 1997, 275, 1, 0, 0, 0, 1998,
		2002, 5, 31, 0, 0, 1999, 2001, 5, 88, 0, 0, 2000, 1999, 1, 0, 0, 0, 2001,
		2004, 1, 0, 0, 0, 2002, 2000, 1, 0, 0, 0, 2002, 2003, 1, 0, 0, 0, 2003,
		2005, 1, 0, 0, 0, 2004, 2002, 1, 0, 0, 0, 2005, 2023, 5, 34, 0, 0, 2006,
		2010, 5, 31, 0, 0, 2007, 2009, 5, 88, 0, 0, 2008, 2007, 1, 0, 0, 0, 2009,
		2012, 1, 0, 0, 0, 2010, 2008, 1, 0, 0, 0, 2010, 2011, 1, 0, 0, 0, 2011,
		2013, 1, 0, 0, 0, 2012, 2010, 1, 0, 0, 0, 2013, 2017, 3, 278, 139, 0, 2014,
		2016, 5, 88, 0, 0, 2015, 2014, 1, 0, 0, 0, 2016, 2019, 1, 0, 0, 0, 2017,
		2015, 1, 0, 0, 0, 2017, 2018, 1, 0, 0, 0, 2018, 2020, 1, 0, 0, 0, 2019,
		2017, 1, 0, 0, 0, 2020, 2021, 5, 34, 0, 0, 2021, 2023, 1, 0, 0, 0, 2022,
		1998, 1, 0, 0, 0, 2022, 2006, 1, 0, 0, 0, 2023, 277, 1, 0, 0, 0, 2024,
		2029, 3, 280, 140, 0, 2025, 2026, 5, 36, 0, 0, 2026, 2028, 3, 280, 140,
		0, 2027, 2025, 1, 0, 0, 0, 2028, 2031, 1, 0, 0, 0, 2029, 2027, 1, 0, 0,
		0, 2029, 2030, 1, 0, 0, 0, 2030, 279, 1, 0, 0, 0, 2031, 2029, 1, 0, 0,
		0, 2032, 2038, 3, 196, 98, 0, 2033, 2034, 3, 328, 164, 0, 2034, 2035, 5,
		37, 0, 0, 2035, 2036, 3, 196, 98, 0, 2036, 2038, 1, 0, 0, 0, 2037, 2032,
		1, 0, 0, 0, 2037, 2033, 1, 0, 0, 0, 2038, 281, 1, 0, 0, 0, 2039, 2041,
		3, 250, 125, 0, 2040, 2042, 3, 284, 142, 0, 2041, 2040, 1, 0, 0, 0, 2041,
		2042, 1, 0, 0, 0, 2042, 283, 1, 0, 0, 0, 2043, 2045, 3, 286, 143, 0, 2044,
		2043, 1, 0, 0, 0, 2045, 2046, 1, 0, 0, 0, 2046, 2044, 1, 0, 0, 0, 2046,
		2047, 1, 0, 0, 0, 2047, 285, 1, 0, 0, 0, 2048, 2049, 3, 332, 166, 0, 2049,
		2050, 5, 37, 0, 0, 2050, 2051, 3, 250, 125, 0, 2051, 287, 1, 0, 0, 0, 2052,
		2056, 3, 290, 145, 0, 2053, 2055, 3, 290, 145, 0, 2054, 2053, 1, 0, 0,
		0, 2055, 2058, 1, 0, 0, 0, 2056, 2054, 1, 0, 0, 0, 2056, 2057, 1, 0, 0,
		0, 2057, 289, 1, 0, 0, 0, 2058, 2056, 1, 0, 0, 0, 2059, 2060, 3, 328, 164,
		0, 2060, 2061, 5, 37, 0, 0, 2061, 291, 1, 0, 0, 0, 2062, 2063, 6, 146,
		-1, 0, 2063, 2066, 3, 294, 147, 0, 2064, 2066, 3, 312, 156, 0, 2065, 2062,
		1, 0, 0, 0, 2065, 2064, 1, 0, 0, 0, 2066, 2081, 1, 0, 0, 0, 2067, 2068,
		10, 6, 0, 0, 2068, 2080, 5, 41, 0, 0, 2069, 2070, 10, 5, 0, 0, 2070, 2080,
		5, 42, 0, 0, 2071, 2072, 10, 4, 0, 0, 2072, 2080, 5, 50, 0, 0, 2073, 2074,
		10, 3, 0, 0, 2074, 2080, 5, 49, 0, 0, 2075, 2076, 10, 2, 0, 0, 2076, 2080,
		5, 45, 0, 0, 2077, 2078, 10, 1, 0, 0, 2078, 2080, 5, 64, 0, 0, 2079, 2067,
		1, 0, 0, 0, 2079, 2069, 1, 0, 0, 0, 2079, 2071, 1, 0, 0, 0, 2079, 2073,
		1, 0, 0, 0, 2079, 2075, 1, 0, 0, 0, 2079, 2077, 1, 0, 0, 0, 2080, 2083,
		1, 0, 0, 0, 2081, 2079, 1, 0, 0, 0, 2081, 2082, 1, 0, 0, 0, 2082, 293,
		1, 0, 0, 0, 2083, 2081, 1, 0, 0, 0, 2084, 2085, 6, 147, -1, 0, 2085, 2086,
		3, 296, 148, 0, 2086, 2151, 1, 0, 0, 0, 2087, 2089, 10, 3, 0, 0, 2088,
		2090, 3, 194, 97, 0, 2089, 2088, 1, 0, 0, 0, 2089, 2090, 1, 0, 0, 0, 2090,
		2094, 1, 0, 0, 0, 2091, 2092, 3, 340, 170, 0, 2092, 2093, 5, 88, 0, 0,
		2093, 2095, 1, 0, 0, 0, 2094, 2091, 1, 0, 0, 0, 2094, 2095, 1, 0, 0, 0,
		2095, 2099, 1, 0, 0, 0, 2096, 2098, 5, 88, 0, 0, 2097, 2096, 1, 0, 0, 0,
		2098, 2101, 1, 0, 0, 0, 2099, 2097, 1, 0, 0, 0, 2099, 2100, 1, 0, 0, 0,
		2100, 2102, 1, 0, 0, 0, 2101, 2099, 1, 0, 0, 0, 2102, 2106, 5, 47, 0, 0,
		2103, 2105, 5, 88, 0, 0, 2104, 2103, 1, 0, 0, 0, 2105, 2108, 1, 0, 0, 0,
		2106, 2104, 1, 0, 0, 0, 2106, 2107, 1, 0, 0, 0, 2107, 2109, 1, 0, 0, 0,
		2108, 2106, 1, 0, 0, 0, 2109, 2111, 3, 294, 147, 0, 2110, 2112, 3, 194,
		97, 0, 2111, 2110, 1, 0, 0, 0, 2111, 2112, 1, 0, 0, 0, 2112, 2116, 1, 0,
		0, 0, 2113, 2114, 3, 340, 170, 0, 2114, 2115, 5, 88, 0, 0, 2115, 2117,
		1, 0, 0, 0, 2116, 2113, 1, 0, 0, 0, 2116, 2117, 1, 0, 0, 0, 2117, 2150,
		1, 0, 0, 0, 2118, 2120, 10, 2, 0, 0, 2119, 2121, 3, 194, 97, 0, 2120, 2119,
		1, 0, 0, 0, 2120, 2121, 1, 0, 0, 0, 2121, 2125, 1, 0, 0, 0, 2122, 2123,
		3, 340, 170, 0, 2123, 2124, 5, 88, 0, 0, 2124, 2126, 1, 0, 0, 0, 2125,
		2122, 1, 0, 0, 0, 2125, 2126, 1, 0, 0, 0, 2126, 2130, 1, 0, 0, 0, 2127,
		2129, 5, 88, 0, 0, 2128, 2127, 1, 0, 0, 0, 2129, 2132, 1, 0, 0, 0, 2130,
		2128, 1, 0, 0, 0, 2130, 2131, 1, 0, 0, 0, 2131, 2133, 1, 0, 0, 0, 2132,
		2130, 1, 0, 0, 0, 2133, 2137, 5, 44, 0, 0, 2134, 2136, 5, 88, 0, 0, 2135,
		2134, 1, 0, 0, 0, 2136, 2139, 1, 0, 0, 0, 2137, 2135, 1, 0, 0, 0, 2137,
		2138, 1, 0, 0, 0, 2138, 2140, 1, 0, 0, 0, 2139, 2137, 1, 0, 0, 0, 2140,
		2142, 3, 294, 147, 0, 2141, 2143, 3, 194, 97, 0, 2142, 2141, 1, 0, 0, 0,
		2142, 2143, 1, 0, 0, 0, 2143, 2147, 1, 0, 0, 0, 2144, 2145, 3, 340, 170,
		0, 2145, 2146, 5, 88, 0, 0, 2146, 2148, 1, 0, 0, 0, 2147, 2144, 1, 0, 0,
		0, 2147, 2148, 1, 0, 0, 0, 2148, 2150, 1, 0, 0, 0, 2149, 2087, 1, 0, 0,
		0, 2149, 2118, 1, 0, 0, 0, 2150, 2153, 1, 0, 0, 0, 2151, 2149, 1, 0, 0,
		0, 2151, 2152, 1, 0, 0, 0, 2152, 295, 1, 0, 0, 0, 2153, 2151, 1, 0, 0,
		0, 2154, 2159, 3, 314, 157, 0, 2155, 2159, 3, 316, 158, 0, 2156, 2159,
		3, 306, 153, 0, 2157, 2159, 3, 300, 150, 0, 2158, 2154, 1, 0, 0, 0, 2158,
		2155, 1, 0, 0, 0, 2158, 2156, 1, 0, 0, 0, 2158, 2157, 1, 0, 0, 0, 2159,
		297, 1, 0, 0, 0, 2160, 2162, 5, 37, 0, 0, 2161, 2160, 1, 0, 0, 0, 2161,
		2162, 1, 0, 0, 0, 2162, 2163, 1, 0, 0, 0, 2163, 2165, 3, 292, 146, 0, 2164,
		2166, 3, 194, 97, 0, 2165, 2164, 1, 0, 0, 0, 2165, 2166, 1, 0, 0, 0, 2166,
		299, 1, 0, 0, 0, 2167, 2168, 3, 62, 31, 0, 2168, 2169, 5, 29, 0, 0, 2169,
		2171, 1, 0, 0, 0, 2170, 2167, 1, 0, 0, 0, 2170, 2171, 1, 0, 0, 0, 2171,
		2172, 1, 0, 0, 0, 2172, 2177, 3, 302, 151, 0, 2173, 2174, 5, 29, 0, 0,
		2174, 2176, 3, 302, 151, 0, 2175, 2173, 1, 0, 0, 0, 2176, 2179, 1, 0, 0,
		0, 2177, 2175, 1, 0, 0, 0, 2177, 2178, 1, 0, 0, 0, 2178, 301, 1, 0, 0,
		0, 2179, 2177, 1, 0, 0, 0, 2180, 2182, 3, 304, 152, 0, 2181, 2183, 3, 50,
		25, 0, 2182, 2181, 1, 0, 0, 0, 2182, 2183, 1, 0, 0, 0, 2183, 303, 1, 0,
		0, 0, 2184, 2185, 5, 72, 0, 0, 2185, 305, 1, 0, 0, 0, 2186, 2194, 5, 31,
		0, 0, 2187, 2189, 5, 88, 0, 0, 2188, 2187, 1, 0, 0, 0, 2189, 2192, 1, 0,
		0, 0, 2190, 2188, 1, 0, 0, 0, 2190, 2191, 1, 0, 0, 0, 2191, 2193, 1, 0,
		0, 0, 2192, 2190, 1, 0, 0, 0, 2193, 2195, 3, 308, 154, 0, 2194, 2190, 1,
		0, 0, 0, 2194, 2195, 1, 0, 0, 0, 2195, 2199, 1, 0, 0, 0, 2196, 2198, 5,
		88, 0, 0, 2197, 2196, 1, 0, 0, 0, 2198, 2201, 1, 0, 0, 0, 2199, 2197, 1,
		0, 0, 0, 2199, 2200, 1, 0, 0, 0, 2200, 2202, 1, 0, 0, 0, 2201, 2199, 1,
		0, 0, 0, 2202, 2203, 5, 34, 0, 0, 2203, 307, 1, 0, 0, 0, 2204, 2216, 3,
		310, 155, 0, 2205, 2209, 3, 388, 194, 0, 2206, 2208, 5, 88, 0, 0, 2207,
		2206, 1, 0, 0, 0, 2208, 2211, 1, 0, 0, 0, 2209, 2207, 1, 0, 0, 0, 2209,
		2210, 1, 0, 0, 0, 2210, 2212, 1, 0, 0, 0, 2211, 2209, 1, 0, 0, 0, 2212,
		2213, 3, 310, 155, 0, 2213, 2215, 1, 0, 0, 0, 2214, 2205, 1, 0, 0, 0, 2215,
		2218, 1, 0, 0, 0, 2216, 2214, 1, 0, 0, 0, 2216, 2217, 1, 0, 0, 0, 2217,
		2220, 1, 0, 0, 0, 2218, 2216, 1, 0, 0, 0, 2219, 2221, 3, 388, 194, 0, 2220,
		2219, 1, 0, 0, 0, 2220, 2221, 1, 0, 0, 0, 2221, 309, 1, 0, 0, 0, 2222,
		2224, 3, 326, 163, 0, 2223, 2225, 5, 37, 0, 0, 2224, 2223, 1, 0, 0, 0,
		2224, 2225, 1, 0, 0, 0, 2225, 2227, 1, 0, 0, 0, 2226, 2222, 1, 0, 0, 0,
		2226, 2227, 1, 0, 0, 0, 2227, 2228, 1, 0, 0, 0, 2228, 2230, 3, 292, 146,
		0, 2229, 2231, 3, 194, 97, 0, 2230, 2229, 1, 0, 0, 0, 2230, 2231, 1, 0,
		0, 0, 2231, 311, 1, 0, 0, 0, 2232, 2233, 3, 116, 58, 0, 2233, 2234, 3,
		346, 173, 0, 2234, 2236, 3, 292, 146, 0, 2235, 2237, 3, 194, 97, 0, 2236,
		2235, 1, 0, 0, 0, 2236, 2237, 1, 0, 0, 0, 2237, 313, 1, 0, 0, 0, 2238,
		2239, 5, 32, 0, 0, 2239, 2241, 3, 292, 146, 0, 2240, 2242, 3, 194, 97,
		0, 2241, 2240, 1, 0, 0, 0, 2241, 2242, 1, 0, 0, 0, 2242, 2243, 1, 0, 0,
		0, 2243, 2244, 5, 35, 0, 0, 2244, 315, 1, 0, 0, 0, 2245, 2246, 5, 30, 0,
		0, 2246, 2248, 3, 292, 146, 0, 2247, 2249, 3, 318, 159, 0, 2248, 2247,
		1, 0, 0, 0, 2248, 2249, 1, 0, 0, 0, 2249, 2251, 1, 0, 0, 0, 2250, 2252,
		5, 37, 0, 0, 2251, 2250, 1, 0, 0, 0, 2251, 2252, 1, 0, 0, 0, 2252, 2253,
		1, 0, 0, 0, 2253, 2255, 3, 292, 146, 0, 2254, 2256, 3, 194, 97, 0, 2255,
		2254, 1, 0, 0, 0, 2255, 2256, 1, 0, 0, 0, 2256, 2257, 1, 0, 0, 0, 2257,
		2258, 5, 33, 0, 0, 2258, 317, 1, 0, 0, 0, 2259, 2260, 3, 194, 97, 0, 2260,
		319, 1, 0, 0, 0, 2261, 2265, 5, 37, 0, 0, 2262, 2264, 5, 88, 0, 0, 2263,
		2262, 1, 0, 0, 0, 2264, 2267, 1, 0, 0, 0, 2265, 2263, 1, 0, 0, 0, 2265,
		2266, 1, 0, 0, 0, 2266, 2268, 1, 0, 0, 0, 2267, 2265, 1, 0, 0, 0, 2268,
		2269, 3, 322, 161, 0, 2269, 321, 1, 0, 0, 0, 2270, 2282, 3, 324, 162, 0,
		2271, 2275, 3, 388, 194, 0, 2272, 2274, 5, 88, 0, 0, 2273, 2272, 1, 0,
		0, 0, 2274, 2277, 1, 0, 0, 0, 2275, 2273, 1, 0, 0, 0, 2275, 2276, 1, 0,
		0, 0, 2276, 2278, 1, 0, 0, 0, 2277, 2275, 1, 0, 0, 0, 2278, 2279, 3, 324,
		162, 0, 2279, 2281, 1, 0, 0, 0, 2280, 2271, 1, 0, 0, 0, 2281, 2284, 1,
		0, 0, 0, 2282, 2280, 1, 0, 0, 0, 2282, 2283, 1, 0, 0, 0, 2283, 2286, 1,
		0, 0, 0, 2284, 2282, 1, 0, 0, 0, 2285, 2287, 3, 388, 194, 0, 2286, 2285,
		1, 0, 0, 0, 2286, 2287, 1, 0, 0, 0, 2287, 323, 1, 0, 0, 0, 2288, 2290,
		3, 294, 147, 0, 2289, 2291, 3, 194, 97, 0, 2290, 2289, 1, 0, 0, 0, 2290,
		2291, 1, 0, 0, 0, 2291, 325, 1, 0, 0, 0, 2292, 2295, 5, 73, 0, 0, 2293,
		2295, 3, 334, 167, 0, 2294, 2292, 1, 0, 0, 0, 2294, 2293, 1, 0, 0, 0, 2295,
		327, 1, 0, 0, 0, 2296, 2299, 5, 73, 0, 0, 2297, 2299, 3, 336, 168, 0, 2298,
		2296, 1, 0, 0, 0, 2298, 2297, 1, 0, 0, 0, 2299, 329, 1, 0, 0, 0, 2300,
		2305, 3, 326, 163, 0, 2301, 2302, 5, 29, 0, 0, 2302, 2304, 3, 326, 163,
		0, 2303, 2301, 1, 0, 0, 0, 2304, 2307, 1, 0, 0, 0, 2305, 2303, 1, 0, 0,
		0, 2305, 2306, 1, 0, 0, 0, 2306, 331, 1, 0, 0, 0, 2307, 2305, 1, 0, 0,
		0, 2308, 2309, 7, 1, 0, 0, 2309, 333, 1, 0, 0, 0, 2310, 2311, 7, 2, 0,
		0, 2311, 335, 1, 0, 0, 0, 2312, 2313, 7, 3, 0, 0, 2313, 337, 1, 0, 0, 0,
		2314, 2319, 5, 89, 0, 0, 2315, 2316, 5, 88, 0, 0, 2316, 2318, 5, 89, 0,
		0, 2317, 2315, 1, 0, 0, 0, 2318, 2321, 1, 0, 0, 0, 2319, 2317, 1, 0, 0,
		0, 2319, 2320, 1, 0, 0, 0, 2320, 339, 1, 0, 0, 0, 2321, 2319, 1, 0, 0,
		0, 2322, 2327, 5, 90, 0, 0, 2323, 2324, 5, 88, 0, 0, 2324, 2326, 5, 90,
		0, 0, 2325, 2323, 1, 0, 0, 0, 2326, 2329, 1, 0, 0, 0, 2327, 2325, 1, 0,
		0, 0, 2327, 2328, 1, 0, 0, 0, 2328, 341, 1, 0, 0, 0, 2329, 2327, 1, 0,
		0, 0, 2330, 2331, 5, 46, 0, 0, 2331, 343, 1, 0, 0, 0, 2332, 2333, 5, 45,
		0, 0, 2333, 345, 1, 0, 0, 0, 2334, 2335, 5, 61, 0, 0, 2335, 347, 1, 0,
		0, 0, 2336, 2337, 5, 62, 0, 0, 2337, 349, 1, 0, 0, 0, 2338, 2339, 5, 63,
		0, 0, 2339, 351, 1, 0, 0, 0, 2340, 2346, 3, 348, 174, 0, 2341, 2346, 3,
		350, 175, 0, 2342, 2346, 3, 358, 179, 0, 2343, 2346, 5, 1, 0, 0, 2344,
		2346, 5, 20, 0, 0, 2345, 2340, 1, 0, 0, 0, 2345, 2341, 1, 0, 0, 0, 2345,
		2342, 1, 0, 0, 0, 2345, 2343, 1, 0, 0, 0, 2345, 2344, 1, 0, 0, 0, 2346,
		353, 1, 0, 0, 0, 2347, 2350, 3, 358, 179, 0, 2348, 2350, 5, 18, 0, 0, 2349,
		2347, 1, 0, 0, 0, 2349, 2348, 1, 0, 0, 0, 2350, 355, 1, 0, 0, 0, 2351,
		2352, 7, 4, 0, 0, 2352, 357, 1, 0, 0, 0, 2353, 2355, 3, 364, 182, 0, 2354,
		2356, 3, 360, 180, 0, 2355, 2354, 1, 0, 0, 0, 2355, 2356, 1, 0, 0, 0, 2356,
		2364, 1, 0, 0, 0, 2357, 2359, 3, 366, 183, 0, 2358, 2360, 3, 368, 184,
		0, 2359, 2358, 1, 0, 0, 0, 2360, 2361, 1, 0, 0, 0, 2361, 2359, 1, 0, 0,
		0, 2361, 2362, 1, 0, 0, 0, 2362, 2364, 1, 0, 0, 0, 2363, 2353, 1, 0, 0,
		0, 2363, 2357, 1, 0, 0, 0, 2364, 359, 1, 0, 0, 0, 2365, 2366, 4, 180, 11,
		0, 2366, 2368, 3, 362, 181, 0, 2367, 2365, 1, 0, 0, 0, 2368, 2369, 1, 0,
		0, 0, 2369, 2367, 1, 0, 0, 0, 2369, 2370, 1, 0, 0, 0, 2370, 361, 1, 0,
		0, 0, 2371, 2374, 3, 364, 182, 0, 2372, 2374, 5, 92, 0, 0, 2373, 2371,
		1, 0, 0, 0, 2373, 2372, 1, 0, 0, 0, 2374, 363, 1, 0, 0, 0, 2375, 2378,
		7, 5, 0, 0, 2376, 2378, 5, 74, 0, 0, 2377, 2375, 1, 0, 0, 0, 2377, 2376,
		1, 0, 0, 0, 2378, 365, 1, 0, 0, 0, 2379, 2380, 5, 29, 0, 0, 2380, 367,
		1, 0, 0, 0, 2381, 2384, 5, 29, 0, 0, 2382, 2384, 3, 362, 181, 0, 2383,
		2381, 1, 0, 0, 0, 2383, 2382, 1, 0, 0, 0, 2384, 369, 1, 0, 0, 0, 2385,
		2390, 3, 376, 188, 0, 2386, 2390, 3, 380, 190, 0, 2387, 2390, 3, 372, 186,
		0, 2388, 2390, 3, 374, 187, 0, 2389, 2385, 1, 0, 0, 0, 2389, 2386, 1, 0,
		0, 0, 2389, 2387, 1, 0, 0, 0, 2389, 2388, 1, 0, 0, 0, 2390, 371, 1, 0,
		0, 0, 2391, 2392, 7, 6, 0, 0, 2392, 373, 1, 0, 0, 0, 2393, 2394, 5, 19,
		0, 0, 2394, 375, 1, 0, 0, 0, 2395, 2397, 3, 344, 172, 0, 2396, 2395, 1,
		0, 0, 0, 2396, 2397, 1, 0, 0, 0, 2397, 2398, 1, 0, 0, 0, 2398, 2404, 3,
		378, 189, 0, 2399, 2401, 3, 344, 172, 0, 2400, 2399, 1, 0, 0, 0, 2400,
		2401, 1, 0, 0, 0, 2401, 2402, 1, 0, 0, 0, 2402, 2404, 5, 81, 0, 0, 2403,
		2396, 1, 0, 0, 0, 2403, 2400, 1, 0, 0, 0, 2404, 377, 1, 0, 0, 0, 2405,
		2406, 7, 7, 0, 0, 2406, 379, 1, 0, 0, 0, 2407, 2408, 7, 8, 0, 0, 2408,
		381, 1, 0, 0, 0, 2409, 2410, 7, 9, 0, 0, 2410, 383, 1, 0, 0, 0, 2411, 2412,
		7, 10, 0, 0, 2412, 385, 1, 0, 0, 0, 2413, 2417, 5, 38, 0, 0, 2414, 2415,
		3, 340, 170, 0, 2415, 2416, 5, 88, 0, 0, 2416, 2418, 1, 0, 0, 0, 2417,
		2414, 1, 0, 0, 0, 2417, 2418, 1, 0, 0, 0, 2418, 2424, 1, 0, 0, 0, 2419,
		2421, 3, 340, 170, 0, 2420, 2419, 1, 0, 0, 0, 2420, 2421, 1, 0, 0, 0, 2421,
		2422, 1, 0, 0, 0, 2422, 2424, 5, 88, 0, 0, 2423, 2413, 1, 0, 0, 0, 2423,
		2420, 1, 0, 0, 0, 2424, 387, 1, 0, 0, 0, 2425, 2429, 5, 36, 0, 0, 2426,
		2427, 3, 340, 170, 0, 2427, 2428, 5, 88, 0, 0, 2428, 2430, 1, 0, 0, 0,
		2429, 2426, 1, 0, 0, 0, 2429, 2430, 1, 0, 0, 0, 2430, 2436, 1, 0, 0, 0,
		2431, 2433, 3, 340, 170, 0, 2432, 2431, 1, 0, 0, 0, 2432, 2433, 1, 0, 0,
		0, 2433, 2434, 1, 0, 0, 0, 2434, 2436, 5, 88, 0, 0, 2435, 2425, 1, 0, 0,
		0, 2435, 2432, 1, 0, 0, 0, 2436, 389, 1, 0, 0, 0, 339, 393, 397, 402, 411,
		417, 432, 439, 443, 447, 454, 462, 472, 482, 489, 494, 501, 508, 515, 522,
		526, 532, 540, 544, 551, 558, 562, 567, 577, 584, 588, 592, 597, 604, 609,
		614, 622, 628, 635, 645, 652, 656, 665, 671, 678, 688, 695, 700, 705, 711,
		714, 727, 733, 737, 742, 752, 756, 763, 774, 781, 795, 805, 812, 819, 825,
		830, 834, 838, 842, 846, 856, 863, 870, 878, 885, 889, 894, 899, 904, 909,
		915, 921, 932, 937, 942, 953, 958, 961, 966, 972, 976, 980, 984, 989, 993,
		998, 1000, 1004, 1009, 1013, 1017, 1022, 1026, 1031, 1042, 1049, 1054,
		1061, 1068, 1072, 1079, 1083, 1087, 1092, 1094, 1099, 1104, 1108, 1113,
		1120, 1125, 1129, 1134, 1146, 1153, 1157, 1162, 1167, 1171, 1176, 1180,
		1183, 1188, 1197, 1201, 1206, 1210, 1216, 1221, 1225, 1230, 1240, 1247,
		1251, 1256, 1261, 1268, 1271, 1278, 1282, 1287, 1296, 1300, 1305, 1312,
		1317, 1321, 1326, 1336, 1343, 1347, 1352, 1357, 1361, 1364, 1368, 1373,
		1381, 1388, 1392, 1395, 1397, 1402, 1407, 1416, 1422, 1426, 1429, 1434,
		1438, 1442, 1448, 1455, 1464, 1473, 1488, 1491, 1493, 1498, 1508, 1512,
		1517, 1525, 1534, 1541, 1545, 1549, 1554, 1559, 1566, 1573, 1577, 1583,
		1595, 1600, 1610, 1615, 1621, 1629, 1638, 1647, 1652, 1663, 1667, 1672,
		1682, 1689, 1693, 1697, 1703, 1707, 1712, 1722, 1729, 1733, 1737, 1746,
		1750, 1755, 1765, 1772, 1776, 1781, 1793, 1800, 1804, 1809, 1819, 1826,
		1830, 1836, 1843, 1852, 1859, 1869, 1876, 1880, 1885, 1891, 1898, 1905,
		1909, 1913, 1922, 1929, 1942, 1946, 1954, 1962, 1966, 1973, 1983, 1985,
		1992, 1996, 2002, 2010, 2017, 2022, 2029, 2037, 2041, 2046, 2056, 2065,
		2079, 2081, 2089, 2094, 2099, 2106, 2111, 2116, 2120, 2125, 2130, 2137,
		2142, 2147, 2149, 2151, 2158, 2161, 2165, 2170, 2177, 2182, 2190, 2194,
		2199, 2209, 2216, 2220, 2224, 2226, 2230, 2236, 2241, 2248, 2251, 2255,
		2265, 2275, 2282, 2286, 2290, 2294, 2298, 2305, 2319, 2327, 2345, 2349,
		2355, 2361, 2363, 2369, 2373, 2377, 2383, 2389, 2396, 2400, 2403, 2417,
		2420, 2423, 2429, 2432, 2435,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// MojoParserInit initializes any static state used to implement MojoParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewMojoParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func MojoParserInit() {
	staticData := &MojoParserParserStaticData
	staticData.once.Do(mojoparserParserInit)
}

// NewMojoParser produces a new parser instance for the optional input antlr.TokenStream.
func NewMojoParser(input antlr.TokenStream) *MojoParser {
	MojoParserInit()
	this := new(MojoParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &MojoParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "MojoParser.g4"

	return this
}

// MojoParser tokens.
const (
	MojoParserEOF                               = antlr.TokenEOF
	MojoParserKEYWORD_AND                       = 1
	MojoParserKEYWORD_AS                        = 2
	MojoParserKEYWORD_ATTRIBUTE                 = 3
	MojoParserKEYWORD_BREAK                     = 4
	MojoParserKEYWORD_CONST                     = 5
	MojoParserKEYWORD_CONTINUE                  = 6
	MojoParserKEYWORD_ELSE                      = 7
	MojoParserKEYWORD_ENUM                      = 8
	MojoParserKEYWORD_FALSE                     = 9
	MojoParserKEYWORD_FOR                       = 10
	MojoParserKEYWORD_FUNC                      = 11
	MojoParserKEYWORD_IF                        = 12
	MojoParserKEYWORD_IMPORT                    = 13
	MojoParserKEYWORD_IN                        = 14
	MojoParserKEYWORD_INTERFACE                 = 15
	MojoParserKEYWORD_IS                        = 16
	MojoParserKEYWORD_MATCH                     = 17
	MojoParserKEYWORD_NOT                       = 18
	MojoParserKEYWORD_NULL                      = 19
	MojoParserKEYWORD_OR                        = 20
	MojoParserKEYWORD_PACKAGE                   = 21
	MojoParserKEYWORD_RETURN                    = 22
	MojoParserKEYWORD_STRUCT                    = 23
	MojoParserKEYWORD_TRUE                      = 24
	MojoParserKEYWORD_TYPE                      = 25
	MojoParserKEYWORD_VAR                       = 26
	MojoParserKEYWORD_WHILE                     = 27
	MojoParserKEYWORD_XOR                       = 28
	MojoParserDOT                               = 29
	MojoParserLCURLY                            = 30
	MojoParserLPAREN                            = 31
	MojoParserLBRACK                            = 32
	MojoParserRCURLY                            = 33
	MojoParserRPAREN                            = 34
	MojoParserRBRACK                            = 35
	MojoParserCOMMA                             = 36
	MojoParserCOLON                             = 37
	MojoParserSEMI                              = 38
	MojoParserLT                                = 39
	MojoParserGT                                = 40
	MojoParserBANG                              = 41
	MojoParserQUESTION                          = 42
	MojoParserAT                                = 43
	MojoParserAND                               = 44
	MojoParserMINUS                             = 45
	MojoParserEQUAL                             = 46
	MojoParserPIPE                              = 47
	MojoParserSLASH                             = 48
	MojoParserPLUS                              = 49
	MojoParserSTAR                              = 50
	MojoParserPERCENT                           = 51
	MojoParserCARET                             = 52
	MojoParserTILDE                             = 53
	MojoParserDOLLER                            = 54
	MojoParserBACKTICK                          = 55
	MojoParserUNDERSCORE                        = 56
	MojoParserPLUS_PLUS                         = 57
	MojoParserMINUS_MINUS                       = 58
	MojoParserCOLON_EQUAL                       = 59
	MojoParserRIGHT_RIGHT_ARROWS                = 60
	MojoParserRIGHT_ARROW                       = 61
	MojoParserDOT_DOT                           = 62
	MojoParserDOT_DOT_LT                        = 63
	MojoParserELLIPSIS                          = 64
	MojoParserGRAPH_RIGHT_PATH                  = 65
	MojoParserGRAPH_LEFT_PATH                   = 66
	MojoParserGRAPH_PATH                        = 67
	MojoParserGRAPH_CONSTRAINT_PATH_LEFT        = 68
	MojoParserGRAPH_CONSTRAINT_PATH_LEFT_ARROW  = 69
	MojoParserGRAPH_CONSTRAINT_PATH_RIGHT       = 70
	MojoParserGRAPH_CONSTRAINT_PATH_RIGHT_ARROW = 71
	MojoParserTYPE_IDENTIFIER                   = 72
	MojoParserVALUE_IDENTIFIER                  = 73
	MojoParserOPERATOR_HEAD_OTHER               = 74
	MojoParserIMPLICIT_PARAMETER_NAME           = 75
	MojoParserBINARY_LITERAL                    = 76
	MojoParserOCTAL_LITERAL                     = 77
	MojoParserDECIMAL_LITERAL                   = 78
	MojoParserPURE_DECIMAL_DIGITS               = 79
	MojoParserHEXADECIMAL_LITERAL               = 80
	MojoParserFLOAT_LITERAL                     = 81
	MojoParserSTATIC_STRING_LITERAL             = 82
	MojoParserINTERPOLATED_STRING_LITERAL       = 83
	MojoParserWS                                = 84
	MojoParserBLOCK_COMMENT                     = 85
	MojoParserLINE_COMMENT                      = 86
	MojoParserLINE_COMMENT_DISTINCT_DOCUMENT    = 87
	MojoParserEOL                               = 88
	MojoParserLINE_DOCUMENT                     = 89
	MojoParserFOLLOWING_LINE_DOCUMENT           = 90
	MojoParserINNER_LINE_DOCUMENT               = 91
	MojoParserOPERATOR_FOLLOWING_CHARACTER      = 92
)

// MojoParser rules.
const (
	MojoParserRULE_mojoFile                          = 0
	MojoParserRULE_statement                         = 1
	MojoParserRULE_ifModifier                        = 2
	MojoParserRULE_whileModifier                     = 3
	MojoParserRULE_floatingStatement                 = 4
	MojoParserRULE_statements                        = 5
	MojoParserRULE_loopStatement                     = 6
	MojoParserRULE_forInStatement                    = 7
	MojoParserRULE_whileStatement                    = 8
	MojoParserRULE_conditions                        = 9
	MojoParserRULE_condition                         = 10
	MojoParserRULE_optionalBindingCondition          = 11
	MojoParserRULE_branchStatement                   = 12
	MojoParserRULE_ifStatement                       = 13
	MojoParserRULE_elseClause                        = 14
	MojoParserRULE_matchStatement                    = 15
	MojoParserRULE_matchCases                        = 16
	MojoParserRULE_matchCase                         = 17
	MojoParserRULE_controlTransferStatement          = 18
	MojoParserRULE_breakStatement                    = 19
	MojoParserRULE_continueStatement                 = 20
	MojoParserRULE_returnStatement                   = 21
	MojoParserRULE_genericParameterClause            = 22
	MojoParserRULE_genericParameters                 = 23
	MojoParserRULE_genericParameter                  = 24
	MojoParserRULE_genericArgumentClause             = 25
	MojoParserRULE_genericArguments                  = 26
	MojoParserRULE_genericArgument                   = 27
	MojoParserRULE_declaration                       = 28
	MojoParserRULE_codeBlock                         = 29
	MojoParserRULE_packageDeclaration                = 30
	MojoParserRULE_packageIdentifier                 = 31
	MojoParserRULE_packageName                       = 32
	MojoParserRULE_importDeclaration                 = 33
	MojoParserRULE_importPath                        = 34
	MojoParserRULE_importPathIdentifier              = 35
	MojoParserRULE_importAllClause                   = 36
	MojoParserRULE_importValueAsClause               = 37
	MojoParserRULE_importTypeClause                  = 38
	MojoParserRULE_importTypeAsClause                = 39
	MojoParserRULE_importGroupClause                 = 40
	MojoParserRULE_importGroup                       = 41
	MojoParserRULE_importValue                       = 42
	MojoParserRULE_importType                        = 43
	MojoParserRULE_constantDeclaration               = 44
	MojoParserRULE_patternInitializers               = 45
	MojoParserRULE_documentedPatternInitializer      = 46
	MojoParserRULE_patternInitializer                = 47
	MojoParserRULE_initializer                       = 48
	MojoParserRULE_variableDeclaration               = 49
	MojoParserRULE_typeAliasDeclaration              = 50
	MojoParserRULE_typeAliasName                     = 51
	MojoParserRULE_typeAliasAssignment               = 52
	MojoParserRULE_functionDeclaration               = 53
	MojoParserRULE_functionName                      = 54
	MojoParserRULE_functionSignature                 = 55
	MojoParserRULE_functionResult                    = 56
	MojoParserRULE_functionBody                      = 57
	MojoParserRULE_functionParameterClause           = 58
	MojoParserRULE_functionParameters                = 59
	MojoParserRULE_functionParameter                 = 60
	MojoParserRULE_enumDeclaration                   = 61
	MojoParserRULE_enumBody                          = 62
	MojoParserRULE_enumName                          = 63
	MojoParserRULE_enumMembers                       = 64
	MojoParserRULE_enumMember                        = 65
	MojoParserRULE_structDeclaration                 = 66
	MojoParserRULE_structName                        = 67
	MojoParserRULE_structType                        = 68
	MojoParserRULE_structBody                        = 69
	MojoParserRULE_structMembers                     = 70
	MojoParserRULE_structMember                      = 71
	MojoParserRULE_structMemberDeclaration           = 72
	MojoParserRULE_interfaceDeclaration              = 73
	MojoParserRULE_interfaceName                     = 74
	MojoParserRULE_interfaceType                     = 75
	MojoParserRULE_interfaceBody                     = 76
	MojoParserRULE_interfaceMembers                  = 77
	MojoParserRULE_interfaceMember                   = 78
	MojoParserRULE_interfaceMethodDeclaration        = 79
	MojoParserRULE_attributeDeclaration              = 80
	MojoParserRULE_attributeAliasDeclaration         = 81
	MojoParserRULE_attributeAliasAssignment          = 82
	MojoParserRULE_pattern                           = 83
	MojoParserRULE_wildcardPattern                   = 84
	MojoParserRULE_identifierPattern                 = 85
	MojoParserRULE_tuplePattern                      = 86
	MojoParserRULE_tuplePatternElementList           = 87
	MojoParserRULE_tuplePatternElement               = 88
	MojoParserRULE_optionalPattern                   = 89
	MojoParserRULE_expressionPattern                 = 90
	MojoParserRULE_attribute                         = 91
	MojoParserRULE_attributeIdentifier               = 92
	MojoParserRULE_attributeName                     = 93
	MojoParserRULE_attributeArgumentClause           = 94
	MojoParserRULE_attributeArgument                 = 95
	MojoParserRULE_attributeArguments                = 96
	MojoParserRULE_attributes                        = 97
	MojoParserRULE_expression                        = 98
	MojoParserRULE_expressions                       = 99
	MojoParserRULE_prefixExpression                  = 100
	MojoParserRULE_binaryExpression                  = 101
	MojoParserRULE_binaryExpressions                 = 102
	MojoParserRULE_conditionalOperator               = 103
	MojoParserRULE_typeCastingOperator               = 104
	MojoParserRULE_primaryExpression                 = 105
	MojoParserRULE_literalExpression                 = 106
	MojoParserRULE_numericOperatorLiteral            = 107
	MojoParserRULE_stringOperatorLiteral             = 108
	MojoParserRULE_suffixLiteralOperator             = 109
	MojoParserRULE_prefixLiteralOperator             = 110
	MojoParserRULE_arrayLiteral                      = 111
	MojoParserRULE_arrayLiteralItems                 = 112
	MojoParserRULE_arrayLiteralItem                  = 113
	MojoParserRULE_mapLiteral                        = 114
	MojoParserRULE_mapLiteralItems                   = 115
	MojoParserRULE_mapLiteralItem                    = 116
	MojoParserRULE_objectLiteral                     = 117
	MojoParserRULE_objectLiteralItems                = 118
	MojoParserRULE_objectLiteralItem                 = 119
	MojoParserRULE_structLiteral                     = 120
	MojoParserRULE_structConstructionExpression      = 121
	MojoParserRULE_matchExprSuffix                   = 122
	MojoParserRULE_matchExprCases                    = 123
	MojoParserRULE_matchExprCase                     = 124
	MojoParserRULE_closureExpression                 = 125
	MojoParserRULE_closureParameters                 = 126
	MojoParserRULE_closureParameter                  = 127
	MojoParserRULE_implicitMemberExpression          = 128
	MojoParserRULE_parenthesizedExpression           = 129
	MojoParserRULE_tupleLiteralExpression            = 130
	MojoParserRULE_tupleElement                      = 131
	MojoParserRULE_wildcardExpression                = 132
	MojoParserRULE_postfixExpression                 = 133
	MojoParserRULE_suffixExpression                  = 134
	MojoParserRULE_explicitMemberSuffix              = 135
	MojoParserRULE_subscriptSuffix                   = 136
	MojoParserRULE_functionCallSuffix                = 137
	MojoParserRULE_functionCallArgumentClause        = 138
	MojoParserRULE_functionCallArguments             = 139
	MojoParserRULE_functionCallArgument              = 140
	MojoParserRULE_trailingClosures                  = 141
	MojoParserRULE_labeledTrailingClosures           = 142
	MojoParserRULE_labeledTrailingClosure            = 143
	MojoParserRULE_argumentNames                     = 144
	MojoParserRULE_argumentName                      = 145
	MojoParserRULE_type_                             = 146
	MojoParserRULE_basicType                         = 147
	MojoParserRULE_primeType                         = 148
	MojoParserRULE_typeAnnotation                    = 149
	MojoParserRULE_typeIdentifier                    = 150
	MojoParserRULE_typeIdentifierClause              = 151
	MojoParserRULE_typeName                          = 152
	MojoParserRULE_tupleType                         = 153
	MojoParserRULE_tupleTypeElements                 = 154
	MojoParserRULE_tupleTypeElement                  = 155
	MojoParserRULE_functionType                      = 156
	MojoParserRULE_arrayType                         = 157
	MojoParserRULE_mapType                           = 158
	MojoParserRULE_keyAttributes                     = 159
	MojoParserRULE_typeInheritanceClause             = 160
	MojoParserRULE_typeInheritances                  = 161
	MojoParserRULE_typeInheritance                   = 162
	MojoParserRULE_declarationIdentifier             = 163
	MojoParserRULE_labelIdentifier                   = 164
	MojoParserRULE_pathIdentifier                    = 165
	MojoParserRULE_identifier                        = 166
	MojoParserRULE_keywordAsIdentifierInDeclarations = 167
	MojoParserRULE_keywordAsIdentifierInLabels       = 168
	MojoParserRULE_document                          = 169
	MojoParserRULE_followingDocument                 = 170
	MojoParserRULE_assignmentOperator                = 171
	MojoParserRULE_negatePrefixOperator              = 172
	MojoParserRULE_arrowOperator                     = 173
	MojoParserRULE_rangeOperator                     = 174
	MojoParserRULE_halfOpenRangeOperator             = 175
	MojoParserRULE_binaryOperator                    = 176
	MojoParserRULE_prefixOperator                    = 177
	MojoParserRULE_postfixOperator                   = 178
	MojoParserRULE_operator                          = 179
	MojoParserRULE_operator_characters               = 180
	MojoParserRULE_operator_character                = 181
	MojoParserRULE_operator_head                     = 182
	MojoParserRULE_dot_operator_head                 = 183
	MojoParserRULE_dot_operator_character            = 184
	MojoParserRULE_literal                           = 185
	MojoParserRULE_boolLiteral                       = 186
	MojoParserRULE_nullLiteral                       = 187
	MojoParserRULE_numericLiteral                    = 188
	MojoParserRULE_integerLiteral                    = 189
	MojoParserRULE_stringLiteral                     = 190
	MojoParserRULE_eos                               = 191
	MojoParserRULE_eov                               = 192
	MojoParserRULE_eosWithDocument                   = 193
	MojoParserRULE_eovWithDocument                   = 194
)

// IMojoFileContext is an interface to support dynamic dispatch.
type IMojoFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	Statements() IStatementsContext

	// IsMojoFileContext differentiates from other interfaces.
	IsMojoFileContext()
}

type MojoFileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMojoFileContext() *MojoFileContext {
	var p = new(MojoFileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_mojoFile
	return p
}

func InitEmptyMojoFileContext(p *MojoFileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_mojoFile
}

func (*MojoFileContext) IsMojoFileContext() {}

func NewMojoFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MojoFileContext {
	var p = new(MojoFileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_mojoFile

	return p
}

func (s *MojoFileContext) GetParser() antlr.Parser { return s.parser }

func (s *MojoFileContext) EOF() antlr.TerminalNode {
	return s.GetToken(MojoParserEOF, 0)
}

func (s *MojoFileContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *MojoFileContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *MojoFileContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *MojoFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MojoFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MojoFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitMojoFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) MojoFile() (localctx IMojoFileContext) {
	localctx = NewMojoFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MojoParserRULE_mojoFile)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(390)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90071451381530622) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&135159) != 0) {
		{
			p.SetState(396)
			p.Statements()
		}

	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(399)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(405)
		p.Match(MojoParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declaration() IDeclarationContext
	Expression() IExpressionContext
	IfModifier() IIfModifierContext
	WhileModifier() IWhileModifierContext
	LoopStatement() ILoopStatementContext
	BranchStatement() IBranchStatementContext
	ControlTransferStatement() IControlTransferStatementContext
	FloatingStatement() IFloatingStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *StatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) IfModifier() IIfModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfModifierContext)
}

func (s *StatementContext) WhileModifier() IWhileModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileModifierContext)
}

func (s *StatementContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *StatementContext) BranchStatement() IBranchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBranchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBranchStatementContext)
}

func (s *StatementContext) ControlTransferStatement() IControlTransferStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlTransferStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlTransferStatementContext)
}

func (s *StatementContext) FloatingStatement() IFloatingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatingStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MojoParserRULE_statement)
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(407)
			p.Declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(408)
			p.Expression()
		}
		p.SetState(411)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MojoParserKEYWORD_IF:
			{
				p.SetState(409)
				p.IfModifier()
			}

		case MojoParserKEYWORD_WHILE:
			{
				p.SetState(410)
				p.WhileModifier()
			}

		case MojoParserEOF, MojoParserRCURLY, MojoParserSEMI, MojoParserEOL:

		default:
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(413)
			p.LoopStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(414)
			p.BranchStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(415)
			p.ControlTransferStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(416)
			p.FloatingStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfModifierContext is an interface to support dynamic dispatch.
type IIfModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_IF() antlr.TerminalNode
	Expression() IExpressionContext

	// IsIfModifierContext differentiates from other interfaces.
	IsIfModifierContext()
}

type IfModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfModifierContext() *IfModifierContext {
	var p = new(IfModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_ifModifier
	return p
}

func InitEmptyIfModifierContext(p *IfModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_ifModifier
}

func (*IfModifierContext) IsIfModifierContext() {}

func NewIfModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfModifierContext {
	var p = new(IfModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_ifModifier

	return p
}

func (s *IfModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IfModifierContext) KEYWORD_IF() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IF, 0)
}

func (s *IfModifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitIfModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) IfModifier() (localctx IIfModifierContext) {
	localctx = NewIfModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MojoParserRULE_ifModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(419)
		p.Match(MojoParserKEYWORD_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(420)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileModifierContext is an interface to support dynamic dispatch.
type IWhileModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_WHILE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWhileModifierContext differentiates from other interfaces.
	IsWhileModifierContext()
}

type WhileModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileModifierContext() *WhileModifierContext {
	var p = new(WhileModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_whileModifier
	return p
}

func InitEmptyWhileModifierContext(p *WhileModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_whileModifier
}

func (*WhileModifierContext) IsWhileModifierContext() {}

func NewWhileModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileModifierContext {
	var p = new(WhileModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_whileModifier

	return p
}

func (s *WhileModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileModifierContext) KEYWORD_WHILE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_WHILE, 0)
}

func (s *WhileModifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitWhileModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) WhileModifier() (localctx IWhileModifierContext) {
	localctx = NewWhileModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MojoParserRULE_whileModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(422)
		p.Match(MojoParserKEYWORD_WHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(423)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloatingStatementContext is an interface to support dynamic dispatch.
type IFloatingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Document() IDocumentContext

	// IsFloatingStatementContext differentiates from other interfaces.
	IsFloatingStatementContext()
}

type FloatingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatingStatementContext() *FloatingStatementContext {
	var p = new(FloatingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_floatingStatement
	return p
}

func InitEmptyFloatingStatementContext(p *FloatingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_floatingStatement
}

func (*FloatingStatementContext) IsFloatingStatementContext() {}

func NewFloatingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatingStatementContext {
	var p = new(FloatingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_floatingStatement

	return p
}

func (s *FloatingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatingStatementContext) Document() IDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDocumentContext)
}

func (s *FloatingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFloatingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FloatingStatement() (localctx IFloatingStatementContext) {
	localctx = NewFloatingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MojoParserRULE_floatingStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(425)
		p.Document()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllEos() []IEosContext
	Eos(i int) IEosContext
	SEMI() antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_statements
	return p
}

func InitEmptyStatementsContext(p *StatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_statements
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *StatementsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(MojoParserSEMI, 0)
}

func (s *StatementsContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *StatementsContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MojoParserRULE_statements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(427)
		p.Statement()
	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(428)
				p.Eos()
			}
			p.SetState(432)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(429)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(434)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(435)
				p.Statement()
			}

		}
		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserSEMI {
		{
			p.SetState(442)
			p.Match(MojoParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForInStatement() IForInStatementContext
	WhileStatement() IWhileStatementContext

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_loopStatement
	return p
}

func InitEmptyLoopStatementContext(p *LoopStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_loopStatement
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) ForInStatement() IForInStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInStatementContext)
}

func (s *LoopStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitLoopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MojoParserRULE_loopStatement)
	p.SetState(447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserKEYWORD_FOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(445)
			p.ForInStatement()
		}

	case MojoParserKEYWORD_WHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(446)
			p.WhileStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInStatementContext is an interface to support dynamic dispatch.
type IForInStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_FOR() antlr.TerminalNode
	Pattern() IPatternContext
	KEYWORD_IN() antlr.TerminalNode
	Expression() IExpressionContext
	CodeBlock() ICodeBlockContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsForInStatementContext differentiates from other interfaces.
	IsForInStatementContext()
}

type ForInStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInStatementContext() *ForInStatementContext {
	var p = new(ForInStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_forInStatement
	return p
}

func InitEmptyForInStatementContext(p *ForInStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_forInStatement
}

func (*ForInStatementContext) IsForInStatementContext() {}

func NewForInStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInStatementContext {
	var p = new(ForInStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_forInStatement

	return p
}

func (s *ForInStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInStatementContext) KEYWORD_FOR() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_FOR, 0)
}

func (s *ForInStatementContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *ForInStatementContext) KEYWORD_IN() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IN, 0)
}

func (s *ForInStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForInStatementContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ForInStatementContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ForInStatementContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ForInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitForInStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ForInStatement() (localctx IForInStatementContext) {
	localctx = NewForInStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MojoParserRULE_forInStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.Match(MojoParserKEYWORD_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(450)
		p.pattern(0)
	}
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(451)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(457)
		p.Match(MojoParserKEYWORD_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(458)
		p.Expression()
	}
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(459)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(465)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_WHILE() antlr.TerminalNode
	Conditions() IConditionsContext
	CodeBlock() ICodeBlockContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) KEYWORD_WHILE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_WHILE, 0)
}

func (s *WhileStatementContext) Conditions() IConditionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionsContext)
}

func (s *WhileStatementContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *WhileStatementContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *WhileStatementContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MojoParserRULE_whileStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)
		p.Match(MojoParserKEYWORD_WHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(468)
		p.Conditions()
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(469)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(475)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionsContext is an interface to support dynamic dispatch.
type IConditionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCondition() []IConditionContext
	Condition(i int) IConditionContext
	AllEov() []IEovContext
	Eov(i int) IEovContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsConditionsContext differentiates from other interfaces.
	IsConditionsContext()
}

type ConditionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionsContext() *ConditionsContext {
	var p = new(ConditionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_conditions
	return p
}

func InitEmptyConditionsContext(p *ConditionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_conditions
}

func (*ConditionsContext) IsConditionsContext() {}

func NewConditionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionsContext {
	var p = new(ConditionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_conditions

	return p
}

func (s *ConditionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionsContext) AllCondition() []IConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConditionContext); ok {
			len++
		}
	}

	tst := make([]IConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConditionContext); ok {
			tst[i] = t.(IConditionContext)
			i++
		}
	}

	return tst
}

func (s *ConditionsContext) Condition(i int) IConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *ConditionsContext) AllEov() []IEovContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovContext); ok {
			len++
		}
	}

	tst := make([]IEovContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovContext); ok {
			tst[i] = t.(IEovContext)
			i++
		}
	}

	return tst
}

func (s *ConditionsContext) Eov(i int) IEovContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovContext)
}

func (s *ConditionsContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ConditionsContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ConditionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitConditions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Conditions() (localctx IConditionsContext) {
	localctx = NewConditionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MojoParserRULE_conditions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(477)
		p.Condition()
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(478)
				p.Eov()
			}
			p.SetState(482)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(479)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(484)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(485)
				p.Condition()
			}

		}
		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	OptionalBindingCondition() IOptionalBindingConditionContext

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_condition
	return p
}

func InitEmptyConditionContext(p *ConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_condition
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionContext) OptionalBindingCondition() IOptionalBindingConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionalBindingConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionalBindingConditionContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MojoParserRULE_condition)
	p.SetState(494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserKEYWORD_AND, MojoParserKEYWORD_AS, MojoParserKEYWORD_ATTRIBUTE, MojoParserKEYWORD_BREAK, MojoParserKEYWORD_CONST, MojoParserKEYWORD_CONTINUE, MojoParserKEYWORD_ELSE, MojoParserKEYWORD_ENUM, MojoParserKEYWORD_FALSE, MojoParserKEYWORD_FUNC, MojoParserKEYWORD_IMPORT, MojoParserKEYWORD_IN, MojoParserKEYWORD_INTERFACE, MojoParserKEYWORD_IS, MojoParserKEYWORD_MATCH, MojoParserKEYWORD_NOT, MojoParserKEYWORD_NULL, MojoParserKEYWORD_OR, MojoParserKEYWORD_PACKAGE, MojoParserKEYWORD_STRUCT, MojoParserKEYWORD_TRUE, MojoParserKEYWORD_TYPE, MojoParserKEYWORD_XOR, MojoParserDOT, MojoParserLCURLY, MojoParserLPAREN, MojoParserLBRACK, MojoParserLT, MojoParserGT, MojoParserBANG, MojoParserQUESTION, MojoParserAND, MojoParserMINUS, MojoParserEQUAL, MojoParserPIPE, MojoParserSLASH, MojoParserPLUS, MojoParserSTAR, MojoParserPERCENT, MojoParserCARET, MojoParserTILDE, MojoParserUNDERSCORE, MojoParserTYPE_IDENTIFIER, MojoParserVALUE_IDENTIFIER, MojoParserOPERATOR_HEAD_OTHER, MojoParserBINARY_LITERAL, MojoParserOCTAL_LITERAL, MojoParserDECIMAL_LITERAL, MojoParserPURE_DECIMAL_DIGITS, MojoParserHEXADECIMAL_LITERAL, MojoParserFLOAT_LITERAL, MojoParserSTATIC_STRING_LITERAL, MojoParserINTERPOLATED_STRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(492)
			p.Expression()
		}

	case MojoParserKEYWORD_VAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(493)
			p.OptionalBindingCondition()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionalBindingConditionContext is an interface to support dynamic dispatch.
type IOptionalBindingConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_VAR() antlr.TerminalNode
	Pattern() IPatternContext
	Initializer() IInitializerContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsOptionalBindingConditionContext differentiates from other interfaces.
	IsOptionalBindingConditionContext()
}

type OptionalBindingConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalBindingConditionContext() *OptionalBindingConditionContext {
	var p = new(OptionalBindingConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_optionalBindingCondition
	return p
}

func InitEmptyOptionalBindingConditionContext(p *OptionalBindingConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_optionalBindingCondition
}

func (*OptionalBindingConditionContext) IsOptionalBindingConditionContext() {}

func NewOptionalBindingConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalBindingConditionContext {
	var p = new(OptionalBindingConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_optionalBindingCondition

	return p
}

func (s *OptionalBindingConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalBindingConditionContext) KEYWORD_VAR() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_VAR, 0)
}

func (s *OptionalBindingConditionContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *OptionalBindingConditionContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *OptionalBindingConditionContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *OptionalBindingConditionContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *OptionalBindingConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalBindingConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalBindingConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitOptionalBindingCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) OptionalBindingCondition() (localctx IOptionalBindingConditionContext) {
	localctx = NewOptionalBindingConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, MojoParserRULE_optionalBindingCondition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		p.Match(MojoParserKEYWORD_VAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(497)
		p.pattern(0)
	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(498)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(503)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(504)
		p.Initializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBranchStatementContext is an interface to support dynamic dispatch.
type IBranchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfStatement() IIfStatementContext
	MatchStatement() IMatchStatementContext

	// IsBranchStatementContext differentiates from other interfaces.
	IsBranchStatementContext()
}

type BranchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBranchStatementContext() *BranchStatementContext {
	var p = new(BranchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_branchStatement
	return p
}

func InitEmptyBranchStatementContext(p *BranchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_branchStatement
}

func (*BranchStatementContext) IsBranchStatementContext() {}

func NewBranchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BranchStatementContext {
	var p = new(BranchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_branchStatement

	return p
}

func (s *BranchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BranchStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *BranchStatementContext) MatchStatement() IMatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchStatementContext)
}

func (s *BranchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BranchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BranchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitBranchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) BranchStatement() (localctx IBranchStatementContext) {
	localctx = NewBranchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MojoParserRULE_branchStatement)
	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserKEYWORD_IF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(506)
			p.IfStatement()
		}

	case MojoParserKEYWORD_MATCH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(507)
			p.MatchStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_IF() antlr.TerminalNode
	Conditions() IConditionsContext
	CodeBlock() ICodeBlockContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	ElseClause() IElseClauseContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) KEYWORD_IF() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IF, 0)
}

func (s *IfStatementContext) Conditions() IConditionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionsContext)
}

func (s *IfStatementContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *IfStatementContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *IfStatementContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *IfStatementContext) ElseClause() IElseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseClauseContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, MojoParserRULE_ifStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)
		p.Match(MojoParserKEYWORD_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(511)
		p.Conditions()
	}
	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(512)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(517)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(518)
		p.CodeBlock()
	}
	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(519)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserKEYWORD_ELSE {
		{
			p.SetState(525)
			p.ElseClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseClauseContext is an interface to support dynamic dispatch.
type IElseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_ELSE() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	IfStatement() IIfStatementContext

	// IsElseClauseContext differentiates from other interfaces.
	IsElseClauseContext()
}

type ElseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseClauseContext() *ElseClauseContext {
	var p = new(ElseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_elseClause
	return p
}

func InitEmptyElseClauseContext(p *ElseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_elseClause
}

func (*ElseClauseContext) IsElseClauseContext() {}

func NewElseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseClauseContext {
	var p = new(ElseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_elseClause

	return p
}

func (s *ElseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseClauseContext) KEYWORD_ELSE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_ELSE, 0)
}

func (s *ElseClauseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ElseClauseContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ElseClauseContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ElseClauseContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *ElseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitElseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ElseClause() (localctx IElseClauseContext) {
	localctx = NewElseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MojoParserRULE_elseClause)
	var _la int

	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(528)
			p.Match(MojoParserKEYWORD_ELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(529)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(534)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(535)
			p.CodeBlock()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(536)
			p.Match(MojoParserKEYWORD_ELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(537)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(542)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(543)
			p.IfStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchStatementContext is an interface to support dynamic dispatch.
type IMatchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_MATCH() antlr.TerminalNode
	Expression() IExpressionContext
	LCURLY() antlr.TerminalNode
	RCURLY() antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	MatchCases() IMatchCasesContext

	// IsMatchStatementContext differentiates from other interfaces.
	IsMatchStatementContext()
}

type MatchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchStatementContext() *MatchStatementContext {
	var p = new(MatchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchStatement
	return p
}

func InitEmptyMatchStatementContext(p *MatchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchStatement
}

func (*MatchStatementContext) IsMatchStatementContext() {}

func NewMatchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchStatementContext {
	var p = new(MatchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_matchStatement

	return p
}

func (s *MatchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchStatementContext) KEYWORD_MATCH() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_MATCH, 0)
}

func (s *MatchStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchStatementContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *MatchStatementContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *MatchStatementContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *MatchStatementContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *MatchStatementContext) MatchCases() IMatchCasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchCasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchCasesContext)
}

func (s *MatchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitMatchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) MatchStatement() (localctx IMatchStatementContext) {
	localctx = NewMatchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MojoParserRULE_matchStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(546)
		p.Match(MojoParserKEYWORD_MATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(547)
		p.Expression()
	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(548)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(554)
		p.Match(MojoParserLCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		p.SetState(558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(555)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(560)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(561)
			p.MatchCases()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(564)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(570)
		p.Match(MojoParserRCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchCasesContext is an interface to support dynamic dispatch.
type IMatchCasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMatchCase() []IMatchCaseContext
	MatchCase(i int) IMatchCaseContext
	AllEos() []IEosContext
	Eos(i int) IEosContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsMatchCasesContext differentiates from other interfaces.
	IsMatchCasesContext()
}

type MatchCasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchCasesContext() *MatchCasesContext {
	var p = new(MatchCasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchCases
	return p
}

func InitEmptyMatchCasesContext(p *MatchCasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchCases
}

func (*MatchCasesContext) IsMatchCasesContext() {}

func NewMatchCasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchCasesContext {
	var p = new(MatchCasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_matchCases

	return p
}

func (s *MatchCasesContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchCasesContext) AllMatchCase() []IMatchCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchCaseContext); ok {
			len++
		}
	}

	tst := make([]IMatchCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchCaseContext); ok {
			tst[i] = t.(IMatchCaseContext)
			i++
		}
	}

	return tst
}

func (s *MatchCasesContext) MatchCase(i int) IMatchCaseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchCaseContext)
}

func (s *MatchCasesContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *MatchCasesContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *MatchCasesContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *MatchCasesContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *MatchCasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchCasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchCasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitMatchCases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) MatchCases() (localctx IMatchCasesContext) {
	localctx = NewMatchCasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MojoParserRULE_matchCases)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.MatchCase()
	}
	p.SetState(584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(573)
				p.Eos()
			}
			p.SetState(577)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(574)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(579)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(580)
				p.MatchCase()
			}

		}
		p.SetState(586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(588)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(587)
			p.Eos()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchCaseContext is an interface to support dynamic dispatch.
type IMatchCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pattern() IPatternContext
	RIGHT_RIGHT_ARROWS() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	Expression() IExpressionContext
	IfModifier() IIfModifierContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsMatchCaseContext differentiates from other interfaces.
	IsMatchCaseContext()
}

type MatchCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchCaseContext() *MatchCaseContext {
	var p = new(MatchCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchCase
	return p
}

func InitEmptyMatchCaseContext(p *MatchCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchCase
}

func (*MatchCaseContext) IsMatchCaseContext() {}

func NewMatchCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchCaseContext {
	var p = new(MatchCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_matchCase

	return p
}

func (s *MatchCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchCaseContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *MatchCaseContext) RIGHT_RIGHT_ARROWS() antlr.TerminalNode {
	return s.GetToken(MojoParserRIGHT_RIGHT_ARROWS, 0)
}

func (s *MatchCaseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *MatchCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchCaseContext) IfModifier() IIfModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfModifierContext)
}

func (s *MatchCaseContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *MatchCaseContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *MatchCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitMatchCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) MatchCase() (localctx IMatchCaseContext) {
	localctx = NewMatchCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MojoParserRULE_matchCase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(590)
		p.pattern(0)
	}
	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserKEYWORD_IF {
		{
			p.SetState(591)
			p.IfModifier()
		}

	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(594)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(600)
		p.Match(MojoParserRIGHT_RIGHT_ARROWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(601)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(607)
			p.CodeBlock()
		}

	case 2:
		{
			p.SetState(608)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IControlTransferStatementContext is an interface to support dynamic dispatch.
type IControlTransferStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BreakStatement() IBreakStatementContext
	ContinueStatement() IContinueStatementContext
	ReturnStatement() IReturnStatementContext

	// IsControlTransferStatementContext differentiates from other interfaces.
	IsControlTransferStatementContext()
}

type ControlTransferStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControlTransferStatementContext() *ControlTransferStatementContext {
	var p = new(ControlTransferStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_controlTransferStatement
	return p
}

func InitEmptyControlTransferStatementContext(p *ControlTransferStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_controlTransferStatement
}

func (*ControlTransferStatementContext) IsControlTransferStatementContext() {}

func NewControlTransferStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ControlTransferStatementContext {
	var p = new(ControlTransferStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_controlTransferStatement

	return p
}

func (s *ControlTransferStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ControlTransferStatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *ControlTransferStatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *ControlTransferStatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *ControlTransferStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ControlTransferStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ControlTransferStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitControlTransferStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ControlTransferStatement() (localctx IControlTransferStatementContext) {
	localctx = NewControlTransferStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MojoParserRULE_controlTransferStatement)
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserKEYWORD_BREAK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(611)
			p.BreakStatement()
		}

	case MojoParserKEYWORD_CONTINUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(612)
			p.ContinueStatement()
		}

	case MojoParserKEYWORD_RETURN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(613)
			p.ReturnStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_BREAK() antlr.TerminalNode

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) KEYWORD_BREAK() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_BREAK, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MojoParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(616)
		p.Match(MojoParserKEYWORD_BREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_CONTINUE() antlr.TerminalNode

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) KEYWORD_CONTINUE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_CONTINUE, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MojoParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Match(MojoParserKEYWORD_CONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_RETURN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) KEYWORD_RETURN() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_RETURN, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MojoParserRULE_returnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(620)
		p.Match(MojoParserKEYWORD_RETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90062655082982398) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&4087) != 0) {
		{
			p.SetState(621)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericParameterClauseContext is an interface to support dynamic dispatch.
type IGenericParameterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GenericParameters() IGenericParametersContext
	GT() antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsGenericParameterClauseContext differentiates from other interfaces.
	IsGenericParameterClauseContext()
}

type GenericParameterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericParameterClauseContext() *GenericParameterClauseContext {
	var p = new(GenericParameterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericParameterClause
	return p
}

func InitEmptyGenericParameterClauseContext(p *GenericParameterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericParameterClause
}

func (*GenericParameterClauseContext) IsGenericParameterClauseContext() {}

func NewGenericParameterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericParameterClauseContext {
	var p = new(GenericParameterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_genericParameterClause

	return p
}

func (s *GenericParameterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericParameterClauseContext) LT() antlr.TerminalNode {
	return s.GetToken(MojoParserLT, 0)
}

func (s *GenericParameterClauseContext) GenericParameters() IGenericParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParametersContext)
}

func (s *GenericParameterClauseContext) GT() antlr.TerminalNode {
	return s.GetToken(MojoParserGT, 0)
}

func (s *GenericParameterClauseContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *GenericParameterClauseContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *GenericParameterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericParameterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericParameterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitGenericParameterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) GenericParameterClause() (localctx IGenericParameterClauseContext) {
	localctx = NewGenericParameterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MojoParserRULE_genericParameterClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(624)
		p.Match(MojoParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(625)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(631)
		p.GenericParameters()
	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(632)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(638)
		p.Match(MojoParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericParametersContext is an interface to support dynamic dispatch.
type IGenericParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericParameter() []IGenericParameterContext
	GenericParameter(i int) IGenericParameterContext
	AllEovWithDocument() []IEovWithDocumentContext
	EovWithDocument(i int) IEovWithDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsGenericParametersContext differentiates from other interfaces.
	IsGenericParametersContext()
}

type GenericParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericParametersContext() *GenericParametersContext {
	var p = new(GenericParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericParameters
	return p
}

func InitEmptyGenericParametersContext(p *GenericParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericParameters
}

func (*GenericParametersContext) IsGenericParametersContext() {}

func NewGenericParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericParametersContext {
	var p = new(GenericParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_genericParameters

	return p
}

func (s *GenericParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericParametersContext) AllGenericParameter() []IGenericParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericParameterContext); ok {
			len++
		}
	}

	tst := make([]IGenericParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericParameterContext); ok {
			tst[i] = t.(IGenericParameterContext)
			i++
		}
	}

	return tst
}

func (s *GenericParametersContext) GenericParameter(i int) IGenericParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParameterContext)
}

func (s *GenericParametersContext) AllEovWithDocument() []IEovWithDocumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovWithDocumentContext); ok {
			len++
		}
	}

	tst := make([]IEovWithDocumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovWithDocumentContext); ok {
			tst[i] = t.(IEovWithDocumentContext)
			i++
		}
	}

	return tst
}

func (s *GenericParametersContext) EovWithDocument(i int) IEovWithDocumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovWithDocumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovWithDocumentContext)
}

func (s *GenericParametersContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *GenericParametersContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *GenericParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitGenericParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) GenericParameters() (localctx IGenericParametersContext) {
	localctx = NewGenericParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MojoParserRULE_genericParameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.GenericParameter()
	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(641)
				p.EovWithDocument()
			}
			p.SetState(645)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(642)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(647)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(648)
				p.GenericParameter()
			}

		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(655)
			p.EovWithDocument()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericParameterContext is an interface to support dynamic dispatch.
type IGenericParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	ELLIPSIS() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext

	// IsGenericParameterContext differentiates from other interfaces.
	IsGenericParameterContext()
}

type GenericParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericParameterContext() *GenericParameterContext {
	var p = new(GenericParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericParameter
	return p
}

func InitEmptyGenericParameterContext(p *GenericParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericParameter
}

func (*GenericParameterContext) IsGenericParameterContext() {}

func NewGenericParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericParameterContext {
	var p = new(GenericParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_genericParameter

	return p
}

func (s *GenericParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericParameterContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *GenericParameterContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(MojoParserELLIPSIS, 0)
}

func (s *GenericParameterContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *GenericParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitGenericParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) GenericParameter() (localctx IGenericParameterContext) {
	localctx = NewGenericParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MojoParserRULE_genericParameter)
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(658)
			p.TypeName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(659)
			p.TypeName()
		}
		{
			p.SetState(660)
			p.Match(MojoParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(662)
			p.TypeName()
		}
		{
			p.SetState(663)
			p.TypeAnnotation()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericArgumentClauseContext is an interface to support dynamic dispatch.
type IGenericArgumentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GenericArguments() IGenericArgumentsContext
	GT() antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsGenericArgumentClauseContext differentiates from other interfaces.
	IsGenericArgumentClauseContext()
}

type GenericArgumentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericArgumentClauseContext() *GenericArgumentClauseContext {
	var p = new(GenericArgumentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericArgumentClause
	return p
}

func InitEmptyGenericArgumentClauseContext(p *GenericArgumentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericArgumentClause
}

func (*GenericArgumentClauseContext) IsGenericArgumentClauseContext() {}

func NewGenericArgumentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericArgumentClauseContext {
	var p = new(GenericArgumentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_genericArgumentClause

	return p
}

func (s *GenericArgumentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericArgumentClauseContext) LT() antlr.TerminalNode {
	return s.GetToken(MojoParserLT, 0)
}

func (s *GenericArgumentClauseContext) GenericArguments() IGenericArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericArgumentsContext)
}

func (s *GenericArgumentClauseContext) GT() antlr.TerminalNode {
	return s.GetToken(MojoParserGT, 0)
}

func (s *GenericArgumentClauseContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *GenericArgumentClauseContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *GenericArgumentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericArgumentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericArgumentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitGenericArgumentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) GenericArgumentClause() (localctx IGenericArgumentClauseContext) {
	localctx = NewGenericArgumentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, MojoParserRULE_genericArgumentClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.Match(MojoParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(668)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(674)
		p.GenericArguments()
	}
	p.SetState(678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(675)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(681)
		p.Match(MojoParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericArgumentsContext is an interface to support dynamic dispatch.
type IGenericArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericArgument() []IGenericArgumentContext
	GenericArgument(i int) IGenericArgumentContext
	AllEov() []IEovContext
	Eov(i int) IEovContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsGenericArgumentsContext differentiates from other interfaces.
	IsGenericArgumentsContext()
}

type GenericArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericArgumentsContext() *GenericArgumentsContext {
	var p = new(GenericArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericArguments
	return p
}

func InitEmptyGenericArgumentsContext(p *GenericArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericArguments
}

func (*GenericArgumentsContext) IsGenericArgumentsContext() {}

func NewGenericArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericArgumentsContext {
	var p = new(GenericArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_genericArguments

	return p
}

func (s *GenericArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericArgumentsContext) AllGenericArgument() []IGenericArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericArgumentContext); ok {
			len++
		}
	}

	tst := make([]IGenericArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericArgumentContext); ok {
			tst[i] = t.(IGenericArgumentContext)
			i++
		}
	}

	return tst
}

func (s *GenericArgumentsContext) GenericArgument(i int) IGenericArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericArgumentContext)
}

func (s *GenericArgumentsContext) AllEov() []IEovContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovContext); ok {
			len++
		}
	}

	tst := make([]IEovContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovContext); ok {
			tst[i] = t.(IEovContext)
			i++
		}
	}

	return tst
}

func (s *GenericArgumentsContext) Eov(i int) IEovContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovContext)
}

func (s *GenericArgumentsContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *GenericArgumentsContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *GenericArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitGenericArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) GenericArguments() (localctx IGenericArgumentsContext) {
	localctx = NewGenericArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, MojoParserRULE_genericArguments)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.GenericArgument()
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(684)
				p.Eov()
			}
			p.SetState(688)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(685)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(690)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(691)
				p.GenericArgument()
			}

		}
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericArgumentContext is an interface to support dynamic dispatch.
type IGenericArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context
	Attributes() IAttributesContext

	// IsGenericArgumentContext differentiates from other interfaces.
	IsGenericArgumentContext()
}

type GenericArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericArgumentContext() *GenericArgumentContext {
	var p = new(GenericArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericArgument
	return p
}

func InitEmptyGenericArgumentContext(p *GenericArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_genericArgument
}

func (*GenericArgumentContext) IsGenericArgumentContext() {}

func NewGenericArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericArgumentContext {
	var p = new(GenericArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_genericArgument

	return p
}

func (s *GenericArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericArgumentContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *GenericArgumentContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *GenericArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitGenericArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) GenericArgument() (localctx IGenericArgumentContext) {
	localctx = NewGenericArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, MojoParserRULE_genericArgument)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.type_(0)
	}
	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserAT {
		{
			p.SetState(699)
			p.Attributes()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PackageDeclaration() IPackageDeclarationContext
	ImportDeclaration() IImportDeclarationContext
	ConstantDeclaration() IConstantDeclarationContext
	VariableDeclaration() IVariableDeclarationContext
	TypeAliasDeclaration() ITypeAliasDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	StructDeclaration() IStructDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	AttributeDeclaration() IAttributeDeclarationContext
	AttributeAliasDeclaration() IAttributeAliasDeclarationContext
	Document() IDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	Attributes() IAttributesContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) PackageDeclaration() IPackageDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageDeclarationContext)
}

func (s *DeclarationContext) ImportDeclaration() IImportDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *DeclarationContext) ConstantDeclaration() IConstantDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDeclarationContext)
}

func (s *DeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *DeclarationContext) TypeAliasDeclaration() ITypeAliasDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasDeclarationContext)
}

func (s *DeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *DeclarationContext) StructDeclaration() IStructDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclarationContext)
}

func (s *DeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *DeclarationContext) AttributeDeclaration() IAttributeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeDeclarationContext)
}

func (s *DeclarationContext) AttributeAliasDeclaration() IAttributeAliasDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeAliasDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeAliasDeclarationContext)
}

func (s *DeclarationContext) Document() IDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDocumentContext)
}

func (s *DeclarationContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *DeclarationContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *DeclarationContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, MojoParserRULE_declaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserLINE_DOCUMENT {
		{
			p.SetState(702)
			p.Document()
		}
		{
			p.SetState(703)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserAT {
		{
			p.SetState(707)
			p.Attributes()
		}
		p.SetState(711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(708)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(713)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(716)
			p.PackageDeclaration()
		}

	case 2:
		{
			p.SetState(717)
			p.ImportDeclaration()
		}

	case 3:
		{
			p.SetState(718)
			p.ConstantDeclaration()
		}

	case 4:
		{
			p.SetState(719)
			p.VariableDeclaration()
		}

	case 5:
		{
			p.SetState(720)
			p.TypeAliasDeclaration()
		}

	case 6:
		{
			p.SetState(721)
			p.FunctionDeclaration()
		}

	case 7:
		{
			p.SetState(722)
			p.EnumDeclaration()
		}

	case 8:
		{
			p.SetState(723)
			p.StructDeclaration()
		}

	case 9:
		{
			p.SetState(724)
			p.InterfaceDeclaration()
		}

	case 10:
		{
			p.SetState(725)
			p.AttributeDeclaration()
		}

	case 11:
		{
			p.SetState(726)
			p.AttributeAliasDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURLY() antlr.TerminalNode
	RCURLY() antlr.TerminalNode
	Statements() IStatementsContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_codeBlock
	return p
}

func InitEmptyCodeBlockContext(p *CodeBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_codeBlock
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *CodeBlockContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *CodeBlockContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *CodeBlockContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *CodeBlockContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitCodeBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) CodeBlock() (localctx ICodeBlockContext) {
	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, MojoParserRULE_codeBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.Match(MojoParserLCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(737)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(730)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(735)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(736)
			p.Statements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(739)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(745)
		p.Match(MojoParserRCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageDeclarationContext is an interface to support dynamic dispatch.
type IPackageDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_PACKAGE() antlr.TerminalNode
	PackageIdentifier() IPackageIdentifierContext
	ObjectLiteral() IObjectLiteralContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsPackageDeclarationContext differentiates from other interfaces.
	IsPackageDeclarationContext()
}

type PackageDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageDeclarationContext() *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_packageDeclaration
	return p
}

func InitEmptyPackageDeclarationContext(p *PackageDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_packageDeclaration
}

func (*PackageDeclarationContext) IsPackageDeclarationContext() {}

func NewPackageDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_packageDeclaration

	return p
}

func (s *PackageDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageDeclarationContext) KEYWORD_PACKAGE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_PACKAGE, 0)
}

func (s *PackageDeclarationContext) PackageIdentifier() IPackageIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageIdentifierContext)
}

func (s *PackageDeclarationContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *PackageDeclarationContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *PackageDeclarationContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *PackageDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPackageDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PackageDeclaration() (localctx IPackageDeclarationContext) {
	localctx = NewPackageDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MojoParserRULE_packageDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(MojoParserKEYWORD_PACKAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(748)
		p.PackageIdentifier()
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(749)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(754)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(755)
			p.ObjectLiteral()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageIdentifierContext is an interface to support dynamic dispatch.
type IPackageIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPackageName() []IPackageNameContext
	PackageName(i int) IPackageNameContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsPackageIdentifierContext differentiates from other interfaces.
	IsPackageIdentifierContext()
}

type PackageIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageIdentifierContext() *PackageIdentifierContext {
	var p = new(PackageIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_packageIdentifier
	return p
}

func InitEmptyPackageIdentifierContext(p *PackageIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_packageIdentifier
}

func (*PackageIdentifierContext) IsPackageIdentifierContext() {}

func NewPackageIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageIdentifierContext {
	var p = new(PackageIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_packageIdentifier

	return p
}

func (s *PackageIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageIdentifierContext) AllPackageName() []IPackageNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPackageNameContext); ok {
			len++
		}
	}

	tst := make([]IPackageNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPackageNameContext); ok {
			tst[i] = t.(IPackageNameContext)
			i++
		}
	}

	return tst
}

func (s *PackageIdentifierContext) PackageName(i int) IPackageNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *PackageIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(MojoParserDOT)
}

func (s *PackageIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, i)
}

func (s *PackageIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPackageIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PackageIdentifier() (localctx IPackageIdentifierContext) {
	localctx = NewPackageIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, MojoParserRULE_packageIdentifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.PackageName()
	}
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(759)
				p.Match(MojoParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(760)
				p.PackageName()
			}

		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageNameContext is an interface to support dynamic dispatch.
type IPackageNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUE_IDENTIFIER() antlr.TerminalNode

	// IsPackageNameContext differentiates from other interfaces.
	IsPackageNameContext()
}

type PackageNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageNameContext() *PackageNameContext {
	var p = new(PackageNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_packageName
	return p
}

func InitEmptyPackageNameContext(p *PackageNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_packageName
}

func (*PackageNameContext) IsPackageNameContext() {}

func NewPackageNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageNameContext {
	var p = new(PackageNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_packageName

	return p
}

func (s *PackageNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageNameContext) VALUE_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MojoParserVALUE_IDENTIFIER, 0)
}

func (s *PackageNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPackageName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PackageName() (localctx IPackageNameContext) {
	localctx = NewPackageNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, MojoParserRULE_packageName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Match(MojoParserVALUE_IDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_IMPORT() antlr.TerminalNode
	ImportPath() IImportPathContext
	ImportAllClause() IImportAllClauseContext
	ImportValueAsClause() IImportValueAsClauseContext
	ImportTypeClause() IImportTypeClauseContext
	ImportGroupClause() IImportGroupClauseContext

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importDeclaration
	return p
}

func InitEmptyImportDeclarationContext(p *ImportDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importDeclaration
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) KEYWORD_IMPORT() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IMPORT, 0)
}

func (s *ImportDeclarationContext) ImportPath() IImportPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPathContext)
}

func (s *ImportDeclarationContext) ImportAllClause() IImportAllClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportAllClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportAllClauseContext)
}

func (s *ImportDeclarationContext) ImportValueAsClause() IImportValueAsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportValueAsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportValueAsClauseContext)
}

func (s *ImportDeclarationContext) ImportTypeClause() IImportTypeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportTypeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportTypeClauseContext)
}

func (s *ImportDeclarationContext) ImportGroupClause() IImportGroupClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportGroupClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportGroupClauseContext)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImportDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImportDeclaration() (localctx IImportDeclarationContext) {
	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MojoParserRULE_importDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.Match(MojoParserKEYWORD_IMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(769)
		p.ImportPath()
	}
	p.SetState(774)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(770)
			p.ImportAllClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(771)
			p.ImportValueAsClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(772)
			p.ImportTypeClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(773)
			p.ImportGroupClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportPathContext is an interface to support dynamic dispatch.
type IImportPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImportPathIdentifier() []IImportPathIdentifierContext
	ImportPathIdentifier(i int) IImportPathIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsImportPathContext differentiates from other interfaces.
	IsImportPathContext()
}

type ImportPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPathContext() *ImportPathContext {
	var p = new(ImportPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importPath
	return p
}

func InitEmptyImportPathContext(p *ImportPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importPath
}

func (*ImportPathContext) IsImportPathContext() {}

func NewImportPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPathContext {
	var p = new(ImportPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_importPath

	return p
}

func (s *ImportPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPathContext) AllImportPathIdentifier() []IImportPathIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportPathIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IImportPathIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportPathIdentifierContext); ok {
			tst[i] = t.(IImportPathIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ImportPathContext) ImportPathIdentifier(i int) IImportPathIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPathIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPathIdentifierContext)
}

func (s *ImportPathContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(MojoParserDOT)
}

func (s *ImportPathContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, i)
}

func (s *ImportPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportPathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImportPath(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImportPath() (localctx IImportPathContext) {
	localctx = NewImportPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, MojoParserRULE_importPath)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(776)
		p.ImportPathIdentifier()
	}
	p.SetState(781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(777)
				p.Match(MojoParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(778)
				p.ImportPathIdentifier()
			}

		}
		p.SetState(783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportPathIdentifierContext is an interface to support dynamic dispatch.
type IImportPathIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DeclarationIdentifier() IDeclarationIdentifierContext

	// IsImportPathIdentifierContext differentiates from other interfaces.
	IsImportPathIdentifierContext()
}

type ImportPathIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPathIdentifierContext() *ImportPathIdentifierContext {
	var p = new(ImportPathIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importPathIdentifier
	return p
}

func InitEmptyImportPathIdentifierContext(p *ImportPathIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importPathIdentifier
}

func (*ImportPathIdentifierContext) IsImportPathIdentifierContext() {}

func NewImportPathIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPathIdentifierContext {
	var p = new(ImportPathIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_importPathIdentifier

	return p
}

func (s *ImportPathIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPathIdentifierContext) DeclarationIdentifier() IDeclarationIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationIdentifierContext)
}

func (s *ImportPathIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPathIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportPathIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImportPathIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImportPathIdentifier() (localctx IImportPathIdentifierContext) {
	localctx = NewImportPathIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, MojoParserRULE_importPathIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.DeclarationIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportAllClauseContext is an interface to support dynamic dispatch.
type IImportAllClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	STAR() antlr.TerminalNode

	// IsImportAllClauseContext differentiates from other interfaces.
	IsImportAllClauseContext()
}

type ImportAllClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportAllClauseContext() *ImportAllClauseContext {
	var p = new(ImportAllClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importAllClause
	return p
}

func InitEmptyImportAllClauseContext(p *ImportAllClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importAllClause
}

func (*ImportAllClauseContext) IsImportAllClauseContext() {}

func NewImportAllClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAllClauseContext {
	var p = new(ImportAllClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_importAllClause

	return p
}

func (s *ImportAllClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAllClauseContext) DOT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, 0)
}

func (s *ImportAllClauseContext) STAR() antlr.TerminalNode {
	return s.GetToken(MojoParserSTAR, 0)
}

func (s *ImportAllClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAllClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAllClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImportAllClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImportAllClause() (localctx IImportAllClauseContext) {
	localctx = NewImportAllClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MojoParserRULE_importAllClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(786)
		p.Match(MojoParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(787)
		p.Match(MojoParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportValueAsClauseContext is an interface to support dynamic dispatch.
type IImportValueAsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_AS() antlr.TerminalNode
	DeclarationIdentifier() IDeclarationIdentifierContext

	// IsImportValueAsClauseContext differentiates from other interfaces.
	IsImportValueAsClauseContext()
}

type ImportValueAsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportValueAsClauseContext() *ImportValueAsClauseContext {
	var p = new(ImportValueAsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importValueAsClause
	return p
}

func InitEmptyImportValueAsClauseContext(p *ImportValueAsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importValueAsClause
}

func (*ImportValueAsClauseContext) IsImportValueAsClauseContext() {}

func NewImportValueAsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportValueAsClauseContext {
	var p = new(ImportValueAsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_importValueAsClause

	return p
}

func (s *ImportValueAsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportValueAsClauseContext) KEYWORD_AS() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_AS, 0)
}

func (s *ImportValueAsClauseContext) DeclarationIdentifier() IDeclarationIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationIdentifierContext)
}

func (s *ImportValueAsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportValueAsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportValueAsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImportValueAsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImportValueAsClause() (localctx IImportValueAsClauseContext) {
	localctx = NewImportValueAsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, MojoParserRULE_importValueAsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(789)
		p.Match(MojoParserKEYWORD_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(790)
		p.DeclarationIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportTypeClauseContext is an interface to support dynamic dispatch.
type IImportTypeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	TypeName() ITypeNameContext
	ImportTypeAsClause() IImportTypeAsClauseContext

	// IsImportTypeClauseContext differentiates from other interfaces.
	IsImportTypeClauseContext()
}

type ImportTypeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportTypeClauseContext() *ImportTypeClauseContext {
	var p = new(ImportTypeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importTypeClause
	return p
}

func InitEmptyImportTypeClauseContext(p *ImportTypeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importTypeClause
}

func (*ImportTypeClauseContext) IsImportTypeClauseContext() {}

func NewImportTypeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportTypeClauseContext {
	var p = new(ImportTypeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_importTypeClause

	return p
}

func (s *ImportTypeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportTypeClauseContext) DOT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, 0)
}

func (s *ImportTypeClauseContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ImportTypeClauseContext) ImportTypeAsClause() IImportTypeAsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportTypeAsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportTypeAsClauseContext)
}

func (s *ImportTypeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportTypeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportTypeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImportTypeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImportTypeClause() (localctx IImportTypeClauseContext) {
	localctx = NewImportTypeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, MojoParserRULE_importTypeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Match(MojoParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(793)
		p.TypeName()
	}
	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserKEYWORD_AS {
		{
			p.SetState(794)
			p.ImportTypeAsClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportTypeAsClauseContext is an interface to support dynamic dispatch.
type IImportTypeAsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_AS() antlr.TerminalNode
	TypeName() ITypeNameContext

	// IsImportTypeAsClauseContext differentiates from other interfaces.
	IsImportTypeAsClauseContext()
}

type ImportTypeAsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportTypeAsClauseContext() *ImportTypeAsClauseContext {
	var p = new(ImportTypeAsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importTypeAsClause
	return p
}

func InitEmptyImportTypeAsClauseContext(p *ImportTypeAsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importTypeAsClause
}

func (*ImportTypeAsClauseContext) IsImportTypeAsClauseContext() {}

func NewImportTypeAsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportTypeAsClauseContext {
	var p = new(ImportTypeAsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_importTypeAsClause

	return p
}

func (s *ImportTypeAsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportTypeAsClauseContext) KEYWORD_AS() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_AS, 0)
}

func (s *ImportTypeAsClauseContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ImportTypeAsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportTypeAsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportTypeAsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImportTypeAsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImportTypeAsClause() (localctx IImportTypeAsClauseContext) {
	localctx = NewImportTypeAsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, MojoParserRULE_importTypeAsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(797)
		p.Match(MojoParserKEYWORD_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(798)
		p.TypeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportGroupClauseContext is an interface to support dynamic dispatch.
type IImportGroupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	LCURLY() antlr.TerminalNode
	ImportGroup() IImportGroupContext
	RCURLY() antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsImportGroupClauseContext differentiates from other interfaces.
	IsImportGroupClauseContext()
}

type ImportGroupClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportGroupClauseContext() *ImportGroupClauseContext {
	var p = new(ImportGroupClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importGroupClause
	return p
}

func InitEmptyImportGroupClauseContext(p *ImportGroupClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importGroupClause
}

func (*ImportGroupClauseContext) IsImportGroupClauseContext() {}

func NewImportGroupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportGroupClauseContext {
	var p = new(ImportGroupClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_importGroupClause

	return p
}

func (s *ImportGroupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportGroupClauseContext) DOT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, 0)
}

func (s *ImportGroupClauseContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *ImportGroupClauseContext) ImportGroup() IImportGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportGroupContext)
}

func (s *ImportGroupClauseContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *ImportGroupClauseContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ImportGroupClauseContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ImportGroupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportGroupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportGroupClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImportGroupClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImportGroupClause() (localctx IImportGroupClauseContext) {
	localctx = NewImportGroupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, MojoParserRULE_importGroupClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(800)
		p.Match(MojoParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(801)
		p.Match(MojoParserLCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(802)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(808)
		p.ImportGroup()
	}
	p.SetState(812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(809)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(815)
		p.Match(MojoParserRCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportGroupContext is an interface to support dynamic dispatch.
type IImportGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImportValue() []IImportValueContext
	ImportValue(i int) IImportValueContext
	AllImportType() []IImportTypeContext
	ImportType(i int) IImportTypeContext
	AllEov() []IEovContext
	Eov(i int) IEovContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsImportGroupContext differentiates from other interfaces.
	IsImportGroupContext()
}

type ImportGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportGroupContext() *ImportGroupContext {
	var p = new(ImportGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importGroup
	return p
}

func InitEmptyImportGroupContext(p *ImportGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importGroup
}

func (*ImportGroupContext) IsImportGroupContext() {}

func NewImportGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportGroupContext {
	var p = new(ImportGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_importGroup

	return p
}

func (s *ImportGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportGroupContext) AllImportValue() []IImportValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportValueContext); ok {
			len++
		}
	}

	tst := make([]IImportValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportValueContext); ok {
			tst[i] = t.(IImportValueContext)
			i++
		}
	}

	return tst
}

func (s *ImportGroupContext) ImportValue(i int) IImportValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportValueContext)
}

func (s *ImportGroupContext) AllImportType() []IImportTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportTypeContext); ok {
			len++
		}
	}

	tst := make([]IImportTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportTypeContext); ok {
			tst[i] = t.(IImportTypeContext)
			i++
		}
	}

	return tst
}

func (s *ImportGroupContext) ImportType(i int) IImportTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportTypeContext)
}

func (s *ImportGroupContext) AllEov() []IEovContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovContext); ok {
			len++
		}
	}

	tst := make([]IEovContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovContext); ok {
			tst[i] = t.(IEovContext)
			i++
		}
	}

	return tst
}

func (s *ImportGroupContext) Eov(i int) IEovContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovContext)
}

func (s *ImportGroupContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ImportGroupContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ImportGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImportGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImportGroup() (localctx IImportGroupContext) {
	localctx = NewImportGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, MojoParserRULE_importGroup)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserKEYWORD_AND, MojoParserKEYWORD_AS, MojoParserKEYWORD_ATTRIBUTE, MojoParserKEYWORD_BREAK, MojoParserKEYWORD_CONST, MojoParserKEYWORD_CONTINUE, MojoParserKEYWORD_ELSE, MojoParserKEYWORD_ENUM, MojoParserKEYWORD_FALSE, MojoParserKEYWORD_FUNC, MojoParserKEYWORD_IMPORT, MojoParserKEYWORD_IN, MojoParserKEYWORD_INTERFACE, MojoParserKEYWORD_IS, MojoParserKEYWORD_MATCH, MojoParserKEYWORD_NOT, MojoParserKEYWORD_NULL, MojoParserKEYWORD_OR, MojoParserKEYWORD_PACKAGE, MojoParserKEYWORD_STRUCT, MojoParserKEYWORD_TRUE, MojoParserKEYWORD_TYPE, MojoParserKEYWORD_XOR, MojoParserVALUE_IDENTIFIER:
		{
			p.SetState(817)
			p.ImportValue()
		}

	case MojoParserTYPE_IDENTIFIER:
		{
			p.SetState(818)
			p.ImportType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(821)
				p.Eov()
			}
			p.SetState(825)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(822)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(827)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(830)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MojoParserKEYWORD_AND, MojoParserKEYWORD_AS, MojoParserKEYWORD_ATTRIBUTE, MojoParserKEYWORD_BREAK, MojoParserKEYWORD_CONST, MojoParserKEYWORD_CONTINUE, MojoParserKEYWORD_ELSE, MojoParserKEYWORD_ENUM, MojoParserKEYWORD_FALSE, MojoParserKEYWORD_FUNC, MojoParserKEYWORD_IMPORT, MojoParserKEYWORD_IN, MojoParserKEYWORD_INTERFACE, MojoParserKEYWORD_IS, MojoParserKEYWORD_MATCH, MojoParserKEYWORD_NOT, MojoParserKEYWORD_NULL, MojoParserKEYWORD_OR, MojoParserKEYWORD_PACKAGE, MojoParserKEYWORD_STRUCT, MojoParserKEYWORD_TRUE, MojoParserKEYWORD_TYPE, MojoParserKEYWORD_XOR, MojoParserVALUE_IDENTIFIER:
				{
					p.SetState(828)
					p.ImportValue()
				}

			case MojoParserTYPE_IDENTIFIER:
				{
					p.SetState(829)
					p.ImportType()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(838)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(837)
			p.Eov()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportValueContext is an interface to support dynamic dispatch.
type IImportValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DeclarationIdentifier() IDeclarationIdentifierContext
	ImportValueAsClause() IImportValueAsClauseContext

	// IsImportValueContext differentiates from other interfaces.
	IsImportValueContext()
}

type ImportValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportValueContext() *ImportValueContext {
	var p = new(ImportValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importValue
	return p
}

func InitEmptyImportValueContext(p *ImportValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importValue
}

func (*ImportValueContext) IsImportValueContext() {}

func NewImportValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportValueContext {
	var p = new(ImportValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_importValue

	return p
}

func (s *ImportValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportValueContext) DeclarationIdentifier() IDeclarationIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationIdentifierContext)
}

func (s *ImportValueContext) ImportValueAsClause() IImportValueAsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportValueAsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportValueAsClauseContext)
}

func (s *ImportValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImportValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImportValue() (localctx IImportValueContext) {
	localctx = NewImportValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, MojoParserRULE_importValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(840)
		p.DeclarationIdentifier()
	}
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserKEYWORD_AS {
		{
			p.SetState(841)
			p.ImportValueAsClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportTypeContext is an interface to support dynamic dispatch.
type IImportTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	ImportTypeAsClause() IImportTypeAsClauseContext

	// IsImportTypeContext differentiates from other interfaces.
	IsImportTypeContext()
}

type ImportTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportTypeContext() *ImportTypeContext {
	var p = new(ImportTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importType
	return p
}

func InitEmptyImportTypeContext(p *ImportTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_importType
}

func (*ImportTypeContext) IsImportTypeContext() {}

func NewImportTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportTypeContext {
	var p = new(ImportTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_importType

	return p
}

func (s *ImportTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportTypeContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ImportTypeContext) ImportTypeAsClause() IImportTypeAsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportTypeAsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportTypeAsClauseContext)
}

func (s *ImportTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImportType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImportType() (localctx IImportTypeContext) {
	localctx = NewImportTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, MojoParserRULE_importType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(844)
		p.TypeName()
	}
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserKEYWORD_AS {
		{
			p.SetState(845)
			p.ImportTypeAsClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDeclarationContext is an interface to support dynamic dispatch.
type IConstantDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_CONST() antlr.TerminalNode
	PatternInitializers() IPatternInitializersContext

	// IsConstantDeclarationContext differentiates from other interfaces.
	IsConstantDeclarationContext()
}

type ConstantDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDeclarationContext() *ConstantDeclarationContext {
	var p = new(ConstantDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_constantDeclaration
	return p
}

func InitEmptyConstantDeclarationContext(p *ConstantDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_constantDeclaration
}

func (*ConstantDeclarationContext) IsConstantDeclarationContext() {}

func NewConstantDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDeclarationContext {
	var p = new(ConstantDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_constantDeclaration

	return p
}

func (s *ConstantDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDeclarationContext) KEYWORD_CONST() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_CONST, 0)
}

func (s *ConstantDeclarationContext) PatternInitializers() IPatternInitializersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternInitializersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternInitializersContext)
}

func (s *ConstantDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitConstantDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ConstantDeclaration() (localctx IConstantDeclarationContext) {
	localctx = NewConstantDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, MojoParserRULE_constantDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)
		p.Match(MojoParserKEYWORD_CONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(849)
		p.PatternInitializers()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternInitializersContext is an interface to support dynamic dispatch.
type IPatternInitializersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPatternInitializer() []IPatternInitializerContext
	PatternInitializer(i int) IPatternInitializerContext
	AllEov() []IEovContext
	Eov(i int) IEovContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	LCURLY() antlr.TerminalNode
	AllDocumentedPatternInitializer() []IDocumentedPatternInitializerContext
	DocumentedPatternInitializer(i int) IDocumentedPatternInitializerContext
	RCURLY() antlr.TerminalNode

	// IsPatternInitializersContext differentiates from other interfaces.
	IsPatternInitializersContext()
}

type PatternInitializersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternInitializersContext() *PatternInitializersContext {
	var p = new(PatternInitializersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_patternInitializers
	return p
}

func InitEmptyPatternInitializersContext(p *PatternInitializersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_patternInitializers
}

func (*PatternInitializersContext) IsPatternInitializersContext() {}

func NewPatternInitializersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternInitializersContext {
	var p = new(PatternInitializersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_patternInitializers

	return p
}

func (s *PatternInitializersContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternInitializersContext) AllPatternInitializer() []IPatternInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPatternInitializerContext); ok {
			len++
		}
	}

	tst := make([]IPatternInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPatternInitializerContext); ok {
			tst[i] = t.(IPatternInitializerContext)
			i++
		}
	}

	return tst
}

func (s *PatternInitializersContext) PatternInitializer(i int) IPatternInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternInitializerContext)
}

func (s *PatternInitializersContext) AllEov() []IEovContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovContext); ok {
			len++
		}
	}

	tst := make([]IEovContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovContext); ok {
			tst[i] = t.(IEovContext)
			i++
		}
	}

	return tst
}

func (s *PatternInitializersContext) Eov(i int) IEovContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovContext)
}

func (s *PatternInitializersContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *PatternInitializersContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *PatternInitializersContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *PatternInitializersContext) AllDocumentedPatternInitializer() []IDocumentedPatternInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDocumentedPatternInitializerContext); ok {
			len++
		}
	}

	tst := make([]IDocumentedPatternInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDocumentedPatternInitializerContext); ok {
			tst[i] = t.(IDocumentedPatternInitializerContext)
			i++
		}
	}

	return tst
}

func (s *PatternInitializersContext) DocumentedPatternInitializer(i int) IDocumentedPatternInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDocumentedPatternInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDocumentedPatternInitializerContext)
}

func (s *PatternInitializersContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *PatternInitializersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternInitializersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternInitializersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPatternInitializers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PatternInitializers() (localctx IPatternInitializersContext) {
	localctx = NewPatternInitializersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, MojoParserRULE_patternInitializers)
	var _la int

	var _alt int

	p.SetState(899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(851)
			p.PatternInitializer()
		}
		p.SetState(863)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(852)
					p.Eov()
				}
				p.SetState(856)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MojoParserEOL {
					{
						p.SetState(853)
						p.Match(MojoParserEOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(858)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(859)
					p.PatternInitializer()
				}

			}
			p.SetState(865)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(866)
			p.Match(MojoParserLCURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(870)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(867)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(872)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(873)
			p.DocumentedPatternInitializer()
		}
		p.SetState(885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(874)
					p.Eov()
				}
				p.SetState(878)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MojoParserEOL {
					{
						p.SetState(875)
						p.Match(MojoParserEOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(880)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(881)
					p.DocumentedPatternInitializer()
				}

			}
			p.SetState(887)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(889)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(888)
				p.Eov()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(891)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(896)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(897)
			p.Match(MojoParserRCURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDocumentedPatternInitializerContext is an interface to support dynamic dispatch.
type IDocumentedPatternInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PatternInitializer() IPatternInitializerContext
	Document() IDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	Attributes() IAttributesContext

	// IsDocumentedPatternInitializerContext differentiates from other interfaces.
	IsDocumentedPatternInitializerContext()
}

type DocumentedPatternInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocumentedPatternInitializerContext() *DocumentedPatternInitializerContext {
	var p = new(DocumentedPatternInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_documentedPatternInitializer
	return p
}

func InitEmptyDocumentedPatternInitializerContext(p *DocumentedPatternInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_documentedPatternInitializer
}

func (*DocumentedPatternInitializerContext) IsDocumentedPatternInitializerContext() {}

func NewDocumentedPatternInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DocumentedPatternInitializerContext {
	var p = new(DocumentedPatternInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_documentedPatternInitializer

	return p
}

func (s *DocumentedPatternInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *DocumentedPatternInitializerContext) PatternInitializer() IPatternInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternInitializerContext)
}

func (s *DocumentedPatternInitializerContext) Document() IDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDocumentContext)
}

func (s *DocumentedPatternInitializerContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *DocumentedPatternInitializerContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *DocumentedPatternInitializerContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *DocumentedPatternInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DocumentedPatternInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DocumentedPatternInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitDocumentedPatternInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) DocumentedPatternInitializer() (localctx IDocumentedPatternInitializerContext) {
	localctx = NewDocumentedPatternInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, MojoParserRULE_documentedPatternInitializer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserLINE_DOCUMENT {
		{
			p.SetState(901)
			p.Document()
		}
		{
			p.SetState(902)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserAT {
		{
			p.SetState(906)
			p.Attributes()
		}
		{
			p.SetState(907)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(911)
		p.PatternInitializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternInitializerContext is an interface to support dynamic dispatch.
type IPatternInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pattern() IPatternContext
	Initializer() IInitializerContext

	// IsPatternInitializerContext differentiates from other interfaces.
	IsPatternInitializerContext()
}

type PatternInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternInitializerContext() *PatternInitializerContext {
	var p = new(PatternInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_patternInitializer
	return p
}

func InitEmptyPatternInitializerContext(p *PatternInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_patternInitializer
}

func (*PatternInitializerContext) IsPatternInitializerContext() {}

func NewPatternInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternInitializerContext {
	var p = new(PatternInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_patternInitializer

	return p
}

func (s *PatternInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternInitializerContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *PatternInitializerContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *PatternInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPatternInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PatternInitializer() (localctx IPatternInitializerContext) {
	localctx = NewPatternInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, MojoParserRULE_patternInitializer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(913)
		p.pattern(0)
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserEQUAL {
		{
			p.SetState(914)
			p.Initializer()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentOperator() IAssignmentOperatorContext
	Expression() IExpressionContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_initializer
	return p
}

func InitEmptyInitializerContext(p *InitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_initializer
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *InitializerContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InitializerContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *InitializerContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Initializer() (localctx IInitializerContext) {
	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, MojoParserRULE_initializer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(917)
		p.AssignmentOperator()
	}
	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(918)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(924)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_VAR() antlr.TerminalNode
	PatternInitializers() IPatternInitializersContext
	IdentifierPattern() IIdentifierPatternContext
	COLON_EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) KEYWORD_VAR() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_VAR, 0)
}

func (s *VariableDeclarationContext) PatternInitializers() IPatternInitializersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternInitializersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternInitializersContext)
}

func (s *VariableDeclarationContext) IdentifierPattern() IIdentifierPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPatternContext)
}

func (s *VariableDeclarationContext) COLON_EQUAL() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON_EQUAL, 0)
}

func (s *VariableDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, MojoParserRULE_variableDeclaration)
	p.SetState(932)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserKEYWORD_VAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(926)
			p.Match(MojoParserKEYWORD_VAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(927)
			p.PatternInitializers()
		}

	case MojoParserKEYWORD_AND, MojoParserKEYWORD_AS, MojoParserKEYWORD_ATTRIBUTE, MojoParserKEYWORD_BREAK, MojoParserKEYWORD_CONST, MojoParserKEYWORD_CONTINUE, MojoParserKEYWORD_ELSE, MojoParserKEYWORD_ENUM, MojoParserKEYWORD_FALSE, MojoParserKEYWORD_FUNC, MojoParserKEYWORD_IMPORT, MojoParserKEYWORD_IN, MojoParserKEYWORD_INTERFACE, MojoParserKEYWORD_IS, MojoParserKEYWORD_MATCH, MojoParserKEYWORD_NOT, MojoParserKEYWORD_NULL, MojoParserKEYWORD_OR, MojoParserKEYWORD_PACKAGE, MojoParserKEYWORD_STRUCT, MojoParserKEYWORD_TRUE, MojoParserKEYWORD_TYPE, MojoParserKEYWORD_XOR, MojoParserVALUE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(928)
			p.IdentifierPattern()
		}
		{
			p.SetState(929)
			p.Match(MojoParserCOLON_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(930)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasDeclarationContext is an interface to support dynamic dispatch.
type ITypeAliasDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_TYPE() antlr.TerminalNode
	TypeAliasName() ITypeAliasNameContext
	TypeAliasAssignment() ITypeAliasAssignmentContext
	GenericParameterClause() IGenericParameterClauseContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsTypeAliasDeclarationContext differentiates from other interfaces.
	IsTypeAliasDeclarationContext()
}

type TypeAliasDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasDeclarationContext() *TypeAliasDeclarationContext {
	var p = new(TypeAliasDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeAliasDeclaration
	return p
}

func InitEmptyTypeAliasDeclarationContext(p *TypeAliasDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeAliasDeclaration
}

func (*TypeAliasDeclarationContext) IsTypeAliasDeclarationContext() {}

func NewTypeAliasDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasDeclarationContext {
	var p = new(TypeAliasDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_typeAliasDeclaration

	return p
}

func (s *TypeAliasDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasDeclarationContext) KEYWORD_TYPE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_TYPE, 0)
}

func (s *TypeAliasDeclarationContext) TypeAliasName() ITypeAliasNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasNameContext)
}

func (s *TypeAliasDeclarationContext) TypeAliasAssignment() ITypeAliasAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasAssignmentContext)
}

func (s *TypeAliasDeclarationContext) GenericParameterClause() IGenericParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParameterClauseContext)
}

func (s *TypeAliasDeclarationContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *TypeAliasDeclarationContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *TypeAliasDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTypeAliasDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TypeAliasDeclaration() (localctx ITypeAliasDeclarationContext) {
	localctx = NewTypeAliasDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, MojoParserRULE_typeAliasDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(934)
		p.Match(MojoParserKEYWORD_TYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(935)
		p.TypeAliasName()
	}
	p.SetState(937)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserLT {
		{
			p.SetState(936)
			p.GenericParameterClause()
		}

	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(939)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(944)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(945)
		p.TypeAliasAssignment()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasNameContext is an interface to support dynamic dispatch.
type ITypeAliasNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext

	// IsTypeAliasNameContext differentiates from other interfaces.
	IsTypeAliasNameContext()
}

type TypeAliasNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasNameContext() *TypeAliasNameContext {
	var p = new(TypeAliasNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeAliasName
	return p
}

func InitEmptyTypeAliasNameContext(p *TypeAliasNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeAliasName
}

func (*TypeAliasNameContext) IsTypeAliasNameContext() {}

func NewTypeAliasNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasNameContext {
	var p = new(TypeAliasNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_typeAliasName

	return p
}

func (s *TypeAliasNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeAliasNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTypeAliasName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TypeAliasName() (localctx ITypeAliasNameContext) {
	localctx = NewTypeAliasNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, MojoParserRULE_typeAliasName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(947)
		p.TypeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasAssignmentContext is an interface to support dynamic dispatch.
type ITypeAliasAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentOperator() IAssignmentOperatorContext
	Type_() IType_Context
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	Attributes() IAttributesContext
	FollowingDocument() IFollowingDocumentContext

	// IsTypeAliasAssignmentContext differentiates from other interfaces.
	IsTypeAliasAssignmentContext()
}

type TypeAliasAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasAssignmentContext() *TypeAliasAssignmentContext {
	var p = new(TypeAliasAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeAliasAssignment
	return p
}

func InitEmptyTypeAliasAssignmentContext(p *TypeAliasAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeAliasAssignment
}

func (*TypeAliasAssignmentContext) IsTypeAliasAssignmentContext() {}

func NewTypeAliasAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasAssignmentContext {
	var p = new(TypeAliasAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_typeAliasAssignment

	return p
}

func (s *TypeAliasAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasAssignmentContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *TypeAliasAssignmentContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeAliasAssignmentContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *TypeAliasAssignmentContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *TypeAliasAssignmentContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *TypeAliasAssignmentContext) FollowingDocument() IFollowingDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *TypeAliasAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTypeAliasAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TypeAliasAssignment() (localctx ITypeAliasAssignmentContext) {
	localctx = NewTypeAliasAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, MojoParserRULE_typeAliasAssignment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(949)
		p.AssignmentOperator()
	}
	p.SetState(953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(950)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(956)
		p.type_(0)
	}
	p.SetState(958)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserAT {
		{
			p.SetState(957)
			p.Attributes()
		}

	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(960)
			p.FollowingDocument()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_FUNC() antlr.TerminalNode
	FunctionName() IFunctionNameContext
	FunctionSignature() IFunctionSignatureContext
	GenericParameterClause() IGenericParameterClauseContext
	FunctionBody() IFunctionBodyContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) KEYWORD_FUNC() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_FUNC, 0)
}

func (s *FunctionDeclarationContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionDeclarationContext) FunctionSignature() IFunctionSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionSignatureContext)
}

func (s *FunctionDeclarationContext) GenericParameterClause() IGenericParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParameterClauseContext)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *FunctionDeclarationContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, MojoParserRULE_functionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(963)
		p.Match(MojoParserKEYWORD_FUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(964)
		p.FunctionName()
	}
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserLT {
		{
			p.SetState(965)
			p.GenericParameterClause()
		}

	}
	{
		p.SetState(968)
		p.FunctionSignature()
	}
	p.SetState(976)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
		p.SetState(972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(969)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(974)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(975)
			p.FunctionBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DeclarationIdentifier() IDeclarationIdentifierContext
	Operator() IOperatorContext

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionName
	return p
}

func InitEmptyFunctionNameContext(p *FunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionName
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) DeclarationIdentifier() IDeclarationIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationIdentifierContext)
}

func (s *FunctionNameContext) Operator() IOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorContext)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, MojoParserRULE_functionName)
	p.SetState(980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserKEYWORD_AND, MojoParserKEYWORD_AS, MojoParserKEYWORD_ATTRIBUTE, MojoParserKEYWORD_BREAK, MojoParserKEYWORD_CONST, MojoParserKEYWORD_CONTINUE, MojoParserKEYWORD_ELSE, MojoParserKEYWORD_ENUM, MojoParserKEYWORD_FALSE, MojoParserKEYWORD_FUNC, MojoParserKEYWORD_IMPORT, MojoParserKEYWORD_IN, MojoParserKEYWORD_INTERFACE, MojoParserKEYWORD_IS, MojoParserKEYWORD_MATCH, MojoParserKEYWORD_NOT, MojoParserKEYWORD_NULL, MojoParserKEYWORD_OR, MojoParserKEYWORD_PACKAGE, MojoParserKEYWORD_STRUCT, MojoParserKEYWORD_TRUE, MojoParserKEYWORD_TYPE, MojoParserKEYWORD_XOR, MojoParserVALUE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(978)
			p.DeclarationIdentifier()
		}

	case MojoParserDOT, MojoParserLT, MojoParserGT, MojoParserBANG, MojoParserQUESTION, MojoParserAND, MojoParserMINUS, MojoParserEQUAL, MojoParserPIPE, MojoParserSLASH, MojoParserPLUS, MojoParserSTAR, MojoParserPERCENT, MojoParserCARET, MojoParserTILDE, MojoParserOPERATOR_HEAD_OTHER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(979)
			p.Operator()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionSignatureContext is an interface to support dynamic dispatch.
type IFunctionSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionParameterClause() IFunctionParameterClauseContext
	FollowingDocument() IFollowingDocumentContext
	FunctionResult() IFunctionResultContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsFunctionSignatureContext differentiates from other interfaces.
	IsFunctionSignatureContext()
}

type FunctionSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionSignatureContext() *FunctionSignatureContext {
	var p = new(FunctionSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionSignature
	return p
}

func InitEmptyFunctionSignatureContext(p *FunctionSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionSignature
}

func (*FunctionSignatureContext) IsFunctionSignatureContext() {}

func NewFunctionSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionSignatureContext {
	var p = new(FunctionSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionSignature

	return p
}

func (s *FunctionSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionSignatureContext) FunctionParameterClause() IFunctionParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterClauseContext)
}

func (s *FunctionSignatureContext) FollowingDocument() IFollowingDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *FunctionSignatureContext) FunctionResult() IFunctionResultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionResultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionResultContext)
}

func (s *FunctionSignatureContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *FunctionSignatureContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *FunctionSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionSignature() (localctx IFunctionSignatureContext) {
	localctx = NewFunctionSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, MojoParserRULE_functionSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(982)
		p.FunctionParameterClause()
	}
	p.SetState(984)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(983)
			p.FollowingDocument()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(993)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		p.SetState(989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(986)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(991)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(992)
			p.FunctionResult()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionResultContext is an interface to support dynamic dispatch.
type IFunctionResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrowOperator() IArrowOperatorContext
	Type_() IType_Context
	LabelIdentifier() ILabelIdentifierContext
	Attributes() IAttributesContext
	FollowingDocument() IFollowingDocumentContext
	COLON() antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsFunctionResultContext differentiates from other interfaces.
	IsFunctionResultContext()
}

type FunctionResultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionResultContext() *FunctionResultContext {
	var p = new(FunctionResultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionResult
	return p
}

func InitEmptyFunctionResultContext(p *FunctionResultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionResult
}

func (*FunctionResultContext) IsFunctionResultContext() {}

func NewFunctionResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionResultContext {
	var p = new(FunctionResultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionResult

	return p
}

func (s *FunctionResultContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionResultContext) ArrowOperator() IArrowOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowOperatorContext)
}

func (s *FunctionResultContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FunctionResultContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *FunctionResultContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *FunctionResultContext) FollowingDocument() IFollowingDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *FunctionResultContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *FunctionResultContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *FunctionResultContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *FunctionResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionResultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionResult(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionResult() (localctx IFunctionResultContext) {
	localctx = NewFunctionResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, MojoParserRULE_functionResult)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		p.ArrowOperator()
	}
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(996)
			p.LabelIdentifier()
		}
		p.SetState(998)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserCOLON {
			{
				p.SetState(997)
				p.Match(MojoParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1002)
		p.type_(0)
	}
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserAT {
		{
			p.SetState(1003)
			p.Attributes()
		}

	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		p.SetState(1009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1006)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1011)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1012)
			p.FollowingDocument()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURLY() antlr.TerminalNode
	RCURLY() antlr.TerminalNode
	FollowingDocument() IFollowingDocumentContext
	Statements() IStatementsContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionBody
	return p
}

func InitEmptyFunctionBodyContext(p *FunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionBody
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *FunctionBodyContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *FunctionBodyContext) FollowingDocument() IFollowingDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *FunctionBodyContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *FunctionBodyContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *FunctionBodyContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, MojoParserRULE_functionBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.Match(MojoParserLCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserFOLLOWING_LINE_DOCUMENT {
		{
			p.SetState(1016)
			p.FollowingDocument()
		}

	}
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		p.SetState(1022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1019)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1024)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1025)
			p.Statements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1028)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1034)
		p.Match(MojoParserRCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionParameterClauseContext is an interface to support dynamic dispatch.
type IFunctionParameterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	FunctionParameters() IFunctionParametersContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsFunctionParameterClauseContext differentiates from other interfaces.
	IsFunctionParameterClauseContext()
}

type FunctionParameterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParameterClauseContext() *FunctionParameterClauseContext {
	var p = new(FunctionParameterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionParameterClause
	return p
}

func InitEmptyFunctionParameterClauseContext(p *FunctionParameterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionParameterClause
}

func (*FunctionParameterClauseContext) IsFunctionParameterClauseContext() {}

func NewFunctionParameterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParameterClauseContext {
	var p = new(FunctionParameterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionParameterClause

	return p
}

func (s *FunctionParameterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParameterClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserLPAREN, 0)
}

func (s *FunctionParameterClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserRPAREN, 0)
}

func (s *FunctionParameterClauseContext) FunctionParameters() IFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParametersContext)
}

func (s *FunctionParameterClauseContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *FunctionParameterClauseContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *FunctionParameterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParameterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionParameterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionParameterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionParameterClause() (localctx IFunctionParameterClauseContext) {
	localctx = NewFunctionParameterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, MojoParserRULE_functionParameterClause)
	var _la int

	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1036)
			p.Match(MojoParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1037)
			p.Match(MojoParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1038)
			p.Match(MojoParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1039)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1044)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1045)
			p.FunctionParameters()
		}
		p.SetState(1049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1046)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1051)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1052)
			p.Match(MojoParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionParametersContext is an interface to support dynamic dispatch.
type IFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionParameter() []IFunctionParameterContext
	FunctionParameter(i int) IFunctionParameterContext
	AllEovWithDocument() []IEovWithDocumentContext
	EovWithDocument(i int) IEovWithDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsFunctionParametersContext differentiates from other interfaces.
	IsFunctionParametersContext()
}

type FunctionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParametersContext() *FunctionParametersContext {
	var p = new(FunctionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionParameters
	return p
}

func InitEmptyFunctionParametersContext(p *FunctionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionParameters
}

func (*FunctionParametersContext) IsFunctionParametersContext() {}

func NewFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParametersContext {
	var p = new(FunctionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionParameters

	return p
}

func (s *FunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParametersContext) AllFunctionParameter() []IFunctionParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			len++
		}
	}

	tst := make([]IFunctionParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionParameterContext); ok {
			tst[i] = t.(IFunctionParameterContext)
			i++
		}
	}

	return tst
}

func (s *FunctionParametersContext) FunctionParameter(i int) IFunctionParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterContext)
}

func (s *FunctionParametersContext) AllEovWithDocument() []IEovWithDocumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovWithDocumentContext); ok {
			len++
		}
	}

	tst := make([]IEovWithDocumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovWithDocumentContext); ok {
			tst[i] = t.(IEovWithDocumentContext)
			i++
		}
	}

	return tst
}

func (s *FunctionParametersContext) EovWithDocument(i int) IEovWithDocumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovWithDocumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovWithDocumentContext)
}

func (s *FunctionParametersContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *FunctionParametersContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *FunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionParameters() (localctx IFunctionParametersContext) {
	localctx = NewFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, MojoParserRULE_functionParameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1056)
		p.FunctionParameter()
	}
	p.SetState(1068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1057)
				p.EovWithDocument()
			}
			p.SetState(1061)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1058)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1063)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1064)
				p.FunctionParameter()
			}

		}
		p.SetState(1070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1071)
			p.EovWithDocument()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionParameterContext is an interface to support dynamic dispatch.
type IFunctionParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelIdentifier() ILabelIdentifierContext
	TypeAnnotation() ITypeAnnotationContext
	Initializer() IInitializerContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	Type_() IType_Context
	ELLIPSIS() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Attributes() IAttributesContext

	// IsFunctionParameterContext differentiates from other interfaces.
	IsFunctionParameterContext()
}

type FunctionParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParameterContext() *FunctionParameterContext {
	var p = new(FunctionParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionParameter
	return p
}

func InitEmptyFunctionParameterContext(p *FunctionParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionParameter
}

func (*FunctionParameterContext) IsFunctionParameterContext() {}

func NewFunctionParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParameterContext {
	var p = new(FunctionParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionParameter

	return p
}

func (s *FunctionParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParameterContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *FunctionParameterContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FunctionParameterContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *FunctionParameterContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *FunctionParameterContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *FunctionParameterContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FunctionParameterContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(MojoParserELLIPSIS, 0)
}

func (s *FunctionParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *FunctionParameterContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *FunctionParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionParameter() (localctx IFunctionParameterContext) {
	localctx = NewFunctionParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, MojoParserRULE_functionParameter)
	var _la int

	p.SetState(1094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1074)
			p.LabelIdentifier()
		}
		{
			p.SetState(1075)
			p.TypeAnnotation()
		}
		p.SetState(1083)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
			p.SetState(1079)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1076)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1081)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1082)
				p.Initializer()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1085)
			p.LabelIdentifier()
		}
		p.SetState(1087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserCOLON {
			{
				p.SetState(1086)
				p.Match(MojoParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1089)
			p.type_(0)
		}
		{
			p.SetState(1090)
			p.Match(MojoParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserAT {
			{
				p.SetState(1091)
				p.Attributes()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_ENUM() antlr.TerminalNode
	EnumName() IEnumNameContext
	EnumBody() IEnumBodyContext
	GenericParameterClause() IGenericParameterClauseContext
	TypeInheritanceClause() ITypeInheritanceClauseContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_enumDeclaration
	return p
}

func InitEmptyEnumDeclarationContext(p *EnumDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_enumDeclaration
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) KEYWORD_ENUM() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_ENUM, 0)
}

func (s *EnumDeclarationContext) EnumName() IEnumNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumNameContext)
}

func (s *EnumDeclarationContext) EnumBody() IEnumBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodyContext)
}

func (s *EnumDeclarationContext) GenericParameterClause() IGenericParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParameterClauseContext)
}

func (s *EnumDeclarationContext) TypeInheritanceClause() ITypeInheritanceClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeInheritanceClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeInheritanceClauseContext)
}

func (s *EnumDeclarationContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *EnumDeclarationContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitEnumDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, MojoParserRULE_enumDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1096)
		p.Match(MojoParserKEYWORD_ENUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1097)
		p.EnumName()
	}
	p.SetState(1099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserLT {
		{
			p.SetState(1098)
			p.GenericParameterClause()
		}

	}
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
		p.SetState(1104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1101)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1106)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1107)
			p.TypeInheritanceClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1110)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1116)
		p.EnumBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumBodyContext is an interface to support dynamic dispatch.
type IEnumBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURLY() antlr.TerminalNode
	RCURLY() antlr.TerminalNode
	FollowingDocument() IFollowingDocumentContext
	EnumMembers() IEnumMembersContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsEnumBodyContext differentiates from other interfaces.
	IsEnumBodyContext()
}

type EnumBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyContext() *EnumBodyContext {
	var p = new(EnumBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_enumBody
	return p
}

func InitEmptyEnumBodyContext(p *EnumBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_enumBody
}

func (*EnumBodyContext) IsEnumBodyContext() {}

func NewEnumBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyContext {
	var p = new(EnumBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_enumBody

	return p
}

func (s *EnumBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *EnumBodyContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *EnumBodyContext) FollowingDocument() IFollowingDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *EnumBodyContext) EnumMembers() IEnumMembersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMembersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMembersContext)
}

func (s *EnumBodyContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *EnumBodyContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *EnumBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitEnumBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) EnumBody() (localctx IEnumBodyContext) {
	localctx = NewEnumBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, MojoParserRULE_enumBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1118)
		p.Match(MojoParserLCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1120)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserFOLLOWING_LINE_DOCUMENT {
		{
			p.SetState(1119)
			p.FollowingDocument()
		}

	}
	p.SetState(1129)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		p.SetState(1125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1122)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1127)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1128)
			p.EnumMembers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1131)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1136)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1137)
		p.Match(MojoParserRCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumNameContext is an interface to support dynamic dispatch.
type IEnumNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext

	// IsEnumNameContext differentiates from other interfaces.
	IsEnumNameContext()
}

type EnumNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumNameContext() *EnumNameContext {
	var p = new(EnumNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_enumName
	return p
}

func InitEmptyEnumNameContext(p *EnumNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_enumName
}

func (*EnumNameContext) IsEnumNameContext() {}

func NewEnumNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumNameContext {
	var p = new(EnumNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_enumName

	return p
}

func (s *EnumNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *EnumNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitEnumName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) EnumName() (localctx IEnumNameContext) {
	localctx = NewEnumNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, MojoParserRULE_enumName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1139)
		p.TypeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumMembersContext is an interface to support dynamic dispatch.
type IEnumMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumMember() []IEnumMemberContext
	EnumMember(i int) IEnumMemberContext
	AllEovWithDocument() []IEovWithDocumentContext
	EovWithDocument(i int) IEovWithDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsEnumMembersContext differentiates from other interfaces.
	IsEnumMembersContext()
}

type EnumMembersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMembersContext() *EnumMembersContext {
	var p = new(EnumMembersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_enumMembers
	return p
}

func InitEmptyEnumMembersContext(p *EnumMembersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_enumMembers
}

func (*EnumMembersContext) IsEnumMembersContext() {}

func NewEnumMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMembersContext {
	var p = new(EnumMembersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_enumMembers

	return p
}

func (s *EnumMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMembersContext) AllEnumMember() []IEnumMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumMemberContext); ok {
			len++
		}
	}

	tst := make([]IEnumMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumMemberContext); ok {
			tst[i] = t.(IEnumMemberContext)
			i++
		}
	}

	return tst
}

func (s *EnumMembersContext) EnumMember(i int) IEnumMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMemberContext)
}

func (s *EnumMembersContext) AllEovWithDocument() []IEovWithDocumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovWithDocumentContext); ok {
			len++
		}
	}

	tst := make([]IEovWithDocumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovWithDocumentContext); ok {
			tst[i] = t.(IEovWithDocumentContext)
			i++
		}
	}

	return tst
}

func (s *EnumMembersContext) EovWithDocument(i int) IEovWithDocumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovWithDocumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovWithDocumentContext)
}

func (s *EnumMembersContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *EnumMembersContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *EnumMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMembersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitEnumMembers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) EnumMembers() (localctx IEnumMembersContext) {
	localctx = NewEnumMembersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, MojoParserRULE_enumMembers)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1141)
		p.EnumMember()
	}
	p.SetState(1153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1142)
				p.EovWithDocument()
			}
			p.SetState(1146)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1143)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1148)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1149)
				p.EnumMember()
			}

		}
		p.SetState(1155)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1156)
			p.EovWithDocument()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumMemberContext is an interface to support dynamic dispatch.
type IEnumMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DeclarationIdentifier() IDeclarationIdentifierContext
	Document() IDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	AllAttributes() []IAttributesContext
	Attributes(i int) IAttributesContext
	Initializer() IInitializerContext
	FloatingStatement() IFloatingStatementContext

	// IsEnumMemberContext differentiates from other interfaces.
	IsEnumMemberContext()
}

type EnumMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMemberContext() *EnumMemberContext {
	var p = new(EnumMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_enumMember
	return p
}

func InitEmptyEnumMemberContext(p *EnumMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_enumMember
}

func (*EnumMemberContext) IsEnumMemberContext() {}

func NewEnumMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMemberContext {
	var p = new(EnumMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_enumMember

	return p
}

func (s *EnumMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMemberContext) DeclarationIdentifier() IDeclarationIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationIdentifierContext)
}

func (s *EnumMemberContext) Document() IDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDocumentContext)
}

func (s *EnumMemberContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *EnumMemberContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *EnumMemberContext) AllAttributes() []IAttributesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributesContext); ok {
			len++
		}
	}

	tst := make([]IAttributesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributesContext); ok {
			tst[i] = t.(IAttributesContext)
			i++
		}
	}

	return tst
}

func (s *EnumMemberContext) Attributes(i int) IAttributesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *EnumMemberContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *EnumMemberContext) FloatingStatement() IFloatingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatingStatementContext)
}

func (s *EnumMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitEnumMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) EnumMember() (localctx IEnumMemberContext) {
	localctx = NewEnumMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, MojoParserRULE_enumMember)
	var _la int

	p.SetState(1183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserLINE_DOCUMENT {
			{
				p.SetState(1159)
				p.Document()
			}
			{
				p.SetState(1160)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserAT {
			{
				p.SetState(1164)
				p.Attributes()
			}
			{
				p.SetState(1165)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1169)
			p.DeclarationIdentifier()
		}
		p.SetState(1171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserAT {
			{
				p.SetState(1170)
				p.Attributes()
			}

		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			p.SetState(1176)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1173)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1178)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1179)
				p.Initializer()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1182)
			p.FloatingStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructDeclarationContext is an interface to support dynamic dispatch.
type IStructDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_TYPE() antlr.TerminalNode
	StructName() IStructNameContext
	StructType() IStructTypeContext
	GenericParameterClause() IGenericParameterClauseContext

	// IsStructDeclarationContext differentiates from other interfaces.
	IsStructDeclarationContext()
}

type StructDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDeclarationContext() *StructDeclarationContext {
	var p = new(StructDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structDeclaration
	return p
}

func InitEmptyStructDeclarationContext(p *StructDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structDeclaration
}

func (*StructDeclarationContext) IsStructDeclarationContext() {}

func NewStructDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDeclarationContext {
	var p = new(StructDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_structDeclaration

	return p
}

func (s *StructDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDeclarationContext) KEYWORD_TYPE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_TYPE, 0)
}

func (s *StructDeclarationContext) StructName() IStructNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructNameContext)
}

func (s *StructDeclarationContext) StructType() IStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *StructDeclarationContext) GenericParameterClause() IGenericParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParameterClauseContext)
}

func (s *StructDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStructDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) StructDeclaration() (localctx IStructDeclarationContext) {
	localctx = NewStructDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, MojoParserRULE_structDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1185)
		p.Match(MojoParserKEYWORD_TYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1186)
		p.StructName()
	}
	p.SetState(1188)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserLT {
		{
			p.SetState(1187)
			p.GenericParameterClause()
		}

	}
	{
		p.SetState(1190)
		p.StructType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructNameContext is an interface to support dynamic dispatch.
type IStructNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext

	// IsStructNameContext differentiates from other interfaces.
	IsStructNameContext()
}

type StructNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructNameContext() *StructNameContext {
	var p = new(StructNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structName
	return p
}

func InitEmptyStructNameContext(p *StructNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structName
}

func (*StructNameContext) IsStructNameContext() {}

func NewStructNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructNameContext {
	var p = new(StructNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_structName

	return p
}

func (s *StructNameContext) GetParser() antlr.Parser { return s.parser }

func (s *StructNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *StructNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStructName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) StructName() (localctx IStructNameContext) {
	localctx = NewStructNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, MojoParserRULE_structName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1192)
		p.TypeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructTypeContext is an interface to support dynamic dispatch.
type IStructTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeInheritanceClause() ITypeInheritanceClauseContext
	StructBody() IStructBodyContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsStructTypeContext differentiates from other interfaces.
	IsStructTypeContext()
}

type StructTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructTypeContext() *StructTypeContext {
	var p = new(StructTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structType
	return p
}

func InitEmptyStructTypeContext(p *StructTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structType
}

func (*StructTypeContext) IsStructTypeContext() {}

func NewStructTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructTypeContext {
	var p = new(StructTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_structType

	return p
}

func (s *StructTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructTypeContext) TypeInheritanceClause() ITypeInheritanceClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeInheritanceClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeInheritanceClauseContext)
}

func (s *StructTypeContext) StructBody() IStructBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructBodyContext)
}

func (s *StructTypeContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *StructTypeContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *StructTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStructType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) StructType() (localctx IStructTypeContext) {
	localctx = NewStructTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, MojoParserRULE_structType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1201)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
		p.SetState(1197)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1194)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1199)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1200)
			p.TypeInheritanceClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1210)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1203)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1208)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1209)
			p.StructBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructBodyContext is an interface to support dynamic dispatch.
type IStructBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURLY() antlr.TerminalNode
	RCURLY() antlr.TerminalNode
	FollowingDocument() IFollowingDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	StructMembers() IStructMembersContext

	// IsStructBodyContext differentiates from other interfaces.
	IsStructBodyContext()
}

type StructBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructBodyContext() *StructBodyContext {
	var p = new(StructBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structBody
	return p
}

func InitEmptyStructBodyContext(p *StructBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structBody
}

func (*StructBodyContext) IsStructBodyContext() {}

func NewStructBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructBodyContext {
	var p = new(StructBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_structBody

	return p
}

func (s *StructBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *StructBodyContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *StructBodyContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *StructBodyContext) FollowingDocument() IFollowingDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *StructBodyContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *StructBodyContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *StructBodyContext) StructMembers() IStructMembersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructMembersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructMembersContext)
}

func (s *StructBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStructBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) StructBody() (localctx IStructBodyContext) {
	localctx = NewStructBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, MojoParserRULE_structBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1212)
		p.Match(MojoParserLCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserFOLLOWING_LINE_DOCUMENT {
		{
			p.SetState(1213)
			p.FollowingDocument()
		}
		{
			p.SetState(1214)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1225)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
		p.SetState(1221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1218)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1223)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1224)
			p.StructMembers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1227)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1232)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1233)
		p.Match(MojoParserRCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructMembersContext is an interface to support dynamic dispatch.
type IStructMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStructMember() []IStructMemberContext
	StructMember(i int) IStructMemberContext
	AllEosWithDocument() []IEosWithDocumentContext
	EosWithDocument(i int) IEosWithDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsStructMembersContext differentiates from other interfaces.
	IsStructMembersContext()
}

type StructMembersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructMembersContext() *StructMembersContext {
	var p = new(StructMembersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structMembers
	return p
}

func InitEmptyStructMembersContext(p *StructMembersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structMembers
}

func (*StructMembersContext) IsStructMembersContext() {}

func NewStructMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructMembersContext {
	var p = new(StructMembersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_structMembers

	return p
}

func (s *StructMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *StructMembersContext) AllStructMember() []IStructMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructMemberContext); ok {
			len++
		}
	}

	tst := make([]IStructMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructMemberContext); ok {
			tst[i] = t.(IStructMemberContext)
			i++
		}
	}

	return tst
}

func (s *StructMembersContext) StructMember(i int) IStructMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructMemberContext)
}

func (s *StructMembersContext) AllEosWithDocument() []IEosWithDocumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosWithDocumentContext); ok {
			len++
		}
	}

	tst := make([]IEosWithDocumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosWithDocumentContext); ok {
			tst[i] = t.(IEosWithDocumentContext)
			i++
		}
	}

	return tst
}

func (s *StructMembersContext) EosWithDocument(i int) IEosWithDocumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosWithDocumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosWithDocumentContext)
}

func (s *StructMembersContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *StructMembersContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *StructMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructMembersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStructMembers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) StructMembers() (localctx IStructMembersContext) {
	localctx = NewStructMembersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, MojoParserRULE_structMembers)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1235)
		p.StructMember()
	}
	p.SetState(1247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1236)
				p.EosWithDocument()
			}
			p.SetState(1240)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1237)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1242)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1243)
				p.StructMember()
			}

		}
		p.SetState(1249)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1250)
			p.EosWithDocument()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructMemberContext is an interface to support dynamic dispatch.
type IStructMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StructDeclaration() IStructDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	ConstantDeclaration() IConstantDeclarationContext
	TypeAliasDeclaration() ITypeAliasDeclarationContext
	StructMemberDeclaration() IStructMemberDeclarationContext
	Document() IDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	Attributes() IAttributesContext
	FloatingStatement() IFloatingStatementContext

	// IsStructMemberContext differentiates from other interfaces.
	IsStructMemberContext()
}

type StructMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructMemberContext() *StructMemberContext {
	var p = new(StructMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structMember
	return p
}

func InitEmptyStructMemberContext(p *StructMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structMember
}

func (*StructMemberContext) IsStructMemberContext() {}

func NewStructMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructMemberContext {
	var p = new(StructMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_structMember

	return p
}

func (s *StructMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *StructMemberContext) StructDeclaration() IStructDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclarationContext)
}

func (s *StructMemberContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *StructMemberContext) ConstantDeclaration() IConstantDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDeclarationContext)
}

func (s *StructMemberContext) TypeAliasDeclaration() ITypeAliasDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasDeclarationContext)
}

func (s *StructMemberContext) StructMemberDeclaration() IStructMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructMemberDeclarationContext)
}

func (s *StructMemberContext) Document() IDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDocumentContext)
}

func (s *StructMemberContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *StructMemberContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *StructMemberContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *StructMemberContext) FloatingStatement() IFloatingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatingStatementContext)
}

func (s *StructMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStructMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) StructMember() (localctx IStructMemberContext) {
	localctx = NewStructMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, MojoParserRULE_structMember)
	var _la int

	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserLINE_DOCUMENT {
			{
				p.SetState(1253)
				p.Document()
			}
			{
				p.SetState(1254)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserAT {
			{
				p.SetState(1258)
				p.Attributes()
			}
			{
				p.SetState(1259)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1263)
				p.StructDeclaration()
			}

		case 2:
			{
				p.SetState(1264)
				p.EnumDeclaration()
			}

		case 3:
			{
				p.SetState(1265)
				p.ConstantDeclaration()
			}

		case 4:
			{
				p.SetState(1266)
				p.TypeAliasDeclaration()
			}

		case 5:
			{
				p.SetState(1267)
				p.StructMemberDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1270)
			p.FloatingStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructMemberDeclarationContext is an interface to support dynamic dispatch.
type IStructMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DeclarationIdentifier() IDeclarationIdentifierContext
	TypeAnnotation() ITypeAnnotationContext
	Initializer() IInitializerContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsStructMemberDeclarationContext differentiates from other interfaces.
	IsStructMemberDeclarationContext()
}

type StructMemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructMemberDeclarationContext() *StructMemberDeclarationContext {
	var p = new(StructMemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structMemberDeclaration
	return p
}

func InitEmptyStructMemberDeclarationContext(p *StructMemberDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structMemberDeclaration
}

func (*StructMemberDeclarationContext) IsStructMemberDeclarationContext() {}

func NewStructMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructMemberDeclarationContext {
	var p = new(StructMemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_structMemberDeclaration

	return p
}

func (s *StructMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StructMemberDeclarationContext) DeclarationIdentifier() IDeclarationIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationIdentifierContext)
}

func (s *StructMemberDeclarationContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *StructMemberDeclarationContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *StructMemberDeclarationContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *StructMemberDeclarationContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *StructMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructMemberDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStructMemberDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) StructMemberDeclaration() (localctx IStructMemberDeclarationContext) {
	localctx = NewStructMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, MojoParserRULE_structMemberDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1273)
		p.DeclarationIdentifier()
	}
	{
		p.SetState(1274)
		p.TypeAnnotation()
	}
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) == 1 {
		p.SetState(1278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1275)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1280)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1281)
			p.Initializer()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_INTERFACE() antlr.TerminalNode
	InterfaceName() IInterfaceNameContext
	InterfaceType() IInterfaceTypeContext
	GenericParameterClause() IGenericParameterClauseContext

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) KEYWORD_INTERFACE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_INTERFACE, 0)
}

func (s *InterfaceDeclarationContext) InterfaceName() IInterfaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceNameContext)
}

func (s *InterfaceDeclarationContext) InterfaceType() IInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeContext)
}

func (s *InterfaceDeclarationContext) GenericParameterClause() IGenericParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParameterClauseContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitInterfaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, MojoParserRULE_interfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1284)
		p.Match(MojoParserKEYWORD_INTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1285)
		p.InterfaceName()
	}
	p.SetState(1287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserLT {
		{
			p.SetState(1286)
			p.GenericParameterClause()
		}

	}
	{
		p.SetState(1289)
		p.InterfaceType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceNameContext is an interface to support dynamic dispatch.
type IInterfaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext

	// IsInterfaceNameContext differentiates from other interfaces.
	IsInterfaceNameContext()
}

type InterfaceNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceNameContext() *InterfaceNameContext {
	var p = new(InterfaceNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceName
	return p
}

func InitEmptyInterfaceNameContext(p *InterfaceNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceName
}

func (*InterfaceNameContext) IsInterfaceNameContext() {}

func NewInterfaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceNameContext {
	var p = new(InterfaceNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_interfaceName

	return p
}

func (s *InterfaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceNameContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *InterfaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitInterfaceName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) InterfaceName() (localctx IInterfaceNameContext) {
	localctx = NewInterfaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, MojoParserRULE_interfaceName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1291)
		p.TypeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceTypeContext is an interface to support dynamic dispatch.
type IInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InterfaceBody() IInterfaceBodyContext
	TypeInheritanceClause() ITypeInheritanceClauseContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsInterfaceTypeContext differentiates from other interfaces.
	IsInterfaceTypeContext()
}

type InterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeContext() *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceType
	return p
}

func InitEmptyInterfaceTypeContext(p *InterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceType
}

func (*InterfaceTypeContext) IsInterfaceTypeContext() {}

func NewInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_interfaceType

	return p
}

func (s *InterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeContext) InterfaceBody() IInterfaceBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyContext)
}

func (s *InterfaceTypeContext) TypeInheritanceClause() ITypeInheritanceClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeInheritanceClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeInheritanceClauseContext)
}

func (s *InterfaceTypeContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *InterfaceTypeContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *InterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) InterfaceType() (localctx IInterfaceTypeContext) {
	localctx = NewInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, MojoParserRULE_interfaceType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1300)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		p.SetState(1296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1293)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1298)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1299)
			p.TypeInheritanceClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1302)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1308)
		p.InterfaceBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBodyContext is an interface to support dynamic dispatch.
type IInterfaceBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURLY() antlr.TerminalNode
	RCURLY() antlr.TerminalNode
	FollowingDocument() IFollowingDocumentContext
	InterfaceMembers() IInterfaceMembersContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsInterfaceBodyContext differentiates from other interfaces.
	IsInterfaceBodyContext()
}

type InterfaceBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyContext() *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceBody
	return p
}

func InitEmptyInterfaceBodyContext(p *InterfaceBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceBody
}

func (*InterfaceBodyContext) IsInterfaceBodyContext() {}

func NewInterfaceBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_interfaceBody

	return p
}

func (s *InterfaceBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *InterfaceBodyContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *InterfaceBodyContext) FollowingDocument() IFollowingDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *InterfaceBodyContext) InterfaceMembers() IInterfaceMembersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMembersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMembersContext)
}

func (s *InterfaceBodyContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *InterfaceBodyContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *InterfaceBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitInterfaceBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) InterfaceBody() (localctx IInterfaceBodyContext) {
	localctx = NewInterfaceBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, MojoParserRULE_interfaceBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1310)
		p.Match(MojoParserLCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1312)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserFOLLOWING_LINE_DOCUMENT {
		{
			p.SetState(1311)
			p.FollowingDocument()
		}

	}
	p.SetState(1321)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
		p.SetState(1317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1314)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1319)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1320)
			p.InterfaceMembers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1323)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1328)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1329)
		p.Match(MojoParserRCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMembersContext is an interface to support dynamic dispatch.
type IInterfaceMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInterfaceMember() []IInterfaceMemberContext
	InterfaceMember(i int) IInterfaceMemberContext
	AllEosWithDocument() []IEosWithDocumentContext
	EosWithDocument(i int) IEosWithDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsInterfaceMembersContext differentiates from other interfaces.
	IsInterfaceMembersContext()
}

type InterfaceMembersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMembersContext() *InterfaceMembersContext {
	var p = new(InterfaceMembersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceMembers
	return p
}

func InitEmptyInterfaceMembersContext(p *InterfaceMembersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceMembers
}

func (*InterfaceMembersContext) IsInterfaceMembersContext() {}

func NewInterfaceMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMembersContext {
	var p = new(InterfaceMembersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_interfaceMembers

	return p
}

func (s *InterfaceMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMembersContext) AllInterfaceMember() []IInterfaceMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMemberContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMemberContext); ok {
			tst[i] = t.(IInterfaceMemberContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceMembersContext) InterfaceMember(i int) IInterfaceMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMemberContext)
}

func (s *InterfaceMembersContext) AllEosWithDocument() []IEosWithDocumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosWithDocumentContext); ok {
			len++
		}
	}

	tst := make([]IEosWithDocumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosWithDocumentContext); ok {
			tst[i] = t.(IEosWithDocumentContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceMembersContext) EosWithDocument(i int) IEosWithDocumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosWithDocumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosWithDocumentContext)
}

func (s *InterfaceMembersContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *InterfaceMembersContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *InterfaceMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMembersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitInterfaceMembers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) InterfaceMembers() (localctx IInterfaceMembersContext) {
	localctx = NewInterfaceMembersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, MojoParserRULE_interfaceMembers)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1331)
		p.InterfaceMember()
	}
	p.SetState(1343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1332)
				p.EosWithDocument()
			}
			p.SetState(1336)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1333)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1338)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1339)
				p.InterfaceMember()
			}

		}
		p.SetState(1345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1347)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1346)
			p.EosWithDocument()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMemberContext is an interface to support dynamic dispatch.
type IInterfaceMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeAliasDeclaration() ITypeAliasDeclarationContext
	InterfaceMethodDeclaration() IInterfaceMethodDeclarationContext
	Document() IDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	Attributes() IAttributesContext
	FloatingStatement() IFloatingStatementContext

	// IsInterfaceMemberContext differentiates from other interfaces.
	IsInterfaceMemberContext()
}

type InterfaceMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMemberContext() *InterfaceMemberContext {
	var p = new(InterfaceMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceMember
	return p
}

func InitEmptyInterfaceMemberContext(p *InterfaceMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceMember
}

func (*InterfaceMemberContext) IsInterfaceMemberContext() {}

func NewInterfaceMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMemberContext {
	var p = new(InterfaceMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_interfaceMember

	return p
}

func (s *InterfaceMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMemberContext) TypeAliasDeclaration() ITypeAliasDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasDeclarationContext)
}

func (s *InterfaceMemberContext) InterfaceMethodDeclaration() IInterfaceMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodDeclarationContext)
}

func (s *InterfaceMemberContext) Document() IDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDocumentContext)
}

func (s *InterfaceMemberContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *InterfaceMemberContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *InterfaceMemberContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *InterfaceMemberContext) FloatingStatement() IFloatingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatingStatementContext)
}

func (s *InterfaceMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitInterfaceMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) InterfaceMember() (localctx IInterfaceMemberContext) {
	localctx = NewInterfaceMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, MojoParserRULE_interfaceMember)
	var _la int

	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserLINE_DOCUMENT {
			{
				p.SetState(1349)
				p.Document()
			}
			{
				p.SetState(1350)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserAT {
			{
				p.SetState(1354)
				p.Attributes()
			}
			{
				p.SetState(1355)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1359)
				p.TypeAliasDeclaration()
			}

		case 2:
			{
				p.SetState(1360)
				p.InterfaceMethodDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1363)
			p.FloatingStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionName() IFunctionNameContext
	FunctionSignature() IFunctionSignatureContext
	GenericParameterClause() IGenericParameterClauseContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsInterfaceMethodDeclarationContext differentiates from other interfaces.
	IsInterfaceMethodDeclarationContext()
}

type InterfaceMethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodDeclarationContext() *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceMethodDeclaration
	return p
}

func InitEmptyInterfaceMethodDeclarationContext(p *InterfaceMethodDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_interfaceMethodDeclaration
}

func (*InterfaceMethodDeclarationContext) IsInterfaceMethodDeclarationContext() {}

func NewInterfaceMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_interfaceMethodDeclaration

	return p
}

func (s *InterfaceMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodDeclarationContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *InterfaceMethodDeclarationContext) FunctionSignature() IFunctionSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionSignatureContext)
}

func (s *InterfaceMethodDeclarationContext) GenericParameterClause() IGenericParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParameterClauseContext)
}

func (s *InterfaceMethodDeclarationContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *InterfaceMethodDeclarationContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *InterfaceMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitInterfaceMethodDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) InterfaceMethodDeclaration() (localctx IInterfaceMethodDeclarationContext) {
	localctx = NewInterfaceMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, MojoParserRULE_interfaceMethodDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1366)
		p.FunctionName()
	}
	p.SetState(1368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserLT {
		{
			p.SetState(1367)
			p.GenericParameterClause()
		}

	}
	p.SetState(1373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1370)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1376)
		p.FunctionSignature()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeDeclarationContext is an interface to support dynamic dispatch.
type IAttributeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_ATTRIBUTE() antlr.TerminalNode
	AttributeName() IAttributeNameContext
	StructBody() IStructBodyContext
	TypeAnnotation() ITypeAnnotationContext
	GenericParameterClause() IGenericParameterClauseContext
	Initializer() IInitializerContext
	FollowingDocument() IFollowingDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsAttributeDeclarationContext differentiates from other interfaces.
	IsAttributeDeclarationContext()
}

type AttributeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeDeclarationContext() *AttributeDeclarationContext {
	var p = new(AttributeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeDeclaration
	return p
}

func InitEmptyAttributeDeclarationContext(p *AttributeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeDeclaration
}

func (*AttributeDeclarationContext) IsAttributeDeclarationContext() {}

func NewAttributeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeDeclarationContext {
	var p = new(AttributeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_attributeDeclaration

	return p
}

func (s *AttributeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeDeclarationContext) KEYWORD_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_ATTRIBUTE, 0)
}

func (s *AttributeDeclarationContext) AttributeName() IAttributeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttributeDeclarationContext) StructBody() IStructBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructBodyContext)
}

func (s *AttributeDeclarationContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *AttributeDeclarationContext) GenericParameterClause() IGenericParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParameterClauseContext)
}

func (s *AttributeDeclarationContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *AttributeDeclarationContext) FollowingDocument() IFollowingDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *AttributeDeclarationContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *AttributeDeclarationContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *AttributeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitAttributeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) AttributeDeclaration() (localctx IAttributeDeclarationContext) {
	localctx = NewAttributeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, MojoParserRULE_attributeDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1378)
		p.Match(MojoParserKEYWORD_ATTRIBUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1379)
		p.AttributeName()
	}
	p.SetState(1381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserLT {
		{
			p.SetState(1380)
			p.GenericParameterClause()
		}

	}
	p.SetState(1397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1383)
			p.StructBody()
		}

	case 2:
		{
			p.SetState(1384)
			p.TypeAnnotation()
		}
		p.SetState(1392)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) == 1 {
			p.SetState(1388)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1385)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1390)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1391)
				p.Initializer()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserFOLLOWING_LINE_DOCUMENT {
			{
				p.SetState(1394)
				p.FollowingDocument()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeAliasDeclarationContext is an interface to support dynamic dispatch.
type IAttributeAliasDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_ATTRIBUTE() antlr.TerminalNode
	AttributeName() IAttributeNameContext
	AttributeAliasAssignment() IAttributeAliasAssignmentContext
	GenericParameterClause() IGenericParameterClauseContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsAttributeAliasDeclarationContext differentiates from other interfaces.
	IsAttributeAliasDeclarationContext()
}

type AttributeAliasDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeAliasDeclarationContext() *AttributeAliasDeclarationContext {
	var p = new(AttributeAliasDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeAliasDeclaration
	return p
}

func InitEmptyAttributeAliasDeclarationContext(p *AttributeAliasDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeAliasDeclaration
}

func (*AttributeAliasDeclarationContext) IsAttributeAliasDeclarationContext() {}

func NewAttributeAliasDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeAliasDeclarationContext {
	var p = new(AttributeAliasDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_attributeAliasDeclaration

	return p
}

func (s *AttributeAliasDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeAliasDeclarationContext) KEYWORD_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_ATTRIBUTE, 0)
}

func (s *AttributeAliasDeclarationContext) AttributeName() IAttributeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttributeAliasDeclarationContext) AttributeAliasAssignment() IAttributeAliasAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeAliasAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeAliasAssignmentContext)
}

func (s *AttributeAliasDeclarationContext) GenericParameterClause() IGenericParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParameterClauseContext)
}

func (s *AttributeAliasDeclarationContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *AttributeAliasDeclarationContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *AttributeAliasDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeAliasDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeAliasDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitAttributeAliasDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) AttributeAliasDeclaration() (localctx IAttributeAliasDeclarationContext) {
	localctx = NewAttributeAliasDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, MojoParserRULE_attributeAliasDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1399)
		p.Match(MojoParserKEYWORD_ATTRIBUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1400)
		p.AttributeName()
	}
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserLT {
		{
			p.SetState(1401)
			p.GenericParameterClause()
		}

	}
	p.SetState(1407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1404)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1409)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1410)
		p.AttributeAliasAssignment()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeAliasAssignmentContext is an interface to support dynamic dispatch.
type IAttributeAliasAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentOperator() IAssignmentOperatorContext
	AttributeName() IAttributeNameContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	PackageIdentifier() IPackageIdentifierContext
	DOT() antlr.TerminalNode
	GenericArgumentClause() IGenericArgumentClauseContext
	FollowingDocument() IFollowingDocumentContext

	// IsAttributeAliasAssignmentContext differentiates from other interfaces.
	IsAttributeAliasAssignmentContext()
}

type AttributeAliasAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeAliasAssignmentContext() *AttributeAliasAssignmentContext {
	var p = new(AttributeAliasAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeAliasAssignment
	return p
}

func InitEmptyAttributeAliasAssignmentContext(p *AttributeAliasAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeAliasAssignment
}

func (*AttributeAliasAssignmentContext) IsAttributeAliasAssignmentContext() {}

func NewAttributeAliasAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeAliasAssignmentContext {
	var p = new(AttributeAliasAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_attributeAliasAssignment

	return p
}

func (s *AttributeAliasAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeAliasAssignmentContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AttributeAliasAssignmentContext) AttributeName() IAttributeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttributeAliasAssignmentContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *AttributeAliasAssignmentContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *AttributeAliasAssignmentContext) PackageIdentifier() IPackageIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageIdentifierContext)
}

func (s *AttributeAliasAssignmentContext) DOT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, 0)
}

func (s *AttributeAliasAssignmentContext) GenericArgumentClause() IGenericArgumentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericArgumentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericArgumentClauseContext)
}

func (s *AttributeAliasAssignmentContext) FollowingDocument() IFollowingDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *AttributeAliasAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeAliasAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeAliasAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitAttributeAliasAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) AttributeAliasAssignment() (localctx IAttributeAliasAssignmentContext) {
	localctx = NewAttributeAliasAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, MojoParserRULE_attributeAliasAssignment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1412)
		p.AssignmentOperator()
	}
	p.SetState(1416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1413)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1422)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1419)
			p.PackageIdentifier()
		}
		{
			p.SetState(1420)
			p.Match(MojoParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1424)
		p.AttributeName()
	}
	p.SetState(1426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserLT {
		{
			p.SetState(1425)
			p.GenericArgumentClause()
		}

	}
	p.SetState(1429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserFOLLOWING_LINE_DOCUMENT {
		{
			p.SetState(1428)
			p.FollowingDocument()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WildcardPattern() IWildcardPatternContext
	TypeAnnotation() ITypeAnnotationContext
	IdentifierPattern() IIdentifierPatternContext
	TuplePattern() ITuplePatternContext
	OptionalPattern() IOptionalPatternContext
	KEYWORD_IS() antlr.TerminalNode
	Type_() IType_Context
	ExpressionPattern() IExpressionPatternContext
	Pattern() IPatternContext
	KEYWORD_AS() antlr.TerminalNode

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_pattern
	return p
}

func InitEmptyPatternContext(p *PatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_pattern
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) WildcardPattern() IWildcardPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildcardPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildcardPatternContext)
}

func (s *PatternContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *PatternContext) IdentifierPattern() IIdentifierPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPatternContext)
}

func (s *PatternContext) TuplePattern() ITuplePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITuplePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITuplePatternContext)
}

func (s *PatternContext) OptionalPattern() IOptionalPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionalPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionalPatternContext)
}

func (s *PatternContext) KEYWORD_IS() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IS, 0)
}

func (s *PatternContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *PatternContext) ExpressionPattern() IExpressionPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionPatternContext)
}

func (s *PatternContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *PatternContext) KEYWORD_AS() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_AS, 0)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Pattern() (localctx IPatternContext) {
	return p.pattern(0)
}

func (p *MojoParser) pattern(_p int) (localctx IPatternContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPatternContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPatternContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 166
	p.EnterRecursionRule(localctx, 166, MojoParserRULE_pattern, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1432)
			p.WildcardPattern()
		}
		p.SetState(1434)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1433)
				p.TypeAnnotation()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(1436)
			p.IdentifierPattern()
		}
		p.SetState(1438)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1437)
				p.TypeAnnotation()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		{
			p.SetState(1440)
			p.TuplePattern()
		}
		p.SetState(1442)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1441)
				p.TypeAnnotation()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		{
			p.SetState(1444)
			p.OptionalPattern()
		}

	case 5:
		{
			p.SetState(1445)
			p.Match(MojoParserKEYWORD_IS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1446)
			p.type_(0)
		}

	case 6:
		{
			p.SetState(1447)
			p.ExpressionPattern()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPatternContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, MojoParserRULE_pattern)
			p.SetState(1450)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(1451)
				p.Match(MojoParserKEYWORD_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1452)
				p.type_(0)
			}

		}
		p.SetState(1457)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildcardPatternContext is an interface to support dynamic dispatch.
type IWildcardPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNDERSCORE() antlr.TerminalNode

	// IsWildcardPatternContext differentiates from other interfaces.
	IsWildcardPatternContext()
}

type WildcardPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildcardPatternContext() *WildcardPatternContext {
	var p = new(WildcardPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_wildcardPattern
	return p
}

func InitEmptyWildcardPatternContext(p *WildcardPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_wildcardPattern
}

func (*WildcardPatternContext) IsWildcardPatternContext() {}

func NewWildcardPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildcardPatternContext {
	var p = new(WildcardPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_wildcardPattern

	return p
}

func (s *WildcardPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *WildcardPatternContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(MojoParserUNDERSCORE, 0)
}

func (s *WildcardPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildcardPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitWildcardPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) WildcardPattern() (localctx IWildcardPatternContext) {
	localctx = NewWildcardPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, MojoParserRULE_wildcardPattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1458)
		p.Match(MojoParserUNDERSCORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierPatternContext is an interface to support dynamic dispatch.
type IIdentifierPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DeclarationIdentifier() IDeclarationIdentifierContext

	// IsIdentifierPatternContext differentiates from other interfaces.
	IsIdentifierPatternContext()
}

type IdentifierPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierPatternContext() *IdentifierPatternContext {
	var p = new(IdentifierPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_identifierPattern
	return p
}

func InitEmptyIdentifierPatternContext(p *IdentifierPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_identifierPattern
}

func (*IdentifierPatternContext) IsIdentifierPatternContext() {}

func NewIdentifierPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierPatternContext {
	var p = new(IdentifierPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_identifierPattern

	return p
}

func (s *IdentifierPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierPatternContext) DeclarationIdentifier() IDeclarationIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationIdentifierContext)
}

func (s *IdentifierPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitIdentifierPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) IdentifierPattern() (localctx IIdentifierPatternContext) {
	localctx = NewIdentifierPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, MojoParserRULE_identifierPattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1460)
		p.DeclarationIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITuplePatternContext is an interface to support dynamic dispatch.
type ITuplePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TuplePatternElementList() ITuplePatternElementListContext

	// IsTuplePatternContext differentiates from other interfaces.
	IsTuplePatternContext()
}

type TuplePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTuplePatternContext() *TuplePatternContext {
	var p = new(TuplePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tuplePattern
	return p
}

func InitEmptyTuplePatternContext(p *TuplePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tuplePattern
}

func (*TuplePatternContext) IsTuplePatternContext() {}

func NewTuplePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TuplePatternContext {
	var p = new(TuplePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_tuplePattern

	return p
}

func (s *TuplePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *TuplePatternContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserLPAREN, 0)
}

func (s *TuplePatternContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserRPAREN, 0)
}

func (s *TuplePatternContext) TuplePatternElementList() ITuplePatternElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITuplePatternElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITuplePatternElementListContext)
}

func (s *TuplePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TuplePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TuplePatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTuplePattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TuplePattern() (localctx ITuplePatternContext) {
	localctx = NewTuplePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, MojoParserRULE_tuplePattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1462)
		p.Match(MojoParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90062655082982398) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&4087) != 0) {
		{
			p.SetState(1463)
			p.TuplePatternElementList()
		}

	}
	{
		p.SetState(1466)
		p.Match(MojoParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITuplePatternElementListContext is an interface to support dynamic dispatch.
type ITuplePatternElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTuplePatternElement() []ITuplePatternElementContext
	TuplePatternElement(i int) ITuplePatternElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTuplePatternElementListContext differentiates from other interfaces.
	IsTuplePatternElementListContext()
}

type TuplePatternElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTuplePatternElementListContext() *TuplePatternElementListContext {
	var p = new(TuplePatternElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tuplePatternElementList
	return p
}

func InitEmptyTuplePatternElementListContext(p *TuplePatternElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tuplePatternElementList
}

func (*TuplePatternElementListContext) IsTuplePatternElementListContext() {}

func NewTuplePatternElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TuplePatternElementListContext {
	var p = new(TuplePatternElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_tuplePatternElementList

	return p
}

func (s *TuplePatternElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *TuplePatternElementListContext) AllTuplePatternElement() []ITuplePatternElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITuplePatternElementContext); ok {
			len++
		}
	}

	tst := make([]ITuplePatternElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITuplePatternElementContext); ok {
			tst[i] = t.(ITuplePatternElementContext)
			i++
		}
	}

	return tst
}

func (s *TuplePatternElementListContext) TuplePatternElement(i int) ITuplePatternElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITuplePatternElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITuplePatternElementContext)
}

func (s *TuplePatternElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MojoParserCOMMA)
}

func (s *TuplePatternElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserCOMMA, i)
}

func (s *TuplePatternElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TuplePatternElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TuplePatternElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTuplePatternElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TuplePatternElementList() (localctx ITuplePatternElementListContext) {
	localctx = NewTuplePatternElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, MojoParserRULE_tuplePatternElementList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1468)
		p.TuplePatternElement()
	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserCOMMA {
		{
			p.SetState(1469)
			p.Match(MojoParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1470)
			p.TuplePatternElement()
		}

		p.SetState(1475)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITuplePatternElementContext is an interface to support dynamic dispatch.
type ITuplePatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pattern() IPatternContext

	// IsTuplePatternElementContext differentiates from other interfaces.
	IsTuplePatternElementContext()
}

type TuplePatternElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTuplePatternElementContext() *TuplePatternElementContext {
	var p = new(TuplePatternElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tuplePatternElement
	return p
}

func InitEmptyTuplePatternElementContext(p *TuplePatternElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tuplePatternElement
}

func (*TuplePatternElementContext) IsTuplePatternElementContext() {}

func NewTuplePatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TuplePatternElementContext {
	var p = new(TuplePatternElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_tuplePatternElement

	return p
}

func (s *TuplePatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TuplePatternElementContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *TuplePatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TuplePatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TuplePatternElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTuplePatternElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TuplePatternElement() (localctx ITuplePatternElementContext) {
	localctx = NewTuplePatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, MojoParserRULE_tuplePatternElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1476)
		p.pattern(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionalPatternContext is an interface to support dynamic dispatch.
type IOptionalPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierPattern() IIdentifierPatternContext
	QUESTION() antlr.TerminalNode

	// IsOptionalPatternContext differentiates from other interfaces.
	IsOptionalPatternContext()
}

type OptionalPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalPatternContext() *OptionalPatternContext {
	var p = new(OptionalPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_optionalPattern
	return p
}

func InitEmptyOptionalPatternContext(p *OptionalPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_optionalPattern
}

func (*OptionalPatternContext) IsOptionalPatternContext() {}

func NewOptionalPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalPatternContext {
	var p = new(OptionalPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_optionalPattern

	return p
}

func (s *OptionalPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalPatternContext) IdentifierPattern() IIdentifierPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPatternContext)
}

func (s *OptionalPatternContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(MojoParserQUESTION, 0)
}

func (s *OptionalPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitOptionalPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) OptionalPattern() (localctx IOptionalPatternContext) {
	localctx = NewOptionalPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, MojoParserRULE_optionalPattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1478)
		p.IdentifierPattern()
	}
	{
		p.SetState(1479)
		p.Match(MojoParserQUESTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionPatternContext is an interface to support dynamic dispatch.
type IExpressionPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsExpressionPatternContext differentiates from other interfaces.
	IsExpressionPatternContext()
}

type ExpressionPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionPatternContext() *ExpressionPatternContext {
	var p = new(ExpressionPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_expressionPattern
	return p
}

func InitEmptyExpressionPatternContext(p *ExpressionPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_expressionPattern
}

func (*ExpressionPatternContext) IsExpressionPatternContext() {}

func NewExpressionPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionPatternContext {
	var p = new(ExpressionPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_expressionPattern

	return p
}

func (s *ExpressionPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionPatternContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitExpressionPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ExpressionPattern() (localctx IExpressionPatternContext) {
	localctx = NewExpressionPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, MojoParserRULE_expressionPattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1481)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	DECIMAL_LITERAL() antlr.TerminalNode
	AttributeIdentifier() IAttributeIdentifierContext
	GenericArgumentClause() IGenericArgumentClauseContext
	AttributeArgumentClause() IAttributeArgumentClauseContext

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attribute
	return p
}

func InitEmptyAttributeContext(p *AttributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attribute
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) AT() antlr.TerminalNode {
	return s.GetToken(MojoParserAT, 0)
}

func (s *AttributeContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MojoParserDECIMAL_LITERAL, 0)
}

func (s *AttributeContext) AttributeIdentifier() IAttributeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeIdentifierContext)
}

func (s *AttributeContext) GenericArgumentClause() IGenericArgumentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericArgumentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericArgumentClauseContext)
}

func (s *AttributeContext) AttributeArgumentClause() IAttributeArgumentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeArgumentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeArgumentClauseContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Attribute() (localctx IAttributeContext) {
	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, MojoParserRULE_attribute)
	p.SetState(1493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1483)
			p.Match(MojoParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1484)
			p.Match(MojoParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1485)
			p.Match(MojoParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1486)
			p.AttributeIdentifier()
		}
		p.SetState(1488)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1487)
				p.GenericArgumentClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1491)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1490)
				p.AttributeArgumentClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeIdentifierContext is an interface to support dynamic dispatch.
type IAttributeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttributeName() IAttributeNameContext
	PackageIdentifier() IPackageIdentifierContext
	DOT() antlr.TerminalNode

	// IsAttributeIdentifierContext differentiates from other interfaces.
	IsAttributeIdentifierContext()
}

type AttributeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeIdentifierContext() *AttributeIdentifierContext {
	var p = new(AttributeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeIdentifier
	return p
}

func InitEmptyAttributeIdentifierContext(p *AttributeIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeIdentifier
}

func (*AttributeIdentifierContext) IsAttributeIdentifierContext() {}

func NewAttributeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeIdentifierContext {
	var p = new(AttributeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_attributeIdentifier

	return p
}

func (s *AttributeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeIdentifierContext) AttributeName() IAttributeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttributeIdentifierContext) PackageIdentifier() IPackageIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageIdentifierContext)
}

func (s *AttributeIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, 0)
}

func (s *AttributeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitAttributeIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) AttributeIdentifier() (localctx IAttributeIdentifierContext) {
	localctx = NewAttributeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, MojoParserRULE_attributeIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1498)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1495)
			p.PackageIdentifier()
		}
		{
			p.SetState(1496)
			p.Match(MojoParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1500)
		p.AttributeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeNameContext is an interface to support dynamic dispatch.
type IAttributeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelIdentifier() ILabelIdentifierContext

	// IsAttributeNameContext differentiates from other interfaces.
	IsAttributeNameContext()
}

type AttributeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNameContext() *AttributeNameContext {
	var p = new(AttributeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeName
	return p
}

func InitEmptyAttributeNameContext(p *AttributeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeName
}

func (*AttributeNameContext) IsAttributeNameContext() {}

func NewAttributeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNameContext {
	var p = new(AttributeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_attributeName

	return p
}

func (s *AttributeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeNameContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *AttributeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitAttributeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) AttributeName() (localctx IAttributeNameContext) {
	localctx = NewAttributeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, MojoParserRULE_attributeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1502)
		p.LabelIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeArgumentClauseContext is an interface to support dynamic dispatch.
type IAttributeArgumentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AttributeArguments() IAttributeArgumentsContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsAttributeArgumentClauseContext differentiates from other interfaces.
	IsAttributeArgumentClauseContext()
}

type AttributeArgumentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeArgumentClauseContext() *AttributeArgumentClauseContext {
	var p = new(AttributeArgumentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeArgumentClause
	return p
}

func InitEmptyAttributeArgumentClauseContext(p *AttributeArgumentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeArgumentClause
}

func (*AttributeArgumentClauseContext) IsAttributeArgumentClauseContext() {}

func NewAttributeArgumentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeArgumentClauseContext {
	var p = new(AttributeArgumentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_attributeArgumentClause

	return p
}

func (s *AttributeArgumentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeArgumentClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserLPAREN, 0)
}

func (s *AttributeArgumentClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserRPAREN, 0)
}

func (s *AttributeArgumentClauseContext) AttributeArguments() IAttributeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeArgumentsContext)
}

func (s *AttributeArgumentClauseContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *AttributeArgumentClauseContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *AttributeArgumentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeArgumentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeArgumentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitAttributeArgumentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) AttributeArgumentClause() (localctx IAttributeArgumentClauseContext) {
	localctx = NewAttributeArgumentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, MojoParserRULE_attributeArgumentClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1504)
		p.Match(MojoParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1512)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) == 1 {
		p.SetState(1508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1505)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1510)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1511)
			p.AttributeArguments()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1514)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1520)
		p.Match(MojoParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeArgumentContext is an interface to support dynamic dispatch.
type IAttributeArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	LabelIdentifier() ILabelIdentifierContext
	COLON() antlr.TerminalNode

	// IsAttributeArgumentContext differentiates from other interfaces.
	IsAttributeArgumentContext()
}

type AttributeArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeArgumentContext() *AttributeArgumentContext {
	var p = new(AttributeArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeArgument
	return p
}

func InitEmptyAttributeArgumentContext(p *AttributeArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeArgument
}

func (*AttributeArgumentContext) IsAttributeArgumentContext() {}

func NewAttributeArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeArgumentContext {
	var p = new(AttributeArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_attributeArgument

	return p
}

func (s *AttributeArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AttributeArgumentContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *AttributeArgumentContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *AttributeArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitAttributeArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) AttributeArgument() (localctx IAttributeArgumentContext) {
	localctx = NewAttributeArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, MojoParserRULE_attributeArgument)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1525)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1522)
			p.LabelIdentifier()
		}
		{
			p.SetState(1523)
			p.Match(MojoParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1527)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeArgumentsContext is an interface to support dynamic dispatch.
type IAttributeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAttributeArgument() []IAttributeArgumentContext
	AttributeArgument(i int) IAttributeArgumentContext
	AllEov() []IEovContext
	Eov(i int) IEovContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsAttributeArgumentsContext differentiates from other interfaces.
	IsAttributeArgumentsContext()
}

type AttributeArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeArgumentsContext() *AttributeArgumentsContext {
	var p = new(AttributeArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeArguments
	return p
}

func InitEmptyAttributeArgumentsContext(p *AttributeArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributeArguments
}

func (*AttributeArgumentsContext) IsAttributeArgumentsContext() {}

func NewAttributeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeArgumentsContext {
	var p = new(AttributeArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_attributeArguments

	return p
}

func (s *AttributeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeArgumentsContext) AllAttributeArgument() []IAttributeArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeArgumentContext); ok {
			len++
		}
	}

	tst := make([]IAttributeArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeArgumentContext); ok {
			tst[i] = t.(IAttributeArgumentContext)
			i++
		}
	}

	return tst
}

func (s *AttributeArgumentsContext) AttributeArgument(i int) IAttributeArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeArgumentContext)
}

func (s *AttributeArgumentsContext) AllEov() []IEovContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovContext); ok {
			len++
		}
	}

	tst := make([]IEovContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovContext); ok {
			tst[i] = t.(IEovContext)
			i++
		}
	}

	return tst
}

func (s *AttributeArgumentsContext) Eov(i int) IEovContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovContext)
}

func (s *AttributeArgumentsContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *AttributeArgumentsContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *AttributeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitAttributeArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) AttributeArguments() (localctx IAttributeArgumentsContext) {
	localctx = NewAttributeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, MojoParserRULE_attributeArguments)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1529)
		p.AttributeArgument()
	}
	p.SetState(1541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1530)
				p.Eov()
			}
			p.SetState(1534)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1531)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1536)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1537)
				p.AttributeArgument()
			}

		}
		p.SetState(1543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1545)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1544)
			p.Eov()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributesContext is an interface to support dynamic dispatch.
type IAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAttribute() []IAttributeContext
	Attribute(i int) IAttributeContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsAttributesContext differentiates from other interfaces.
	IsAttributesContext()
}

type AttributesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributesContext() *AttributesContext {
	var p = new(AttributesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributes
	return p
}

func InitEmptyAttributesContext(p *AttributesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_attributes
}

func (*AttributesContext) IsAttributesContext() {}

func NewAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributesContext {
	var p = new(AttributesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_attributes

	return p
}

func (s *AttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributesContext) AllAttribute() []IAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeContext); ok {
			len++
		}
	}

	tst := make([]IAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeContext); ok {
			tst[i] = t.(IAttributeContext)
			i++
		}
	}

	return tst
}

func (s *AttributesContext) Attribute(i int) IAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *AttributesContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *AttributesContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *AttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitAttributes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Attributes() (localctx IAttributesContext) {
	localctx = NewAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, MojoParserRULE_attributes)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1547)
		p.Attribute()
	}
	p.SetState(1554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1549)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MojoParserEOL {
				{
					p.SetState(1548)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1551)
				p.Attribute()
			}

		}
		p.SetState(1556)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrefixExpression() IPrefixExpressionContext
	BinaryExpressions() IBinaryExpressionsContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) PrefixExpression() IPrefixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixExpressionContext)
}

func (s *ExpressionContext) BinaryExpressions() IBinaryExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinaryExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinaryExpressionsContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, MojoParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1557)
		p.PrefixExpression()
	}
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1558)
			p.BinaryExpressions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllEov() []IEovContext
	Eov(i int) IEovContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsExpressionsContext differentiates from other interfaces.
	IsExpressionsContext()
}

type ExpressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext {
	var p = new(ExpressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_expressions
	return p
}

func InitEmptyExpressionsContext(p *ExpressionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_expressions
}

func (*ExpressionsContext) IsExpressionsContext() {}

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext {
	var p = new(ExpressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_expressions

	return p
}

func (s *ExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionsContext) AllEov() []IEovContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovContext); ok {
			len++
		}
	}

	tst := make([]IEovContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovContext); ok {
			tst[i] = t.(IEovContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsContext) Eov(i int) IEovContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovContext)
}

func (s *ExpressionsContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ExpressionsContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Expressions() (localctx IExpressionsContext) {
	localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, MojoParserRULE_expressions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1561)
		p.Expression()
	}
	p.SetState(1573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1562)
				p.Eov()
			}
			p.SetState(1566)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1563)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1568)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1569)
				p.Expression()
			}

		}
		p.SetState(1575)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserCOMMA || _la == MojoParserEOL {
		{
			p.SetState(1576)
			p.Eov()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrefixExpressionContext is an interface to support dynamic dispatch.
type IPrefixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrefixOperator() IPrefixOperatorContext
	PostfixExpression() IPostfixExpressionContext

	// IsPrefixExpressionContext differentiates from other interfaces.
	IsPrefixExpressionContext()
}

type PrefixExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixExpressionContext() *PrefixExpressionContext {
	var p = new(PrefixExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_prefixExpression
	return p
}

func InitEmptyPrefixExpressionContext(p *PrefixExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_prefixExpression
}

func (*PrefixExpressionContext) IsPrefixExpressionContext() {}

func NewPrefixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixExpressionContext {
	var p = new(PrefixExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_prefixExpression

	return p
}

func (s *PrefixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixExpressionContext) PrefixOperator() IPrefixOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixOperatorContext)
}

func (s *PrefixExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PrefixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPrefixExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PrefixExpression() (localctx IPrefixExpressionContext) {
	localctx = NewPrefixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, MojoParserRULE_prefixExpression)
	p.SetState(1583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1579)
			p.PrefixOperator()
		}
		{
			p.SetState(1580)
			p.PostfixExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1582)
			p.PostfixExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinaryExpressionContext is an interface to support dynamic dispatch.
type IBinaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BinaryOperator() IBinaryOperatorContext
	PrefixExpression() IPrefixExpressionContext
	AssignmentOperator() IAssignmentOperatorContext
	ConditionalOperator() IConditionalOperatorContext
	TypeCastingOperator() ITypeCastingOperatorContext

	// IsBinaryExpressionContext differentiates from other interfaces.
	IsBinaryExpressionContext()
}

type BinaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryExpressionContext() *BinaryExpressionContext {
	var p = new(BinaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_binaryExpression
	return p
}

func InitEmptyBinaryExpressionContext(p *BinaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_binaryExpression
}

func (*BinaryExpressionContext) IsBinaryExpressionContext() {}

func NewBinaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryExpressionContext {
	var p = new(BinaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_binaryExpression

	return p
}

func (s *BinaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryExpressionContext) BinaryOperator() IBinaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinaryOperatorContext)
}

func (s *BinaryExpressionContext) PrefixExpression() IPrefixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixExpressionContext)
}

func (s *BinaryExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *BinaryExpressionContext) ConditionalOperator() IConditionalOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalOperatorContext)
}

func (s *BinaryExpressionContext) TypeCastingOperator() ITypeCastingOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCastingOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCastingOperatorContext)
}

func (s *BinaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitBinaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) BinaryExpression() (localctx IBinaryExpressionContext) {
	localctx = NewBinaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, MojoParserRULE_binaryExpression)
	p.SetState(1595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1585)
			p.BinaryOperator()
		}
		{
			p.SetState(1586)
			p.PrefixExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1588)
			p.AssignmentOperator()
		}
		{
			p.SetState(1589)
			p.PrefixExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1591)
			p.ConditionalOperator()
		}
		{
			p.SetState(1592)
			p.PrefixExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1594)
			p.TypeCastingOperator()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinaryExpressionsContext is an interface to support dynamic dispatch.
type IBinaryExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBinaryExpression() []IBinaryExpressionContext
	BinaryExpression(i int) IBinaryExpressionContext

	// IsBinaryExpressionsContext differentiates from other interfaces.
	IsBinaryExpressionsContext()
}

type BinaryExpressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryExpressionsContext() *BinaryExpressionsContext {
	var p = new(BinaryExpressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_binaryExpressions
	return p
}

func InitEmptyBinaryExpressionsContext(p *BinaryExpressionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_binaryExpressions
}

func (*BinaryExpressionsContext) IsBinaryExpressionsContext() {}

func NewBinaryExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryExpressionsContext {
	var p = new(BinaryExpressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_binaryExpressions

	return p
}

func (s *BinaryExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryExpressionsContext) AllBinaryExpression() []IBinaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBinaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBinaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBinaryExpressionContext); ok {
			tst[i] = t.(IBinaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BinaryExpressionsContext) BinaryExpression(i int) IBinaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinaryExpressionContext)
}

func (s *BinaryExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitBinaryExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) BinaryExpressions() (localctx IBinaryExpressionsContext) {
	localctx = NewBinaryExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, MojoParserRULE_binaryExpressions)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1597)
				p.BinaryExpression()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1600)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalOperatorContext is an interface to support dynamic dispatch.
type IConditionalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUESTION() antlr.TerminalNode
	Expression() IExpressionContext
	COLON() antlr.TerminalNode

	// IsConditionalOperatorContext differentiates from other interfaces.
	IsConditionalOperatorContext()
}

type ConditionalOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalOperatorContext() *ConditionalOperatorContext {
	var p = new(ConditionalOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_conditionalOperator
	return p
}

func InitEmptyConditionalOperatorContext(p *ConditionalOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_conditionalOperator
}

func (*ConditionalOperatorContext) IsConditionalOperatorContext() {}

func NewConditionalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalOperatorContext {
	var p = new(ConditionalOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_conditionalOperator

	return p
}

func (s *ConditionalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalOperatorContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(MojoParserQUESTION, 0)
}

func (s *ConditionalOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalOperatorContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *ConditionalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitConditionalOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ConditionalOperator() (localctx IConditionalOperatorContext) {
	localctx = NewConditionalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, MojoParserRULE_conditionalOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1602)
		p.Match(MojoParserQUESTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1603)
		p.Expression()
	}
	{
		p.SetState(1604)
		p.Match(MojoParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeCastingOperatorContext is an interface to support dynamic dispatch.
type ITypeCastingOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_IS() antlr.TerminalNode
	Type_() IType_Context
	KEYWORD_AS() antlr.TerminalNode

	// IsTypeCastingOperatorContext differentiates from other interfaces.
	IsTypeCastingOperatorContext()
}

type TypeCastingOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeCastingOperatorContext() *TypeCastingOperatorContext {
	var p = new(TypeCastingOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeCastingOperator
	return p
}

func InitEmptyTypeCastingOperatorContext(p *TypeCastingOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeCastingOperator
}

func (*TypeCastingOperatorContext) IsTypeCastingOperatorContext() {}

func NewTypeCastingOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeCastingOperatorContext {
	var p = new(TypeCastingOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_typeCastingOperator

	return p
}

func (s *TypeCastingOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeCastingOperatorContext) KEYWORD_IS() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IS, 0)
}

func (s *TypeCastingOperatorContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeCastingOperatorContext) KEYWORD_AS() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_AS, 0)
}

func (s *TypeCastingOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeCastingOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeCastingOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTypeCastingOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TypeCastingOperator() (localctx ITypeCastingOperatorContext) {
	localctx = NewTypeCastingOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, MojoParserRULE_typeCastingOperator)
	p.SetState(1610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserKEYWORD_IS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1606)
			p.Match(MojoParserKEYWORD_IS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1607)
			p.type_(0)
		}

	case MojoParserKEYWORD_AS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1608)
			p.Match(MojoParserKEYWORD_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1609)
			p.type_(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LiteralExpression() ILiteralExpressionContext
	DeclarationIdentifier() IDeclarationIdentifierContext
	GenericArgumentClause() IGenericArgumentClauseContext
	TypeIdentifier() ITypeIdentifierContext
	DOT() antlr.TerminalNode
	ClosureExpression() IClosureExpressionContext
	TupleLiteralExpression() ITupleLiteralExpressionContext
	ParenthesizedExpression() IParenthesizedExpressionContext
	ImplicitMemberExpression() IImplicitMemberExpressionContext
	WildcardExpression() IWildcardExpressionContext
	StructConstructionExpression() IStructConstructionExpressionContext

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *PrimaryExpressionContext) DeclarationIdentifier() IDeclarationIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationIdentifierContext)
}

func (s *PrimaryExpressionContext) GenericArgumentClause() IGenericArgumentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericArgumentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericArgumentClauseContext)
}

func (s *PrimaryExpressionContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PrimaryExpressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, 0)
}

func (s *PrimaryExpressionContext) ClosureExpression() IClosureExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureExpressionContext)
}

func (s *PrimaryExpressionContext) TupleLiteralExpression() ITupleLiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleLiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleLiteralExpressionContext)
}

func (s *PrimaryExpressionContext) ParenthesizedExpression() IParenthesizedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExpressionContext)
}

func (s *PrimaryExpressionContext) ImplicitMemberExpression() IImplicitMemberExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplicitMemberExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplicitMemberExpressionContext)
}

func (s *PrimaryExpressionContext) WildcardExpression() IWildcardExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildcardExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildcardExpressionContext)
}

func (s *PrimaryExpressionContext) StructConstructionExpression() IStructConstructionExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructConstructionExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructConstructionExpressionContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPrimaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, MojoParserRULE_primaryExpression)
	p.SetState(1629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1612)
			p.LiteralExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1613)
			p.DeclarationIdentifier()
		}
		p.SetState(1615)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1614)
				p.GenericArgumentClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1617)
			p.TypeIdentifier()
		}
		{
			p.SetState(1618)
			p.Match(MojoParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1619)
			p.DeclarationIdentifier()
		}
		p.SetState(1621)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1620)
				p.GenericArgumentClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1623)
			p.ClosureExpression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1624)
			p.TupleLiteralExpression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1625)
			p.ParenthesizedExpression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1626)
			p.ImplicitMemberExpression()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1627)
			p.WildcardExpression()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1628)
			p.StructConstructionExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralExpressionContext is an interface to support dynamic dispatch.
type ILiteralExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericOperatorLiteral() INumericOperatorLiteralContext
	StringOperatorLiteral() IStringOperatorLiteralContext
	StructLiteral() IStructLiteralContext
	Literal() ILiteralContext
	ArrayLiteral() IArrayLiteralContext
	MapLiteral() IMapLiteralContext
	ObjectLiteral() IObjectLiteralContext

	// IsLiteralExpressionContext differentiates from other interfaces.
	IsLiteralExpressionContext()
}

type LiteralExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralExpressionContext() *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_literalExpression
	return p
}

func InitEmptyLiteralExpressionContext(p *LiteralExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_literalExpression
}

func (*LiteralExpressionContext) IsLiteralExpressionContext() {}

func NewLiteralExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_literalExpression

	return p
}

func (s *LiteralExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralExpressionContext) NumericOperatorLiteral() INumericOperatorLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericOperatorLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericOperatorLiteralContext)
}

func (s *LiteralExpressionContext) StringOperatorLiteral() IStringOperatorLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringOperatorLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringOperatorLiteralContext)
}

func (s *LiteralExpressionContext) StructLiteral() IStructLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructLiteralContext)
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *LiteralExpressionContext) MapLiteral() IMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *LiteralExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) LiteralExpression() (localctx ILiteralExpressionContext) {
	localctx = NewLiteralExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, MojoParserRULE_literalExpression)
	p.SetState(1638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1631)
			p.NumericOperatorLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1632)
			p.StringOperatorLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1633)
			p.StructLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1634)
			p.Literal()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1635)
			p.ArrayLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1636)
			p.MapLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1637)
			p.ObjectLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericOperatorLiteralContext is an interface to support dynamic dispatch.
type INumericOperatorLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericLiteral() INumericLiteralContext
	SuffixLiteralOperator() ISuffixLiteralOperatorContext

	// IsNumericOperatorLiteralContext differentiates from other interfaces.
	IsNumericOperatorLiteralContext()
}

type NumericOperatorLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericOperatorLiteralContext() *NumericOperatorLiteralContext {
	var p = new(NumericOperatorLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_numericOperatorLiteral
	return p
}

func InitEmptyNumericOperatorLiteralContext(p *NumericOperatorLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_numericOperatorLiteral
}

func (*NumericOperatorLiteralContext) IsNumericOperatorLiteralContext() {}

func NewNumericOperatorLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericOperatorLiteralContext {
	var p = new(NumericOperatorLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_numericOperatorLiteral

	return p
}

func (s *NumericOperatorLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericOperatorLiteralContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *NumericOperatorLiteralContext) SuffixLiteralOperator() ISuffixLiteralOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuffixLiteralOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuffixLiteralOperatorContext)
}

func (s *NumericOperatorLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericOperatorLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericOperatorLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitNumericOperatorLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) NumericOperatorLiteral() (localctx INumericOperatorLiteralContext) {
	localctx = NewNumericOperatorLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, MojoParserRULE_numericOperatorLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1640)
		p.NumericLiteral()
	}
	{
		p.SetState(1641)
		p.SuffixLiteralOperator()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringOperatorLiteralContext is an interface to support dynamic dispatch.
type IStringOperatorLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrefixLiteralOperator() IPrefixLiteralOperatorContext
	StringLiteral() IStringLiteralContext
	SuffixLiteralOperator() ISuffixLiteralOperatorContext

	// IsStringOperatorLiteralContext differentiates from other interfaces.
	IsStringOperatorLiteralContext()
}

type StringOperatorLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringOperatorLiteralContext() *StringOperatorLiteralContext {
	var p = new(StringOperatorLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_stringOperatorLiteral
	return p
}

func InitEmptyStringOperatorLiteralContext(p *StringOperatorLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_stringOperatorLiteral
}

func (*StringOperatorLiteralContext) IsStringOperatorLiteralContext() {}

func NewStringOperatorLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringOperatorLiteralContext {
	var p = new(StringOperatorLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_stringOperatorLiteral

	return p
}

func (s *StringOperatorLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringOperatorLiteralContext) PrefixLiteralOperator() IPrefixLiteralOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixLiteralOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixLiteralOperatorContext)
}

func (s *StringOperatorLiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *StringOperatorLiteralContext) SuffixLiteralOperator() ISuffixLiteralOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuffixLiteralOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuffixLiteralOperatorContext)
}

func (s *StringOperatorLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringOperatorLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringOperatorLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStringOperatorLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) StringOperatorLiteral() (localctx IStringOperatorLiteralContext) {
	localctx = NewStringOperatorLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, MojoParserRULE_stringOperatorLiteral)
	p.SetState(1652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserVALUE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1643)
			p.PrefixLiteralOperator()
		}
		p.SetState(1644)

		if !(p.GetTokenStream().Get(p.GetTokenStream().Index()-1).GetTokenType() != MojoParserWS) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.GetTokenStream().Get(p.GetTokenStream().Index()-1).GetTokenType() != MojoParserWS", ""))
			goto errorExit
		}
		{
			p.SetState(1645)
			p.StringLiteral()
		}
		p.SetState(1647)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1646)
				p.SuffixLiteralOperator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MojoParserSTATIC_STRING_LITERAL, MojoParserINTERPOLATED_STRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1649)
			p.StringLiteral()
		}
		{
			p.SetState(1650)
			p.SuffixLiteralOperator()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuffixLiteralOperatorContext is an interface to support dynamic dispatch.
type ISuffixLiteralOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE_IDENTIFIER() antlr.TerminalNode
	VALUE_IDENTIFIER() antlr.TerminalNode

	// IsSuffixLiteralOperatorContext differentiates from other interfaces.
	IsSuffixLiteralOperatorContext()
}

type SuffixLiteralOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuffixLiteralOperatorContext() *SuffixLiteralOperatorContext {
	var p = new(SuffixLiteralOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_suffixLiteralOperator
	return p
}

func InitEmptySuffixLiteralOperatorContext(p *SuffixLiteralOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_suffixLiteralOperator
}

func (*SuffixLiteralOperatorContext) IsSuffixLiteralOperatorContext() {}

func NewSuffixLiteralOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuffixLiteralOperatorContext {
	var p = new(SuffixLiteralOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_suffixLiteralOperator

	return p
}

func (s *SuffixLiteralOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SuffixLiteralOperatorContext) TYPE_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MojoParserTYPE_IDENTIFIER, 0)
}

func (s *SuffixLiteralOperatorContext) VALUE_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MojoParserVALUE_IDENTIFIER, 0)
}

func (s *SuffixLiteralOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuffixLiteralOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuffixLiteralOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitSuffixLiteralOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) SuffixLiteralOperator() (localctx ISuffixLiteralOperatorContext) {
	localctx = NewSuffixLiteralOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, MojoParserRULE_suffixLiteralOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1654)

	if !(p.GetTokenStream().Get(p.GetTokenStream().Index()-1).GetTokenType() != MojoParserWS) {
		p.SetError(antlr.NewFailedPredicateException(p, "p.GetTokenStream().Get(p.GetTokenStream().Index()-1).GetTokenType() != MojoParserWS", ""))
		goto errorExit
	}
	{
		p.SetState(1655)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MojoParserTYPE_IDENTIFIER || _la == MojoParserVALUE_IDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrefixLiteralOperatorContext is an interface to support dynamic dispatch.
type IPrefixLiteralOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUE_IDENTIFIER() antlr.TerminalNode

	// IsPrefixLiteralOperatorContext differentiates from other interfaces.
	IsPrefixLiteralOperatorContext()
}

type PrefixLiteralOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixLiteralOperatorContext() *PrefixLiteralOperatorContext {
	var p = new(PrefixLiteralOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_prefixLiteralOperator
	return p
}

func InitEmptyPrefixLiteralOperatorContext(p *PrefixLiteralOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_prefixLiteralOperator
}

func (*PrefixLiteralOperatorContext) IsPrefixLiteralOperatorContext() {}

func NewPrefixLiteralOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixLiteralOperatorContext {
	var p = new(PrefixLiteralOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_prefixLiteralOperator

	return p
}

func (s *PrefixLiteralOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixLiteralOperatorContext) VALUE_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MojoParserVALUE_IDENTIFIER, 0)
}

func (s *PrefixLiteralOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixLiteralOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixLiteralOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPrefixLiteralOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PrefixLiteralOperator() (localctx IPrefixLiteralOperatorContext) {
	localctx = NewPrefixLiteralOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, MojoParserRULE_prefixLiteralOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1657)
		p.Match(MojoParserVALUE_IDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	ArrayLiteralItems() IArrayLiteralItemsContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(MojoParserLBRACK, 0)
}

func (s *ArrayLiteralContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(MojoParserRBRACK, 0)
}

func (s *ArrayLiteralContext) ArrayLiteralItems() IArrayLiteralItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralItemsContext)
}

func (s *ArrayLiteralContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ArrayLiteralContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, MojoParserRULE_arrayLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1659)
		p.Match(MojoParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1667)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
		p.SetState(1663)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1660)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1665)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1666)
			p.ArrayLiteralItems()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1669)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1675)
		p.Match(MojoParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralItemsContext is an interface to support dynamic dispatch.
type IArrayLiteralItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArrayLiteralItem() []IArrayLiteralItemContext
	ArrayLiteralItem(i int) IArrayLiteralItemContext
	AllEov() []IEovContext
	Eov(i int) IEovContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsArrayLiteralItemsContext differentiates from other interfaces.
	IsArrayLiteralItemsContext()
}

type ArrayLiteralItemsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralItemsContext() *ArrayLiteralItemsContext {
	var p = new(ArrayLiteralItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_arrayLiteralItems
	return p
}

func InitEmptyArrayLiteralItemsContext(p *ArrayLiteralItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_arrayLiteralItems
}

func (*ArrayLiteralItemsContext) IsArrayLiteralItemsContext() {}

func NewArrayLiteralItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralItemsContext {
	var p = new(ArrayLiteralItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_arrayLiteralItems

	return p
}

func (s *ArrayLiteralItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralItemsContext) AllArrayLiteralItem() []IArrayLiteralItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayLiteralItemContext); ok {
			len++
		}
	}

	tst := make([]IArrayLiteralItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayLiteralItemContext); ok {
			tst[i] = t.(IArrayLiteralItemContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralItemsContext) ArrayLiteralItem(i int) IArrayLiteralItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralItemContext)
}

func (s *ArrayLiteralItemsContext) AllEov() []IEovContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovContext); ok {
			len++
		}
	}

	tst := make([]IEovContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovContext); ok {
			tst[i] = t.(IEovContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralItemsContext) Eov(i int) IEovContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovContext)
}

func (s *ArrayLiteralItemsContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ArrayLiteralItemsContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ArrayLiteralItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitArrayLiteralItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ArrayLiteralItems() (localctx IArrayLiteralItemsContext) {
	localctx = NewArrayLiteralItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, MojoParserRULE_arrayLiteralItems)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1677)
		p.ArrayLiteralItem()
	}
	p.SetState(1689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1678)
				p.Eov()
			}
			p.SetState(1682)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1679)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1684)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1685)
				p.ArrayLiteralItem()
			}

		}
		p.SetState(1691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1693)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1692)
			p.Eov()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralItemContext is an interface to support dynamic dispatch.
type IArrayLiteralItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	ELLIPSIS() antlr.TerminalNode

	// IsArrayLiteralItemContext differentiates from other interfaces.
	IsArrayLiteralItemContext()
}

type ArrayLiteralItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralItemContext() *ArrayLiteralItemContext {
	var p = new(ArrayLiteralItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_arrayLiteralItem
	return p
}

func InitEmptyArrayLiteralItemContext(p *ArrayLiteralItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_arrayLiteralItem
}

func (*ArrayLiteralItemContext) IsArrayLiteralItemContext() {}

func NewArrayLiteralItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralItemContext {
	var p = new(ArrayLiteralItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_arrayLiteralItem

	return p
}

func (s *ArrayLiteralItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayLiteralItemContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(MojoParserELLIPSIS, 0)
}

func (s *ArrayLiteralItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitArrayLiteralItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ArrayLiteralItem() (localctx IArrayLiteralItemContext) {
	localctx = NewArrayLiteralItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, MojoParserRULE_arrayLiteralItem)
	p.SetState(1697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserKEYWORD_AND, MojoParserKEYWORD_AS, MojoParserKEYWORD_ATTRIBUTE, MojoParserKEYWORD_BREAK, MojoParserKEYWORD_CONST, MojoParserKEYWORD_CONTINUE, MojoParserKEYWORD_ELSE, MojoParserKEYWORD_ENUM, MojoParserKEYWORD_FALSE, MojoParserKEYWORD_FUNC, MojoParserKEYWORD_IMPORT, MojoParserKEYWORD_IN, MojoParserKEYWORD_INTERFACE, MojoParserKEYWORD_IS, MojoParserKEYWORD_MATCH, MojoParserKEYWORD_NOT, MojoParserKEYWORD_NULL, MojoParserKEYWORD_OR, MojoParserKEYWORD_PACKAGE, MojoParserKEYWORD_STRUCT, MojoParserKEYWORD_TRUE, MojoParserKEYWORD_TYPE, MojoParserKEYWORD_XOR, MojoParserDOT, MojoParserLCURLY, MojoParserLPAREN, MojoParserLBRACK, MojoParserLT, MojoParserGT, MojoParserBANG, MojoParserQUESTION, MojoParserAND, MojoParserMINUS, MojoParserEQUAL, MojoParserPIPE, MojoParserSLASH, MojoParserPLUS, MojoParserSTAR, MojoParserPERCENT, MojoParserCARET, MojoParserTILDE, MojoParserUNDERSCORE, MojoParserTYPE_IDENTIFIER, MojoParserVALUE_IDENTIFIER, MojoParserOPERATOR_HEAD_OTHER, MojoParserBINARY_LITERAL, MojoParserOCTAL_LITERAL, MojoParserDECIMAL_LITERAL, MojoParserPURE_DECIMAL_DIGITS, MojoParserHEXADECIMAL_LITERAL, MojoParserFLOAT_LITERAL, MojoParserSTATIC_STRING_LITERAL, MojoParserINTERPOLATED_STRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1695)
			p.Expression()
		}

	case MojoParserELLIPSIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1696)
			p.Match(MojoParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURLY() antlr.TerminalNode
	RCURLY() antlr.TerminalNode
	MapLiteralItems() IMapLiteralItemsContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_mapLiteral
	return p
}

func InitEmptyMapLiteralContext(p *MapLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_mapLiteral
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *MapLiteralContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *MapLiteralContext) MapLiteralItems() IMapLiteralItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralItemsContext)
}

func (s *MapLiteralContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *MapLiteralContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitMapLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) MapLiteral() (localctx IMapLiteralContext) {
	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, MojoParserRULE_mapLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1699)
		p.Match(MojoParserLCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1707)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 219, p.GetParserRuleContext()) == 1 {
		p.SetState(1703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1700)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1705)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1706)
			p.MapLiteralItems()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1709)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1714)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1715)
		p.Match(MojoParserRCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapLiteralItemsContext is an interface to support dynamic dispatch.
type IMapLiteralItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMapLiteralItem() []IMapLiteralItemContext
	MapLiteralItem(i int) IMapLiteralItemContext
	AllEov() []IEovContext
	Eov(i int) IEovContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsMapLiteralItemsContext differentiates from other interfaces.
	IsMapLiteralItemsContext()
}

type MapLiteralItemsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralItemsContext() *MapLiteralItemsContext {
	var p = new(MapLiteralItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_mapLiteralItems
	return p
}

func InitEmptyMapLiteralItemsContext(p *MapLiteralItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_mapLiteralItems
}

func (*MapLiteralItemsContext) IsMapLiteralItemsContext() {}

func NewMapLiteralItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralItemsContext {
	var p = new(MapLiteralItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_mapLiteralItems

	return p
}

func (s *MapLiteralItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralItemsContext) AllMapLiteralItem() []IMapLiteralItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapLiteralItemContext); ok {
			len++
		}
	}

	tst := make([]IMapLiteralItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapLiteralItemContext); ok {
			tst[i] = t.(IMapLiteralItemContext)
			i++
		}
	}

	return tst
}

func (s *MapLiteralItemsContext) MapLiteralItem(i int) IMapLiteralItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralItemContext)
}

func (s *MapLiteralItemsContext) AllEov() []IEovContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovContext); ok {
			len++
		}
	}

	tst := make([]IEovContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovContext); ok {
			tst[i] = t.(IEovContext)
			i++
		}
	}

	return tst
}

func (s *MapLiteralItemsContext) Eov(i int) IEovContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovContext)
}

func (s *MapLiteralItemsContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *MapLiteralItemsContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *MapLiteralItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLiteralItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitMapLiteralItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) MapLiteralItems() (localctx IMapLiteralItemsContext) {
	localctx = NewMapLiteralItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, MojoParserRULE_mapLiteralItems)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1717)
		p.MapLiteralItem()
	}
	p.SetState(1729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 222, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1718)
				p.Eov()
			}
			p.SetState(1722)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1719)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1724)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1725)
				p.MapLiteralItem()
			}

		}
		p.SetState(1731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 222, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1733)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1732)
			p.Eov()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapLiteralItemContext is an interface to support dynamic dispatch.
type IMapLiteralItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Expression() IExpressionContext
	StringLiteral() IStringLiteralContext
	IntegerLiteral() IIntegerLiteralContext

	// IsMapLiteralItemContext differentiates from other interfaces.
	IsMapLiteralItemContext()
}

type MapLiteralItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralItemContext() *MapLiteralItemContext {
	var p = new(MapLiteralItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_mapLiteralItem
	return p
}

func InitEmptyMapLiteralItemContext(p *MapLiteralItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_mapLiteralItem
}

func (*MapLiteralItemContext) IsMapLiteralItemContext() {}

func NewMapLiteralItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralItemContext {
	var p = new(MapLiteralItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_mapLiteralItem

	return p
}

func (s *MapLiteralItemContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *MapLiteralItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapLiteralItemContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *MapLiteralItemContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *MapLiteralItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLiteralItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitMapLiteralItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) MapLiteralItem() (localctx IMapLiteralItemContext) {
	localctx = NewMapLiteralItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, MojoParserRULE_mapLiteralItem)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserSTATIC_STRING_LITERAL, MojoParserINTERPOLATED_STRING_LITERAL:
		{
			p.SetState(1735)
			p.StringLiteral()
		}

	case MojoParserBINARY_LITERAL, MojoParserOCTAL_LITERAL, MojoParserDECIMAL_LITERAL, MojoParserPURE_DECIMAL_DIGITS, MojoParserHEXADECIMAL_LITERAL:
		{
			p.SetState(1736)
			p.IntegerLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1739)
		p.Match(MojoParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1740)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURLY() antlr.TerminalNode
	RCURLY() antlr.TerminalNode
	ObjectLiteralItems() IObjectLiteralItemsContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_objectLiteral
	return p
}

func InitEmptyObjectLiteralContext(p *ObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_objectLiteral
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *ObjectLiteralContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *ObjectLiteralContext) ObjectLiteralItems() IObjectLiteralItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralItemsContext)
}

func (s *ObjectLiteralContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ObjectLiteralContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, MojoParserRULE_objectLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1742)
		p.Match(MojoParserLCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1750)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext()) == 1 {
		p.SetState(1746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1743)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1748)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1749)
			p.ObjectLiteralItems()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1752)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1758)
		p.Match(MojoParserRCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralItemsContext is an interface to support dynamic dispatch.
type IObjectLiteralItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObjectLiteralItem() []IObjectLiteralItemContext
	ObjectLiteralItem(i int) IObjectLiteralItemContext
	AllEov() []IEovContext
	Eov(i int) IEovContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsObjectLiteralItemsContext differentiates from other interfaces.
	IsObjectLiteralItemsContext()
}

type ObjectLiteralItemsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralItemsContext() *ObjectLiteralItemsContext {
	var p = new(ObjectLiteralItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_objectLiteralItems
	return p
}

func InitEmptyObjectLiteralItemsContext(p *ObjectLiteralItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_objectLiteralItems
}

func (*ObjectLiteralItemsContext) IsObjectLiteralItemsContext() {}

func NewObjectLiteralItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralItemsContext {
	var p = new(ObjectLiteralItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_objectLiteralItems

	return p
}

func (s *ObjectLiteralItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralItemsContext) AllObjectLiteralItem() []IObjectLiteralItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectLiteralItemContext); ok {
			len++
		}
	}

	tst := make([]IObjectLiteralItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectLiteralItemContext); ok {
			tst[i] = t.(IObjectLiteralItemContext)
			i++
		}
	}

	return tst
}

func (s *ObjectLiteralItemsContext) ObjectLiteralItem(i int) IObjectLiteralItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralItemContext)
}

func (s *ObjectLiteralItemsContext) AllEov() []IEovContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovContext); ok {
			len++
		}
	}

	tst := make([]IEovContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovContext); ok {
			tst[i] = t.(IEovContext)
			i++
		}
	}

	return tst
}

func (s *ObjectLiteralItemsContext) Eov(i int) IEovContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovContext)
}

func (s *ObjectLiteralItemsContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ObjectLiteralItemsContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ObjectLiteralItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitObjectLiteralItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ObjectLiteralItems() (localctx IObjectLiteralItemsContext) {
	localctx = NewObjectLiteralItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, MojoParserRULE_objectLiteralItems)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1760)
		p.ObjectLiteralItem()
	}
	p.SetState(1772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 229, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1761)
				p.Eov()
			}
			p.SetState(1765)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1762)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1767)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1768)
				p.ObjectLiteralItem()
			}

		}
		p.SetState(1774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 229, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1776)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1775)
			p.Eov()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralItemContext is an interface to support dynamic dispatch.
type IObjectLiteralItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PathIdentifier() IPathIdentifierContext
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsObjectLiteralItemContext differentiates from other interfaces.
	IsObjectLiteralItemContext()
}

type ObjectLiteralItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralItemContext() *ObjectLiteralItemContext {
	var p = new(ObjectLiteralItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_objectLiteralItem
	return p
}

func InitEmptyObjectLiteralItemContext(p *ObjectLiteralItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_objectLiteralItem
}

func (*ObjectLiteralItemContext) IsObjectLiteralItemContext() {}

func NewObjectLiteralItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralItemContext {
	var p = new(ObjectLiteralItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_objectLiteralItem

	return p
}

func (s *ObjectLiteralItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralItemContext) PathIdentifier() IPathIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathIdentifierContext)
}

func (s *ObjectLiteralItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *ObjectLiteralItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ObjectLiteralItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitObjectLiteralItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ObjectLiteralItem() (localctx IObjectLiteralItemContext) {
	localctx = NewObjectLiteralItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, MojoParserRULE_objectLiteralItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1778)
		p.PathIdentifier()
	}
	p.SetState(1781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserCOLON {
		{
			p.SetState(1779)
			p.Match(MojoParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1780)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructLiteralContext is an interface to support dynamic dispatch.
type IStructLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	ObjectLiteral() IObjectLiteralContext

	// IsStructLiteralContext differentiates from other interfaces.
	IsStructLiteralContext()
}

type StructLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructLiteralContext() *StructLiteralContext {
	var p = new(StructLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structLiteral
	return p
}

func InitEmptyStructLiteralContext(p *StructLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structLiteral
}

func (*StructLiteralContext) IsStructLiteralContext() {}

func NewStructLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructLiteralContext {
	var p = new(StructLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_structLiteral

	return p
}

func (s *StructLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StructLiteralContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *StructLiteralContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *StructLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStructLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) StructLiteral() (localctx IStructLiteralContext) {
	localctx = NewStructLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, MojoParserRULE_structLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1783)
		p.TypeIdentifier()
	}
	{
		p.SetState(1784)
		p.ObjectLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructConstructionExpressionContext is an interface to support dynamic dispatch.
type IStructConstructionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	FunctionCallSuffix() IFunctionCallSuffixContext

	// IsStructConstructionExpressionContext differentiates from other interfaces.
	IsStructConstructionExpressionContext()
}

type StructConstructionExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructConstructionExpressionContext() *StructConstructionExpressionContext {
	var p = new(StructConstructionExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structConstructionExpression
	return p
}

func InitEmptyStructConstructionExpressionContext(p *StructConstructionExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_structConstructionExpression
}

func (*StructConstructionExpressionContext) IsStructConstructionExpressionContext() {}

func NewStructConstructionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructConstructionExpressionContext {
	var p = new(StructConstructionExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_structConstructionExpression

	return p
}

func (s *StructConstructionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StructConstructionExpressionContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *StructConstructionExpressionContext) FunctionCallSuffix() IFunctionCallSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallSuffixContext)
}

func (s *StructConstructionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructConstructionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructConstructionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStructConstructionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) StructConstructionExpression() (localctx IStructConstructionExpressionContext) {
	localctx = NewStructConstructionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, MojoParserRULE_structConstructionExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1786)
		p.TypeIdentifier()
	}
	{
		p.SetState(1787)
		p.FunctionCallSuffix()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchExprSuffixContext is an interface to support dynamic dispatch.
type IMatchExprSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_MATCH() antlr.TerminalNode
	LCURLY() antlr.TerminalNode
	RCURLY() antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	MatchExprCases() IMatchExprCasesContext

	// IsMatchExprSuffixContext differentiates from other interfaces.
	IsMatchExprSuffixContext()
}

type MatchExprSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchExprSuffixContext() *MatchExprSuffixContext {
	var p = new(MatchExprSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchExprSuffix
	return p
}

func InitEmptyMatchExprSuffixContext(p *MatchExprSuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchExprSuffix
}

func (*MatchExprSuffixContext) IsMatchExprSuffixContext() {}

func NewMatchExprSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExprSuffixContext {
	var p = new(MatchExprSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_matchExprSuffix

	return p
}

func (s *MatchExprSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExprSuffixContext) KEYWORD_MATCH() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_MATCH, 0)
}

func (s *MatchExprSuffixContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *MatchExprSuffixContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *MatchExprSuffixContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *MatchExprSuffixContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *MatchExprSuffixContext) MatchExprCases() IMatchExprCasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchExprCasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchExprCasesContext)
}

func (s *MatchExprSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExprSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitMatchExprSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) MatchExprSuffix() (localctx IMatchExprSuffixContext) {
	localctx = NewMatchExprSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, MojoParserRULE_matchExprSuffix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1789)
		p.Match(MojoParserKEYWORD_MATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1790)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1796)
		p.Match(MojoParserLCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1804)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext()) == 1 {
		p.SetState(1800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1797)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1802)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1803)
			p.MatchExprCases()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1806)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1812)
		p.Match(MojoParserRCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchExprCasesContext is an interface to support dynamic dispatch.
type IMatchExprCasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMatchExprCase() []IMatchExprCaseContext
	MatchExprCase(i int) IMatchExprCaseContext
	AllEos() []IEosContext
	Eos(i int) IEosContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsMatchExprCasesContext differentiates from other interfaces.
	IsMatchExprCasesContext()
}

type MatchExprCasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchExprCasesContext() *MatchExprCasesContext {
	var p = new(MatchExprCasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchExprCases
	return p
}

func InitEmptyMatchExprCasesContext(p *MatchExprCasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchExprCases
}

func (*MatchExprCasesContext) IsMatchExprCasesContext() {}

func NewMatchExprCasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExprCasesContext {
	var p = new(MatchExprCasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_matchExprCases

	return p
}

func (s *MatchExprCasesContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExprCasesContext) AllMatchExprCase() []IMatchExprCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchExprCaseContext); ok {
			len++
		}
	}

	tst := make([]IMatchExprCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchExprCaseContext); ok {
			tst[i] = t.(IMatchExprCaseContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprCasesContext) MatchExprCase(i int) IMatchExprCaseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchExprCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchExprCaseContext)
}

func (s *MatchExprCasesContext) AllEos() []IEosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEosContext); ok {
			len++
		}
	}

	tst := make([]IEosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEosContext); ok {
			tst[i] = t.(IEosContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprCasesContext) Eos(i int) IEosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *MatchExprCasesContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *MatchExprCasesContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *MatchExprCasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprCasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExprCasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitMatchExprCases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) MatchExprCases() (localctx IMatchExprCasesContext) {
	localctx = NewMatchExprCasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, MojoParserRULE_matchExprCases)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1814)
		p.MatchExprCase()
	}
	p.SetState(1826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1815)
				p.Eos()
			}
			p.SetState(1819)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1816)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1821)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1822)
				p.MatchExprCase()
			}

		}
		p.SetState(1828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1830)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1829)
			p.Eos()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchExprCaseContext is an interface to support dynamic dispatch.
type IMatchExprCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pattern() IPatternContext
	RIGHT_RIGHT_ARROWS() antlr.TerminalNode
	Expression() IExpressionContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsMatchExprCaseContext differentiates from other interfaces.
	IsMatchExprCaseContext()
}

type MatchExprCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchExprCaseContext() *MatchExprCaseContext {
	var p = new(MatchExprCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchExprCase
	return p
}

func InitEmptyMatchExprCaseContext(p *MatchExprCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_matchExprCase
}

func (*MatchExprCaseContext) IsMatchExprCaseContext() {}

func NewMatchExprCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExprCaseContext {
	var p = new(MatchExprCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_matchExprCase

	return p
}

func (s *MatchExprCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExprCaseContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *MatchExprCaseContext) RIGHT_RIGHT_ARROWS() antlr.TerminalNode {
	return s.GetToken(MojoParserRIGHT_RIGHT_ARROWS, 0)
}

func (s *MatchExprCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchExprCaseContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *MatchExprCaseContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *MatchExprCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExprCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitMatchExprCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) MatchExprCase() (localctx IMatchExprCaseContext) {
	localctx = NewMatchExprCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, MojoParserRULE_matchExprCase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1832)
		p.pattern(0)
	}
	p.SetState(1836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1833)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1839)
		p.Match(MojoParserRIGHT_RIGHT_ARROWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1840)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1846)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClosureExpressionContext is an interface to support dynamic dispatch.
type IClosureExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURLY() antlr.TerminalNode
	Statements() IStatementsContext
	RCURLY() antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	ClosureParameters() IClosureParametersContext
	RIGHT_ARROW() antlr.TerminalNode
	Type_() IType_Context

	// IsClosureExpressionContext differentiates from other interfaces.
	IsClosureExpressionContext()
}

type ClosureExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosureExpressionContext() *ClosureExpressionContext {
	var p = new(ClosureExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_closureExpression
	return p
}

func InitEmptyClosureExpressionContext(p *ClosureExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_closureExpression
}

func (*ClosureExpressionContext) IsClosureExpressionContext() {}

func NewClosureExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosureExpressionContext {
	var p = new(ClosureExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_closureExpression

	return p
}

func (s *ClosureExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosureExpressionContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *ClosureExpressionContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *ClosureExpressionContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *ClosureExpressionContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ClosureExpressionContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ClosureExpressionContext) ClosureParameters() IClosureParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureParametersContext)
}

func (s *ClosureExpressionContext) RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(MojoParserRIGHT_ARROW, 0)
}

func (s *ClosureExpressionContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ClosureExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosureExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitClosureExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ClosureExpression() (localctx IClosureExpressionContext) {
	localctx = NewClosureExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, MojoParserRULE_closureExpression)
	var _la int

	p.SetState(1891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 247, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1848)
			p.Match(MojoParserLCURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1849)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1854)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1855)
			p.Statements()
		}
		p.SetState(1859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1856)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1861)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1862)
			p.Match(MojoParserRCURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1864)
			p.Match(MojoParserLCURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1865)
			p.ClosureParameters()
		}
		p.SetState(1869)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1866)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1871)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1872)
			p.Match(MojoParserRIGHT_ARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1880)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext()) == 1 {
			p.SetState(1876)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1873)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1878)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1879)
				p.type_(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1882)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1887)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1888)
			p.Statements()
		}
		{
			p.SetState(1889)
			p.Match(MojoParserRCURLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClosureParametersContext is an interface to support dynamic dispatch.
type IClosureParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClosureParameter() []IClosureParameterContext
	ClosureParameter(i int) IClosureParameterContext
	AllEov() []IEovContext
	Eov(i int) IEovContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsClosureParametersContext differentiates from other interfaces.
	IsClosureParametersContext()
}

type ClosureParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosureParametersContext() *ClosureParametersContext {
	var p = new(ClosureParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_closureParameters
	return p
}

func InitEmptyClosureParametersContext(p *ClosureParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_closureParameters
}

func (*ClosureParametersContext) IsClosureParametersContext() {}

func NewClosureParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosureParametersContext {
	var p = new(ClosureParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_closureParameters

	return p
}

func (s *ClosureParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosureParametersContext) AllClosureParameter() []IClosureParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClosureParameterContext); ok {
			len++
		}
	}

	tst := make([]IClosureParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClosureParameterContext); ok {
			tst[i] = t.(IClosureParameterContext)
			i++
		}
	}

	return tst
}

func (s *ClosureParametersContext) ClosureParameter(i int) IClosureParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureParameterContext)
}

func (s *ClosureParametersContext) AllEov() []IEovContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovContext); ok {
			len++
		}
	}

	tst := make([]IEovContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovContext); ok {
			tst[i] = t.(IEovContext)
			i++
		}
	}

	return tst
}

func (s *ClosureParametersContext) Eov(i int) IEovContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovContext)
}

func (s *ClosureParametersContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ClosureParametersContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ClosureParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosureParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitClosureParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ClosureParameters() (localctx IClosureParametersContext) {
	localctx = NewClosureParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, MojoParserRULE_closureParameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1893)
		p.ClosureParameter()
	}
	p.SetState(1905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1894)
				p.Eov()
			}
			p.SetState(1898)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(1895)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1900)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1901)
				p.ClosureParameter()
			}

		}
		p.SetState(1907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1909)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 250, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1908)
			p.Eov()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClosureParameterContext is an interface to support dynamic dispatch.
type IClosureParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionParameter() IFunctionParameterContext
	LabelIdentifier() ILabelIdentifierContext

	// IsClosureParameterContext differentiates from other interfaces.
	IsClosureParameterContext()
}

type ClosureParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosureParameterContext() *ClosureParameterContext {
	var p = new(ClosureParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_closureParameter
	return p
}

func InitEmptyClosureParameterContext(p *ClosureParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_closureParameter
}

func (*ClosureParameterContext) IsClosureParameterContext() {}

func NewClosureParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosureParameterContext {
	var p = new(ClosureParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_closureParameter

	return p
}

func (s *ClosureParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosureParameterContext) FunctionParameter() IFunctionParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterContext)
}

func (s *ClosureParameterContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *ClosureParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosureParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitClosureParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ClosureParameter() (localctx IClosureParameterContext) {
	localctx = NewClosureParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, MojoParserRULE_closureParameter)
	p.SetState(1913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 251, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1911)
			p.FunctionParameter()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1912)
			p.LabelIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplicitMemberExpressionContext is an interface to support dynamic dispatch.
type IImplicitMemberExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	LabelIdentifier() ILabelIdentifierContext

	// IsImplicitMemberExpressionContext differentiates from other interfaces.
	IsImplicitMemberExpressionContext()
}

type ImplicitMemberExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplicitMemberExpressionContext() *ImplicitMemberExpressionContext {
	var p = new(ImplicitMemberExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_implicitMemberExpression
	return p
}

func InitEmptyImplicitMemberExpressionContext(p *ImplicitMemberExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_implicitMemberExpression
}

func (*ImplicitMemberExpressionContext) IsImplicitMemberExpressionContext() {}

func NewImplicitMemberExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplicitMemberExpressionContext {
	var p = new(ImplicitMemberExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_implicitMemberExpression

	return p
}

func (s *ImplicitMemberExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplicitMemberExpressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, 0)
}

func (s *ImplicitMemberExpressionContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *ImplicitMemberExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplicitMemberExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplicitMemberExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitImplicitMemberExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ImplicitMemberExpression() (localctx IImplicitMemberExpressionContext) {
	localctx = NewImplicitMemberExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, MojoParserRULE_implicitMemberExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1915)
		p.Match(MojoParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1916)
		p.LabelIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsParenthesizedExpressionContext differentiates from other interfaces.
	IsParenthesizedExpressionContext()
}

type ParenthesizedExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExpressionContext() *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_parenthesizedExpression
	return p
}

func InitEmptyParenthesizedExpressionContext(p *ParenthesizedExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_parenthesizedExpression
}

func (*ParenthesizedExpressionContext) IsParenthesizedExpressionContext() {}

func NewParenthesizedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_parenthesizedExpression

	return p
}

func (s *ParenthesizedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserLPAREN, 0)
}

func (s *ParenthesizedExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserRPAREN, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *ParenthesizedExpressionContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ParenthesizedExpression() (localctx IParenthesizedExpressionContext) {
	localctx = NewParenthesizedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, MojoParserRULE_parenthesizedExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1918)
		p.Match(MojoParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1919)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	{
		p.SetState(1925)
		p.Expression()
	}

	p.SetState(1929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(1926)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1932)
		p.Match(MojoParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleLiteralExpressionContext is an interface to support dynamic dispatch.
type ITupleLiteralExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllTupleElement() []ITupleElementContext
	TupleElement(i int) ITupleElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTupleLiteralExpressionContext differentiates from other interfaces.
	IsTupleLiteralExpressionContext()
}

type TupleLiteralExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleLiteralExpressionContext() *TupleLiteralExpressionContext {
	var p = new(TupleLiteralExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tupleLiteralExpression
	return p
}

func InitEmptyTupleLiteralExpressionContext(p *TupleLiteralExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tupleLiteralExpression
}

func (*TupleLiteralExpressionContext) IsTupleLiteralExpressionContext() {}

func NewTupleLiteralExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleLiteralExpressionContext {
	var p = new(TupleLiteralExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_tupleLiteralExpression

	return p
}

func (s *TupleLiteralExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleLiteralExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserLPAREN, 0)
}

func (s *TupleLiteralExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserRPAREN, 0)
}

func (s *TupleLiteralExpressionContext) AllTupleElement() []ITupleElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITupleElementContext); ok {
			len++
		}
	}

	tst := make([]ITupleElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITupleElementContext); ok {
			tst[i] = t.(ITupleElementContext)
			i++
		}
	}

	return tst
}

func (s *TupleLiteralExpressionContext) TupleElement(i int) ITupleElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleElementContext)
}

func (s *TupleLiteralExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MojoParserCOMMA)
}

func (s *TupleLiteralExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserCOMMA, i)
}

func (s *TupleLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleLiteralExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTupleLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TupleLiteralExpression() (localctx ITupleLiteralExpressionContext) {
	localctx = NewTupleLiteralExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, MojoParserRULE_tupleLiteralExpression)
	var _la int

	p.SetState(1946)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1934)
			p.Match(MojoParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1935)
			p.Match(MojoParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1936)
			p.Match(MojoParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1937)
			p.TupleElement()
		}
		p.SetState(1940)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MojoParserCOMMA {
			{
				p.SetState(1938)
				p.Match(MojoParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1939)
				p.TupleElement()
			}

			p.SetState(1942)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1944)
			p.Match(MojoParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleElementContext is an interface to support dynamic dispatch.
type ITupleElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	LabelIdentifier() ILabelIdentifierContext
	COLON() antlr.TerminalNode
	ELLIPSIS() antlr.TerminalNode

	// IsTupleElementContext differentiates from other interfaces.
	IsTupleElementContext()
}

type TupleElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleElementContext() *TupleElementContext {
	var p = new(TupleElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tupleElement
	return p
}

func InitEmptyTupleElementContext(p *TupleElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tupleElement
}

func (*TupleElementContext) IsTupleElementContext() {}

func NewTupleElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleElementContext {
	var p = new(TupleElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_tupleElement

	return p
}

func (s *TupleElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleElementContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *TupleElementContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *TupleElementContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(MojoParserELLIPSIS, 0)
}

func (s *TupleElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTupleElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TupleElement() (localctx ITupleElementContext) {
	localctx = NewTupleElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, MojoParserRULE_tupleElement)
	p.SetState(1954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1948)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1949)
			p.LabelIdentifier()
		}
		{
			p.SetState(1950)
			p.Match(MojoParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1951)
			p.Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1953)
			p.Match(MojoParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildcardExpressionContext is an interface to support dynamic dispatch.
type IWildcardExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNDERSCORE() antlr.TerminalNode

	// IsWildcardExpressionContext differentiates from other interfaces.
	IsWildcardExpressionContext()
}

type WildcardExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildcardExpressionContext() *WildcardExpressionContext {
	var p = new(WildcardExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_wildcardExpression
	return p
}

func InitEmptyWildcardExpressionContext(p *WildcardExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_wildcardExpression
}

func (*WildcardExpressionContext) IsWildcardExpressionContext() {}

func NewWildcardExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildcardExpressionContext {
	var p = new(WildcardExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_wildcardExpression

	return p
}

func (s *WildcardExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WildcardExpressionContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(MojoParserUNDERSCORE, 0)
}

func (s *WildcardExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildcardExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitWildcardExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) WildcardExpression() (localctx IWildcardExpressionContext) {
	localctx = NewWildcardExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, MojoParserRULE_wildcardExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1956)
		p.Match(MojoParserUNDERSCORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpression() IPrimaryExpressionContext
	AllSuffixExpression() []ISuffixExpressionContext
	SuffixExpression(i int) ISuffixExpressionContext
	PostfixOperator() IPostfixOperatorContext

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_postfixExpression
	return p
}

func InitEmptyPostfixExpressionContext(p *PostfixExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_postfixExpression
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixExpressionContext) AllSuffixExpression() []ISuffixExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISuffixExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISuffixExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISuffixExpressionContext); ok {
			tst[i] = t.(ISuffixExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExpressionContext) SuffixExpression(i int) ISuffixExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuffixExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuffixExpressionContext)
}

func (s *PostfixExpressionContext) PostfixOperator() IPostfixOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixOperatorContext)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPostfixExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PostfixExpression() (localctx IPostfixExpressionContext) {
	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, MojoParserRULE_postfixExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1958)
		p.PrimaryExpression()
	}
	p.SetState(1962)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 257, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1959)
				p.SuffixExpression()
			}

		}
		p.SetState(1964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 257, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1966)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 258, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1965)
			p.PostfixOperator()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuffixExpressionContext is an interface to support dynamic dispatch.
type ISuffixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionCallSuffix() IFunctionCallSuffixContext
	ExplicitMemberSuffix() IExplicitMemberSuffixContext
	SubscriptSuffix() ISubscriptSuffixContext
	MatchExprSuffix() IMatchExprSuffixContext
	TypeCastingOperator() ITypeCastingOperatorContext

	// IsSuffixExpressionContext differentiates from other interfaces.
	IsSuffixExpressionContext()
}

type SuffixExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuffixExpressionContext() *SuffixExpressionContext {
	var p = new(SuffixExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_suffixExpression
	return p
}

func InitEmptySuffixExpressionContext(p *SuffixExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_suffixExpression
}

func (*SuffixExpressionContext) IsSuffixExpressionContext() {}

func NewSuffixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuffixExpressionContext {
	var p = new(SuffixExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_suffixExpression

	return p
}

func (s *SuffixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SuffixExpressionContext) FunctionCallSuffix() IFunctionCallSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallSuffixContext)
}

func (s *SuffixExpressionContext) ExplicitMemberSuffix() IExplicitMemberSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitMemberSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitMemberSuffixContext)
}

func (s *SuffixExpressionContext) SubscriptSuffix() ISubscriptSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubscriptSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubscriptSuffixContext)
}

func (s *SuffixExpressionContext) MatchExprSuffix() IMatchExprSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchExprSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchExprSuffixContext)
}

func (s *SuffixExpressionContext) TypeCastingOperator() ITypeCastingOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCastingOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCastingOperatorContext)
}

func (s *SuffixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuffixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuffixExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitSuffixExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) SuffixExpression() (localctx ISuffixExpressionContext) {
	localctx = NewSuffixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, MojoParserRULE_suffixExpression)
	p.SetState(1973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserLCURLY, MojoParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1968)
			p.FunctionCallSuffix()
		}

	case MojoParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1969)
			p.ExplicitMemberSuffix()
		}

	case MojoParserLBRACK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1970)
			p.SubscriptSuffix()
		}

	case MojoParserKEYWORD_MATCH:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1971)
			p.MatchExprSuffix()
		}

	case MojoParserKEYWORD_AS, MojoParserKEYWORD_IS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1972)
			p.TypeCastingOperator()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplicitMemberSuffixContext is an interface to support dynamic dispatch.
type IExplicitMemberSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	PURE_DECIMAL_DIGITS() antlr.TerminalNode
	Identifier() IIdentifierContext
	GenericArgumentClause() IGenericArgumentClauseContext
	LPAREN() antlr.TerminalNode
	ArgumentNames() IArgumentNamesContext
	RPAREN() antlr.TerminalNode

	// IsExplicitMemberSuffixContext differentiates from other interfaces.
	IsExplicitMemberSuffixContext()
}

type ExplicitMemberSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitMemberSuffixContext() *ExplicitMemberSuffixContext {
	var p = new(ExplicitMemberSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_explicitMemberSuffix
	return p
}

func InitEmptyExplicitMemberSuffixContext(p *ExplicitMemberSuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_explicitMemberSuffix
}

func (*ExplicitMemberSuffixContext) IsExplicitMemberSuffixContext() {}

func NewExplicitMemberSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitMemberSuffixContext {
	var p = new(ExplicitMemberSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_explicitMemberSuffix

	return p
}

func (s *ExplicitMemberSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitMemberSuffixContext) DOT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, 0)
}

func (s *ExplicitMemberSuffixContext) PURE_DECIMAL_DIGITS() antlr.TerminalNode {
	return s.GetToken(MojoParserPURE_DECIMAL_DIGITS, 0)
}

func (s *ExplicitMemberSuffixContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExplicitMemberSuffixContext) GenericArgumentClause() IGenericArgumentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericArgumentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericArgumentClauseContext)
}

func (s *ExplicitMemberSuffixContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserLPAREN, 0)
}

func (s *ExplicitMemberSuffixContext) ArgumentNames() IArgumentNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentNamesContext)
}

func (s *ExplicitMemberSuffixContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserRPAREN, 0)
}

func (s *ExplicitMemberSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitMemberSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitMemberSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitExplicitMemberSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ExplicitMemberSuffix() (localctx IExplicitMemberSuffixContext) {
	localctx = NewExplicitMemberSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, MojoParserRULE_explicitMemberSuffix)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1975)
		p.Match(MojoParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserPURE_DECIMAL_DIGITS:
		{
			p.SetState(1976)
			p.Match(MojoParserPURE_DECIMAL_DIGITS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MojoParserVALUE_IDENTIFIER, MojoParserIMPLICIT_PARAMETER_NAME:
		{
			p.SetState(1977)
			p.Identifier()
		}
		p.SetState(1983)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1978)
				p.GenericArgumentClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1979)
				p.Match(MojoParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1980)
				p.ArgumentNames()
			}
			{
				p.SetState(1981)
				p.Match(MojoParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubscriptSuffixContext is an interface to support dynamic dispatch.
type ISubscriptSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	FunctionCallArguments() IFunctionCallArgumentsContext
	RBRACK() antlr.TerminalNode

	// IsSubscriptSuffixContext differentiates from other interfaces.
	IsSubscriptSuffixContext()
}

type SubscriptSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptSuffixContext() *SubscriptSuffixContext {
	var p = new(SubscriptSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_subscriptSuffix
	return p
}

func InitEmptySubscriptSuffixContext(p *SubscriptSuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_subscriptSuffix
}

func (*SubscriptSuffixContext) IsSubscriptSuffixContext() {}

func NewSubscriptSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptSuffixContext {
	var p = new(SubscriptSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_subscriptSuffix

	return p
}

func (s *SubscriptSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptSuffixContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(MojoParserLBRACK, 0)
}

func (s *SubscriptSuffixContext) FunctionCallArguments() IFunctionCallArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallArgumentsContext)
}

func (s *SubscriptSuffixContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(MojoParserRBRACK, 0)
}

func (s *SubscriptSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitSubscriptSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) SubscriptSuffix() (localctx ISubscriptSuffixContext) {
	localctx = NewSubscriptSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, MojoParserRULE_subscriptSuffix)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1987)
		p.Match(MojoParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1988)
		p.FunctionCallArguments()
	}
	{
		p.SetState(1989)
		p.Match(MojoParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallSuffixContext is an interface to support dynamic dispatch.
type IFunctionCallSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TrailingClosures() ITrailingClosuresContext
	FunctionCallArgumentClause() IFunctionCallArgumentClauseContext

	// IsFunctionCallSuffixContext differentiates from other interfaces.
	IsFunctionCallSuffixContext()
}

type FunctionCallSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallSuffixContext() *FunctionCallSuffixContext {
	var p = new(FunctionCallSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionCallSuffix
	return p
}

func InitEmptyFunctionCallSuffixContext(p *FunctionCallSuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionCallSuffix
}

func (*FunctionCallSuffixContext) IsFunctionCallSuffixContext() {}

func NewFunctionCallSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallSuffixContext {
	var p = new(FunctionCallSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionCallSuffix

	return p
}

func (s *FunctionCallSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallSuffixContext) TrailingClosures() ITrailingClosuresContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrailingClosuresContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrailingClosuresContext)
}

func (s *FunctionCallSuffixContext) FunctionCallArgumentClause() IFunctionCallArgumentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallArgumentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallArgumentClauseContext)
}

func (s *FunctionCallSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionCallSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionCallSuffix() (localctx IFunctionCallSuffixContext) {
	localctx = NewFunctionCallSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, MojoParserRULE_functionCallSuffix)
	var _la int

	p.SetState(1996)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1992)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserLPAREN {
			{
				p.SetState(1991)
				p.FunctionCallArgumentClause()
			}

		}
		{
			p.SetState(1994)
			p.TrailingClosures()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1995)
			p.FunctionCallArgumentClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallArgumentClauseContext is an interface to support dynamic dispatch.
type IFunctionCallArgumentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode
	FunctionCallArguments() IFunctionCallArgumentsContext

	// IsFunctionCallArgumentClauseContext differentiates from other interfaces.
	IsFunctionCallArgumentClauseContext()
}

type FunctionCallArgumentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallArgumentClauseContext() *FunctionCallArgumentClauseContext {
	var p = new(FunctionCallArgumentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionCallArgumentClause
	return p
}

func InitEmptyFunctionCallArgumentClauseContext(p *FunctionCallArgumentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionCallArgumentClause
}

func (*FunctionCallArgumentClauseContext) IsFunctionCallArgumentClauseContext() {}

func NewFunctionCallArgumentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallArgumentClauseContext {
	var p = new(FunctionCallArgumentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionCallArgumentClause

	return p
}

func (s *FunctionCallArgumentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallArgumentClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserLPAREN, 0)
}

func (s *FunctionCallArgumentClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserRPAREN, 0)
}

func (s *FunctionCallArgumentClauseContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *FunctionCallArgumentClauseContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *FunctionCallArgumentClauseContext) FunctionCallArguments() IFunctionCallArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallArgumentsContext)
}

func (s *FunctionCallArgumentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallArgumentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallArgumentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionCallArgumentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionCallArgumentClause() (localctx IFunctionCallArgumentClauseContext) {
	localctx = NewFunctionCallArgumentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, MojoParserRULE_functionCallArgumentClause)
	var _la int

	p.SetState(2022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1998)
			p.Match(MojoParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(1999)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2004)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2005)
			p.Match(MojoParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2006)
			p.Match(MojoParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2010)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(2007)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2012)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2013)
			p.FunctionCallArguments()
		}
		p.SetState(2017)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(2014)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2019)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2020)
			p.Match(MojoParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallArgumentsContext is an interface to support dynamic dispatch.
type IFunctionCallArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionCallArgument() []IFunctionCallArgumentContext
	FunctionCallArgument(i int) IFunctionCallArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionCallArgumentsContext differentiates from other interfaces.
	IsFunctionCallArgumentsContext()
}

type FunctionCallArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallArgumentsContext() *FunctionCallArgumentsContext {
	var p = new(FunctionCallArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionCallArguments
	return p
}

func InitEmptyFunctionCallArgumentsContext(p *FunctionCallArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionCallArguments
}

func (*FunctionCallArgumentsContext) IsFunctionCallArgumentsContext() {}

func NewFunctionCallArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallArgumentsContext {
	var p = new(FunctionCallArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionCallArguments

	return p
}

func (s *FunctionCallArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallArgumentsContext) AllFunctionCallArgument() []IFunctionCallArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionCallArgumentContext); ok {
			len++
		}
	}

	tst := make([]IFunctionCallArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionCallArgumentContext); ok {
			tst[i] = t.(IFunctionCallArgumentContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallArgumentsContext) FunctionCallArgument(i int) IFunctionCallArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallArgumentContext)
}

func (s *FunctionCallArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MojoParserCOMMA)
}

func (s *FunctionCallArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserCOMMA, i)
}

func (s *FunctionCallArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionCallArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionCallArguments() (localctx IFunctionCallArgumentsContext) {
	localctx = NewFunctionCallArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, MojoParserRULE_functionCallArguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2024)
		p.FunctionCallArgument()
	}
	p.SetState(2029)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserCOMMA {
		{
			p.SetState(2025)
			p.Match(MojoParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2026)
			p.FunctionCallArgument()
		}

		p.SetState(2031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallArgumentContext is an interface to support dynamic dispatch.
type IFunctionCallArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	LabelIdentifier() ILabelIdentifierContext
	COLON() antlr.TerminalNode

	// IsFunctionCallArgumentContext differentiates from other interfaces.
	IsFunctionCallArgumentContext()
}

type FunctionCallArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallArgumentContext() *FunctionCallArgumentContext {
	var p = new(FunctionCallArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionCallArgument
	return p
}

func InitEmptyFunctionCallArgumentContext(p *FunctionCallArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionCallArgument
}

func (*FunctionCallArgumentContext) IsFunctionCallArgumentContext() {}

func NewFunctionCallArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallArgumentContext {
	var p = new(FunctionCallArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionCallArgument

	return p
}

func (s *FunctionCallArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallArgumentContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *FunctionCallArgumentContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *FunctionCallArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionCallArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionCallArgument() (localctx IFunctionCallArgumentContext) {
	localctx = NewFunctionCallArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, MojoParserRULE_functionCallArgument)
	p.SetState(2037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 269, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2032)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2033)
			p.LabelIdentifier()
		}
		{
			p.SetState(2034)
			p.Match(MojoParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2035)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrailingClosuresContext is an interface to support dynamic dispatch.
type ITrailingClosuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClosureExpression() IClosureExpressionContext
	LabeledTrailingClosures() ILabeledTrailingClosuresContext

	// IsTrailingClosuresContext differentiates from other interfaces.
	IsTrailingClosuresContext()
}

type TrailingClosuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailingClosuresContext() *TrailingClosuresContext {
	var p = new(TrailingClosuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_trailingClosures
	return p
}

func InitEmptyTrailingClosuresContext(p *TrailingClosuresContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_trailingClosures
}

func (*TrailingClosuresContext) IsTrailingClosuresContext() {}

func NewTrailingClosuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailingClosuresContext {
	var p = new(TrailingClosuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_trailingClosures

	return p
}

func (s *TrailingClosuresContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailingClosuresContext) ClosureExpression() IClosureExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureExpressionContext)
}

func (s *TrailingClosuresContext) LabeledTrailingClosures() ILabeledTrailingClosuresContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledTrailingClosuresContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledTrailingClosuresContext)
}

func (s *TrailingClosuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailingClosuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrailingClosuresContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTrailingClosures(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TrailingClosures() (localctx ITrailingClosuresContext) {
	localctx = NewTrailingClosuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, MojoParserRULE_trailingClosures)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2039)
		p.ClosureExpression()
	}
	p.SetState(2041)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2040)
			p.LabeledTrailingClosures()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabeledTrailingClosuresContext is an interface to support dynamic dispatch.
type ILabeledTrailingClosuresContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabeledTrailingClosure() []ILabeledTrailingClosureContext
	LabeledTrailingClosure(i int) ILabeledTrailingClosureContext

	// IsLabeledTrailingClosuresContext differentiates from other interfaces.
	IsLabeledTrailingClosuresContext()
}

type LabeledTrailingClosuresContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledTrailingClosuresContext() *LabeledTrailingClosuresContext {
	var p = new(LabeledTrailingClosuresContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_labeledTrailingClosures
	return p
}

func InitEmptyLabeledTrailingClosuresContext(p *LabeledTrailingClosuresContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_labeledTrailingClosures
}

func (*LabeledTrailingClosuresContext) IsLabeledTrailingClosuresContext() {}

func NewLabeledTrailingClosuresContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledTrailingClosuresContext {
	var p = new(LabeledTrailingClosuresContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_labeledTrailingClosures

	return p
}

func (s *LabeledTrailingClosuresContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledTrailingClosuresContext) AllLabeledTrailingClosure() []ILabeledTrailingClosureContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabeledTrailingClosureContext); ok {
			len++
		}
	}

	tst := make([]ILabeledTrailingClosureContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabeledTrailingClosureContext); ok {
			tst[i] = t.(ILabeledTrailingClosureContext)
			i++
		}
	}

	return tst
}

func (s *LabeledTrailingClosuresContext) LabeledTrailingClosure(i int) ILabeledTrailingClosureContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledTrailingClosureContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledTrailingClosureContext)
}

func (s *LabeledTrailingClosuresContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledTrailingClosuresContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledTrailingClosuresContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitLabeledTrailingClosures(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) LabeledTrailingClosures() (localctx ILabeledTrailingClosuresContext) {
	localctx = NewLabeledTrailingClosuresContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, MojoParserRULE_labeledTrailingClosures)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2043)
				p.LabeledTrailingClosure()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2046)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabeledTrailingClosureContext is an interface to support dynamic dispatch.
type ILabeledTrailingClosureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	ClosureExpression() IClosureExpressionContext

	// IsLabeledTrailingClosureContext differentiates from other interfaces.
	IsLabeledTrailingClosureContext()
}

type LabeledTrailingClosureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledTrailingClosureContext() *LabeledTrailingClosureContext {
	var p = new(LabeledTrailingClosureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_labeledTrailingClosure
	return p
}

func InitEmptyLabeledTrailingClosureContext(p *LabeledTrailingClosureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_labeledTrailingClosure
}

func (*LabeledTrailingClosureContext) IsLabeledTrailingClosureContext() {}

func NewLabeledTrailingClosureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledTrailingClosureContext {
	var p = new(LabeledTrailingClosureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_labeledTrailingClosure

	return p
}

func (s *LabeledTrailingClosureContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledTrailingClosureContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabeledTrailingClosureContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *LabeledTrailingClosureContext) ClosureExpression() IClosureExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosureExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosureExpressionContext)
}

func (s *LabeledTrailingClosureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledTrailingClosureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledTrailingClosureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitLabeledTrailingClosure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) LabeledTrailingClosure() (localctx ILabeledTrailingClosureContext) {
	localctx = NewLabeledTrailingClosureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, MojoParserRULE_labeledTrailingClosure)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2048)
		p.Identifier()
	}
	{
		p.SetState(2049)
		p.Match(MojoParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2050)
		p.ClosureExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentNamesContext is an interface to support dynamic dispatch.
type IArgumentNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgumentName() []IArgumentNameContext
	ArgumentName(i int) IArgumentNameContext

	// IsArgumentNamesContext differentiates from other interfaces.
	IsArgumentNamesContext()
}

type ArgumentNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentNamesContext() *ArgumentNamesContext {
	var p = new(ArgumentNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_argumentNames
	return p
}

func InitEmptyArgumentNamesContext(p *ArgumentNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_argumentNames
}

func (*ArgumentNamesContext) IsArgumentNamesContext() {}

func NewArgumentNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentNamesContext {
	var p = new(ArgumentNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_argumentNames

	return p
}

func (s *ArgumentNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentNamesContext) AllArgumentName() []IArgumentNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentNameContext); ok {
			len++
		}
	}

	tst := make([]IArgumentNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentNameContext); ok {
			tst[i] = t.(IArgumentNameContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentNamesContext) ArgumentName(i int) IArgumentNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentNameContext)
}

func (s *ArgumentNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitArgumentNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ArgumentNames() (localctx IArgumentNamesContext) {
	localctx = NewArgumentNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, MojoParserRULE_argumentNames)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2052)
		p.ArgumentName()
	}
	p.SetState(2056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&536866814) != 0) || _la == MojoParserVALUE_IDENTIFIER {
		{
			p.SetState(2053)
			p.ArgumentName()
		}

		p.SetState(2058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentNameContext is an interface to support dynamic dispatch.
type IArgumentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelIdentifier() ILabelIdentifierContext
	COLON() antlr.TerminalNode

	// IsArgumentNameContext differentiates from other interfaces.
	IsArgumentNameContext()
}

type ArgumentNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentNameContext() *ArgumentNameContext {
	var p = new(ArgumentNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_argumentName
	return p
}

func InitEmptyArgumentNameContext(p *ArgumentNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_argumentName
}

func (*ArgumentNameContext) IsArgumentNameContext() {}

func NewArgumentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentNameContext {
	var p = new(ArgumentNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_argumentName

	return p
}

func (s *ArgumentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentNameContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *ArgumentNameContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *ArgumentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitArgumentName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ArgumentName() (localctx IArgumentNameContext) {
	localctx = NewArgumentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, MojoParserRULE_argumentName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2059)
		p.LabelIdentifier()
	}
	{
		p.SetState(2060)
		p.Match(MojoParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BasicType() IBasicTypeContext
	FunctionType() IFunctionTypeContext
	Type_() IType_Context
	BANG() antlr.TerminalNode
	QUESTION() antlr.TerminalNode
	STAR() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	ELLIPSIS() antlr.TerminalNode

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_type_
	return p
}

func InitEmptyType_Context(p *Type_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_type_
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) BasicType() IBasicTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasicTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasicTypeContext)
}

func (s *Type_Context) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *Type_Context) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *Type_Context) BANG() antlr.TerminalNode {
	return s.GetToken(MojoParserBANG, 0)
}

func (s *Type_Context) QUESTION() antlr.TerminalNode {
	return s.GetToken(MojoParserQUESTION, 0)
}

func (s *Type_Context) STAR() antlr.TerminalNode {
	return s.GetToken(MojoParserSTAR, 0)
}

func (s *Type_Context) PLUS() antlr.TerminalNode {
	return s.GetToken(MojoParserPLUS, 0)
}

func (s *Type_Context) MINUS() antlr.TerminalNode {
	return s.GetToken(MojoParserMINUS, 0)
}

func (s *Type_Context) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(MojoParserELLIPSIS, 0)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitType_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Type_() (localctx IType_Context) {
	return p.type_(0)
}

func (p *MojoParser) type_(_p int) (localctx IType_Context) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewType_Context(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IType_Context = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 292
	p.EnterRecursionRule(localctx, 292, MojoParserRULE_type_, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2065)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 273, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2063)
			p.basicType(0)
		}

	case 2:
		{
			p.SetState(2064)
			p.FunctionType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2079)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext()) {
			case 1:
				localctx = NewType_Context(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MojoParserRULE_type_)
				p.SetState(2067)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(2068)
					p.Match(MojoParserBANG)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewType_Context(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MojoParserRULE_type_)
				p.SetState(2069)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(2070)
					p.Match(MojoParserQUESTION)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:
				localctx = NewType_Context(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MojoParserRULE_type_)
				p.SetState(2071)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(2072)
					p.Match(MojoParserSTAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 4:
				localctx = NewType_Context(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MojoParserRULE_type_)
				p.SetState(2073)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(2074)
					p.Match(MojoParserPLUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 5:
				localctx = NewType_Context(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MojoParserRULE_type_)
				p.SetState(2075)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(2076)
					p.Match(MojoParserMINUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 6:
				localctx = NewType_Context(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MojoParserRULE_type_)
				p.SetState(2077)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(2078)
					p.Match(MojoParserELLIPSIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBasicTypeContext is an interface to support dynamic dispatch.
type IBasicTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBasicTypeContext differentiates from other interfaces.
	IsBasicTypeContext()
}

type BasicTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasicTypeContext() *BasicTypeContext {
	var p = new(BasicTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_basicType
	return p
}

func InitEmptyBasicTypeContext(p *BasicTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_basicType
}

func (*BasicTypeContext) IsBasicTypeContext() {}

func NewBasicTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasicTypeContext {
	var p = new(BasicTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_basicType

	return p
}

func (s *BasicTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BasicTypeContext) CopyAll(ctx *BasicTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BasicTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IntersectionContext struct {
	BasicTypeContext
}

func NewIntersectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntersectionContext {
	var p = new(IntersectionContext)

	InitEmptyBasicTypeContext(&p.BasicTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*BasicTypeContext))

	return p
}

func (s *IntersectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionContext) AllBasicType() []IBasicTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBasicTypeContext); ok {
			len++
		}
	}

	tst := make([]IBasicTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBasicTypeContext); ok {
			tst[i] = t.(IBasicTypeContext)
			i++
		}
	}

	return tst
}

func (s *IntersectionContext) BasicType(i int) IBasicTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasicTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasicTypeContext)
}

func (s *IntersectionContext) AND() antlr.TerminalNode {
	return s.GetToken(MojoParserAND, 0)
}

func (s *IntersectionContext) AllAttributes() []IAttributesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributesContext); ok {
			len++
		}
	}

	tst := make([]IAttributesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributesContext); ok {
			tst[i] = t.(IAttributesContext)
			i++
		}
	}

	return tst
}

func (s *IntersectionContext) Attributes(i int) IAttributesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *IntersectionContext) AllFollowingDocument() []IFollowingDocumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			len++
		}
	}

	tst := make([]IFollowingDocumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFollowingDocumentContext); ok {
			tst[i] = t.(IFollowingDocumentContext)
			i++
		}
	}

	return tst
}

func (s *IntersectionContext) FollowingDocument(i int) IFollowingDocumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *IntersectionContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *IntersectionContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *IntersectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitIntersection(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimeContext struct {
	BasicTypeContext
}

func NewPrimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimeContext {
	var p = new(PrimeContext)

	InitEmptyBasicTypeContext(&p.BasicTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*BasicTypeContext))

	return p
}

func (s *PrimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimeContext) PrimeType() IPrimeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimeTypeContext)
}

func (s *PrimeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPrime(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnionContext struct {
	BasicTypeContext
}

func NewUnionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionContext {
	var p = new(UnionContext)

	InitEmptyBasicTypeContext(&p.BasicTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*BasicTypeContext))

	return p
}

func (s *UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionContext) AllBasicType() []IBasicTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBasicTypeContext); ok {
			len++
		}
	}

	tst := make([]IBasicTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBasicTypeContext); ok {
			tst[i] = t.(IBasicTypeContext)
			i++
		}
	}

	return tst
}

func (s *UnionContext) BasicType(i int) IBasicTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasicTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasicTypeContext)
}

func (s *UnionContext) PIPE() antlr.TerminalNode {
	return s.GetToken(MojoParserPIPE, 0)
}

func (s *UnionContext) AllAttributes() []IAttributesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributesContext); ok {
			len++
		}
	}

	tst := make([]IAttributesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributesContext); ok {
			tst[i] = t.(IAttributesContext)
			i++
		}
	}

	return tst
}

func (s *UnionContext) Attributes(i int) IAttributesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *UnionContext) AllFollowingDocument() []IFollowingDocumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			len++
		}
	}

	tst := make([]IFollowingDocumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFollowingDocumentContext); ok {
			tst[i] = t.(IFollowingDocumentContext)
			i++
		}
	}

	return tst
}

func (s *UnionContext) FollowingDocument(i int) IFollowingDocumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *UnionContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *UnionContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *UnionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitUnion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) BasicType() (localctx IBasicTypeContext) {
	return p.basicType(0)
}

func (p *MojoParser) basicType(_p int) (localctx IBasicTypeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBasicTypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBasicTypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 294
	p.EnterRecursionRule(localctx, 294, MojoParserRULE_basicType, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewPrimeContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(2085)
		p.PrimeType()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2151)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2149)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext()) {
			case 1:
				localctx = NewUnionContext(p, NewBasicTypeContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MojoParserRULE_basicType)
				p.SetState(2087)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				p.SetState(2089)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MojoParserAT {
					{
						p.SetState(2088)
						p.Attributes()
					}

				}
				p.SetState(2094)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MojoParserFOLLOWING_LINE_DOCUMENT {
					{
						p.SetState(2091)
						p.FollowingDocument()
					}
					{
						p.SetState(2092)
						p.Match(MojoParserEOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2099)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MojoParserEOL {
					{
						p.SetState(2096)
						p.Match(MojoParserEOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(2101)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2102)
					p.Match(MojoParserPIPE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2106)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MojoParserEOL {
					{
						p.SetState(2103)
						p.Match(MojoParserEOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(2108)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2109)
					p.basicType(0)
				}
				p.SetState(2111)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 280, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(2110)
						p.Attributes()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				p.SetState(2116)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 281, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(2113)
						p.FollowingDocument()
					}
					{
						p.SetState(2114)
						p.Match(MojoParserEOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case 2:
				localctx = NewIntersectionContext(p, NewBasicTypeContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MojoParserRULE_basicType)
				p.SetState(2118)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				p.SetState(2120)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MojoParserAT {
					{
						p.SetState(2119)
						p.Attributes()
					}

				}
				p.SetState(2125)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MojoParserFOLLOWING_LINE_DOCUMENT {
					{
						p.SetState(2122)
						p.FollowingDocument()
					}
					{
						p.SetState(2123)
						p.Match(MojoParserEOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2130)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MojoParserEOL {
					{
						p.SetState(2127)
						p.Match(MojoParserEOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(2132)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2133)
					p.Match(MojoParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2137)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MojoParserEOL {
					{
						p.SetState(2134)
						p.Match(MojoParserEOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(2139)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2140)
					p.basicType(0)
				}
				p.SetState(2142)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(2141)
						p.Attributes()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				p.SetState(2147)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(2144)
						p.FollowingDocument()
					}
					{
						p.SetState(2145)
						p.Match(MojoParserEOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimeTypeContext is an interface to support dynamic dispatch.
type IPrimeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayType() IArrayTypeContext
	MapType() IMapTypeContext
	TupleType() ITupleTypeContext
	TypeIdentifier() ITypeIdentifierContext

	// IsPrimeTypeContext differentiates from other interfaces.
	IsPrimeTypeContext()
}

type PrimeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimeTypeContext() *PrimeTypeContext {
	var p = new(PrimeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_primeType
	return p
}

func InitEmptyPrimeTypeContext(p *PrimeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_primeType
}

func (*PrimeTypeContext) IsPrimeTypeContext() {}

func NewPrimeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimeTypeContext {
	var p = new(PrimeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_primeType

	return p
}

func (s *PrimeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimeTypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *PrimeTypeContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *PrimeTypeContext) TupleType() ITupleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeContext)
}

func (s *PrimeTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PrimeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPrimeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PrimeType() (localctx IPrimeTypeContext) {
	localctx = NewPrimeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, MojoParserRULE_primeType)
	p.SetState(2158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserLBRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2154)
			p.ArrayType()
		}

	case MojoParserLCURLY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2155)
			p.MapType()
		}

	case MojoParserLPAREN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2156)
			p.TupleType()
		}

	case MojoParserTYPE_IDENTIFIER, MojoParserVALUE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2157)
			p.TypeIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAnnotationContext is an interface to support dynamic dispatch.
type ITypeAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context
	COLON() antlr.TerminalNode
	Attributes() IAttributesContext

	// IsTypeAnnotationContext differentiates from other interfaces.
	IsTypeAnnotationContext()
}

type TypeAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAnnotationContext() *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeAnnotation
	return p
}

func InitEmptyTypeAnnotationContext(p *TypeAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeAnnotation
}

func (*TypeAnnotationContext) IsTypeAnnotationContext() {}

func NewTypeAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_typeAnnotation

	return p
}

func (s *TypeAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAnnotationContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeAnnotationContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *TypeAnnotationContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *TypeAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTypeAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TypeAnnotation() (localctx ITypeAnnotationContext) {
	localctx = NewTypeAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, MojoParserRULE_typeAnnotation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2161)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserCOLON {
		{
			p.SetState(2160)
			p.Match(MojoParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2163)
		p.type_(0)
	}
	p.SetState(2165)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2164)
			p.Attributes()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdentifierContext is an interface to support dynamic dispatch.
type ITypeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeIdentifierClause() []ITypeIdentifierClauseContext
	TypeIdentifierClause(i int) ITypeIdentifierClauseContext
	PackageIdentifier() IPackageIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsTypeIdentifierContext differentiates from other interfaces.
	IsTypeIdentifierContext()
}

type TypeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdentifierContext() *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeIdentifier
	return p
}

func InitEmptyTypeIdentifierContext(p *TypeIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeIdentifier
}

func (*TypeIdentifierContext) IsTypeIdentifierContext() {}

func NewTypeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_typeIdentifier

	return p
}

func (s *TypeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdentifierContext) AllTypeIdentifierClause() []ITypeIdentifierClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeIdentifierClauseContext); ok {
			len++
		}
	}

	tst := make([]ITypeIdentifierClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeIdentifierClauseContext); ok {
			tst[i] = t.(ITypeIdentifierClauseContext)
			i++
		}
	}

	return tst
}

func (s *TypeIdentifierContext) TypeIdentifierClause(i int) ITypeIdentifierClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierClauseContext)
}

func (s *TypeIdentifierContext) PackageIdentifier() IPackageIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageIdentifierContext)
}

func (s *TypeIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(MojoParserDOT)
}

func (s *TypeIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, i)
}

func (s *TypeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTypeIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TypeIdentifier() (localctx ITypeIdentifierContext) {
	localctx = NewTypeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, MojoParserRULE_typeIdentifier)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserVALUE_IDENTIFIER {
		{
			p.SetState(2167)
			p.PackageIdentifier()
		}
		{
			p.SetState(2168)
			p.Match(MojoParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2172)
		p.TypeIdentifierClause()
	}
	p.SetState(2177)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2173)
				p.Match(MojoParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2174)
				p.TypeIdentifierClause()
			}

		}
		p.SetState(2179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdentifierClauseContext is an interface to support dynamic dispatch.
type ITypeIdentifierClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	GenericArgumentClause() IGenericArgumentClauseContext

	// IsTypeIdentifierClauseContext differentiates from other interfaces.
	IsTypeIdentifierClauseContext()
}

type TypeIdentifierClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdentifierClauseContext() *TypeIdentifierClauseContext {
	var p = new(TypeIdentifierClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeIdentifierClause
	return p
}

func InitEmptyTypeIdentifierClauseContext(p *TypeIdentifierClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeIdentifierClause
}

func (*TypeIdentifierClauseContext) IsTypeIdentifierClauseContext() {}

func NewTypeIdentifierClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdentifierClauseContext {
	var p = new(TypeIdentifierClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_typeIdentifierClause

	return p
}

func (s *TypeIdentifierClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdentifierClauseContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *TypeIdentifierClauseContext) GenericArgumentClause() IGenericArgumentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericArgumentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericArgumentClauseContext)
}

func (s *TypeIdentifierClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdentifierClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdentifierClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTypeIdentifierClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TypeIdentifierClause() (localctx ITypeIdentifierClauseContext) {
	localctx = NewTypeIdentifierClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, MojoParserRULE_typeIdentifierClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2180)
		p.TypeName()
	}
	p.SetState(2182)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2181)
			p.GenericArgumentClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE_IDENTIFIER() antlr.TerminalNode

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) TYPE_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MojoParserTYPE_IDENTIFIER, 0)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TypeName() (localctx ITypeNameContext) {
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, MojoParserRULE_typeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2184)
		p.Match(MojoParserTYPE_IDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TupleTypeElements() ITupleTypeElementsContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tupleType
	return p
}

func InitEmptyTupleTypeContext(p *TupleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tupleType
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserLPAREN, 0)
}

func (s *TupleTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MojoParserRPAREN, 0)
}

func (s *TupleTypeContext) TupleTypeElements() ITupleTypeElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeElementsContext)
}

func (s *TupleTypeContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *TupleTypeContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTupleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TupleType() (localctx ITupleTypeContext) {
	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, MojoParserRULE_tupleType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2186)
		p.Match(MojoParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2194)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) == 1 {
		p.SetState(2190)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MojoParserEOL {
			{
				p.SetState(2187)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2192)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2193)
			p.TupleTypeElements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2199)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(2196)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2201)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2202)
		p.Match(MojoParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeElementsContext is an interface to support dynamic dispatch.
type ITupleTypeElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTupleTypeElement() []ITupleTypeElementContext
	TupleTypeElement(i int) ITupleTypeElementContext
	AllEovWithDocument() []IEovWithDocumentContext
	EovWithDocument(i int) IEovWithDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsTupleTypeElementsContext differentiates from other interfaces.
	IsTupleTypeElementsContext()
}

type TupleTypeElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeElementsContext() *TupleTypeElementsContext {
	var p = new(TupleTypeElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tupleTypeElements
	return p
}

func InitEmptyTupleTypeElementsContext(p *TupleTypeElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tupleTypeElements
}

func (*TupleTypeElementsContext) IsTupleTypeElementsContext() {}

func NewTupleTypeElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeElementsContext {
	var p = new(TupleTypeElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_tupleTypeElements

	return p
}

func (s *TupleTypeElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeElementsContext) AllTupleTypeElement() []ITupleTypeElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITupleTypeElementContext); ok {
			len++
		}
	}

	tst := make([]ITupleTypeElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITupleTypeElementContext); ok {
			tst[i] = t.(ITupleTypeElementContext)
			i++
		}
	}

	return tst
}

func (s *TupleTypeElementsContext) TupleTypeElement(i int) ITupleTypeElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeElementContext)
}

func (s *TupleTypeElementsContext) AllEovWithDocument() []IEovWithDocumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovWithDocumentContext); ok {
			len++
		}
	}

	tst := make([]IEovWithDocumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovWithDocumentContext); ok {
			tst[i] = t.(IEovWithDocumentContext)
			i++
		}
	}

	return tst
}

func (s *TupleTypeElementsContext) EovWithDocument(i int) IEovWithDocumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovWithDocumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovWithDocumentContext)
}

func (s *TupleTypeElementsContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *TupleTypeElementsContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *TupleTypeElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTupleTypeElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TupleTypeElements() (localctx ITupleTypeElementsContext) {
	localctx = NewTupleTypeElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, MojoParserRULE_tupleTypeElements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2204)
		p.TupleTypeElement()
	}
	p.SetState(2216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2205)
				p.EovWithDocument()
			}
			p.SetState(2209)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(2206)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2211)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2212)
				p.TupleTypeElement()
			}

		}
		p.SetState(2218)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2220)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 301, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2219)
			p.EovWithDocument()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeElementContext is an interface to support dynamic dispatch.
type ITupleTypeElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context
	DeclarationIdentifier() IDeclarationIdentifierContext
	Attributes() IAttributesContext
	COLON() antlr.TerminalNode

	// IsTupleTypeElementContext differentiates from other interfaces.
	IsTupleTypeElementContext()
}

type TupleTypeElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeElementContext() *TupleTypeElementContext {
	var p = new(TupleTypeElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tupleTypeElement
	return p
}

func InitEmptyTupleTypeElementContext(p *TupleTypeElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_tupleTypeElement
}

func (*TupleTypeElementContext) IsTupleTypeElementContext() {}

func NewTupleTypeElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeElementContext {
	var p = new(TupleTypeElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_tupleTypeElement

	return p
}

func (s *TupleTypeElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeElementContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TupleTypeElementContext) DeclarationIdentifier() IDeclarationIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationIdentifierContext)
}

func (s *TupleTypeElementContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *TupleTypeElementContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *TupleTypeElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTupleTypeElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TupleTypeElement() (localctx ITupleTypeElementContext) {
	localctx = NewTupleTypeElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, MojoParserRULE_tupleTypeElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2226)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 303, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2222)
			p.DeclarationIdentifier()
		}
		p.SetState(2224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserCOLON {
			{
				p.SetState(2223)
				p.Match(MojoParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2228)
		p.type_(0)
	}
	p.SetState(2230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserAT {
		{
			p.SetState(2229)
			p.Attributes()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionParameterClause() IFunctionParameterClauseContext
	ArrowOperator() IArrowOperatorContext
	Type_() IType_Context
	Attributes() IAttributesContext

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FunctionParameterClause() IFunctionParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterClauseContext)
}

func (s *FunctionTypeContext) ArrowOperator() IArrowOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowOperatorContext)
}

func (s *FunctionTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FunctionTypeContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, MojoParserRULE_functionType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2232)
		p.FunctionParameterClause()
	}
	{
		p.SetState(2233)
		p.ArrowOperator()
	}
	{
		p.SetState(2234)
		p.type_(0)
	}
	p.SetState(2236)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2235)
			p.Attributes()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	Type_() IType_Context
	RBRACK() antlr.TerminalNode
	Attributes() IAttributesContext

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(MojoParserLBRACK, 0)
}

func (s *ArrayTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ArrayTypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(MojoParserRBRACK, 0)
}

func (s *ArrayTypeContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, MojoParserRULE_arrayType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2238)
		p.Match(MojoParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2239)
		p.type_(0)
	}
	p.SetState(2241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserAT {
		{
			p.SetState(2240)
			p.Attributes()
		}

	}
	{
		p.SetState(2243)
		p.Match(MojoParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapTypeContext is an interface to support dynamic dispatch.
type IMapTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURLY() antlr.TerminalNode
	AllType_() []IType_Context
	Type_(i int) IType_Context
	RCURLY() antlr.TerminalNode
	KeyAttributes() IKeyAttributesContext
	COLON() antlr.TerminalNode
	Attributes() IAttributesContext

	// IsMapTypeContext differentiates from other interfaces.
	IsMapTypeContext()
}

type MapTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapTypeContext() *MapTypeContext {
	var p = new(MapTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_mapType
	return p
}

func InitEmptyMapTypeContext(p *MapTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_mapType
}

func (*MapTypeContext) IsMapTypeContext() {}

func NewMapTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTypeContext {
	var p = new(MapTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_mapType

	return p
}

func (s *MapTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTypeContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserLCURLY, 0)
}

func (s *MapTypeContext) AllType_() []IType_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IType_Context); ok {
			len++
		}
	}

	tst := make([]IType_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IType_Context); ok {
			tst[i] = t.(IType_Context)
			i++
		}
	}

	return tst
}

func (s *MapTypeContext) Type_(i int) IType_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *MapTypeContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(MojoParserRCURLY, 0)
}

func (s *MapTypeContext) KeyAttributes() IKeyAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyAttributesContext)
}

func (s *MapTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *MapTypeContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *MapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitMapType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) MapType() (localctx IMapTypeContext) {
	localctx = NewMapTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, MojoParserRULE_mapType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2245)
		p.Match(MojoParserLCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2246)
		p.type_(0)
	}
	p.SetState(2248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserAT {
		{
			p.SetState(2247)
			p.KeyAttributes()
		}

	}
	p.SetState(2251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserCOLON {
		{
			p.SetState(2250)
			p.Match(MojoParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2253)
		p.type_(0)
	}
	p.SetState(2255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserAT {
		{
			p.SetState(2254)
			p.Attributes()
		}

	}
	{
		p.SetState(2257)
		p.Match(MojoParserRCURLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyAttributesContext is an interface to support dynamic dispatch.
type IKeyAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Attributes() IAttributesContext

	// IsKeyAttributesContext differentiates from other interfaces.
	IsKeyAttributesContext()
}

type KeyAttributesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyAttributesContext() *KeyAttributesContext {
	var p = new(KeyAttributesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_keyAttributes
	return p
}

func InitEmptyKeyAttributesContext(p *KeyAttributesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_keyAttributes
}

func (*KeyAttributesContext) IsKeyAttributesContext() {}

func NewKeyAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyAttributesContext {
	var p = new(KeyAttributesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_keyAttributes

	return p
}

func (s *KeyAttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyAttributesContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *KeyAttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyAttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyAttributesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitKeyAttributes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) KeyAttributes() (localctx IKeyAttributesContext) {
	localctx = NewKeyAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, MojoParserRULE_keyAttributes)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2259)
		p.Attributes()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeInheritanceClauseContext is an interface to support dynamic dispatch.
type ITypeInheritanceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	TypeInheritances() ITypeInheritancesContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsTypeInheritanceClauseContext differentiates from other interfaces.
	IsTypeInheritanceClauseContext()
}

type TypeInheritanceClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeInheritanceClauseContext() *TypeInheritanceClauseContext {
	var p = new(TypeInheritanceClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeInheritanceClause
	return p
}

func InitEmptyTypeInheritanceClauseContext(p *TypeInheritanceClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeInheritanceClause
}

func (*TypeInheritanceClauseContext) IsTypeInheritanceClauseContext() {}

func NewTypeInheritanceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeInheritanceClauseContext {
	var p = new(TypeInheritanceClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_typeInheritanceClause

	return p
}

func (s *TypeInheritanceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeInheritanceClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(MojoParserCOLON, 0)
}

func (s *TypeInheritanceClauseContext) TypeInheritances() ITypeInheritancesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeInheritancesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeInheritancesContext)
}

func (s *TypeInheritanceClauseContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *TypeInheritanceClauseContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *TypeInheritanceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeInheritanceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeInheritanceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTypeInheritanceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TypeInheritanceClause() (localctx ITypeInheritanceClauseContext) {
	localctx = NewTypeInheritanceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, MojoParserRULE_typeInheritanceClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2261)
		p.Match(MojoParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserEOL {
		{
			p.SetState(2262)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2268)
		p.TypeInheritances()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeInheritancesContext is an interface to support dynamic dispatch.
type ITypeInheritancesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeInheritance() []ITypeInheritanceContext
	TypeInheritance(i int) ITypeInheritanceContext
	AllEovWithDocument() []IEovWithDocumentContext
	EovWithDocument(i int) IEovWithDocumentContext
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsTypeInheritancesContext differentiates from other interfaces.
	IsTypeInheritancesContext()
}

type TypeInheritancesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeInheritancesContext() *TypeInheritancesContext {
	var p = new(TypeInheritancesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeInheritances
	return p
}

func InitEmptyTypeInheritancesContext(p *TypeInheritancesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeInheritances
}

func (*TypeInheritancesContext) IsTypeInheritancesContext() {}

func NewTypeInheritancesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeInheritancesContext {
	var p = new(TypeInheritancesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_typeInheritances

	return p
}

func (s *TypeInheritancesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeInheritancesContext) AllTypeInheritance() []ITypeInheritanceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeInheritanceContext); ok {
			len++
		}
	}

	tst := make([]ITypeInheritanceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeInheritanceContext); ok {
			tst[i] = t.(ITypeInheritanceContext)
			i++
		}
	}

	return tst
}

func (s *TypeInheritancesContext) TypeInheritance(i int) ITypeInheritanceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeInheritanceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeInheritanceContext)
}

func (s *TypeInheritancesContext) AllEovWithDocument() []IEovWithDocumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEovWithDocumentContext); ok {
			len++
		}
	}

	tst := make([]IEovWithDocumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEovWithDocumentContext); ok {
			tst[i] = t.(IEovWithDocumentContext)
			i++
		}
	}

	return tst
}

func (s *TypeInheritancesContext) EovWithDocument(i int) IEovWithDocumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEovWithDocumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEovWithDocumentContext)
}

func (s *TypeInheritancesContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *TypeInheritancesContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *TypeInheritancesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeInheritancesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeInheritancesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTypeInheritances(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TypeInheritances() (localctx ITypeInheritancesContext) {
	localctx = NewTypeInheritancesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, MojoParserRULE_typeInheritances)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2270)
		p.TypeInheritance()
	}
	p.SetState(2282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2271)
				p.EovWithDocument()
			}
			p.SetState(2275)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MojoParserEOL {
				{
					p.SetState(2272)
					p.Match(MojoParserEOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2277)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2278)
				p.TypeInheritance()
			}

		}
		p.SetState(2284)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2286)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2285)
			p.EovWithDocument()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeInheritanceContext is an interface to support dynamic dispatch.
type ITypeInheritanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BasicType() IBasicTypeContext
	Attributes() IAttributesContext

	// IsTypeInheritanceContext differentiates from other interfaces.
	IsTypeInheritanceContext()
}

type TypeInheritanceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeInheritanceContext() *TypeInheritanceContext {
	var p = new(TypeInheritanceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeInheritance
	return p
}

func InitEmptyTypeInheritanceContext(p *TypeInheritanceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_typeInheritance
}

func (*TypeInheritanceContext) IsTypeInheritanceContext() {}

func NewTypeInheritanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeInheritanceContext {
	var p = new(TypeInheritanceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_typeInheritance

	return p
}

func (s *TypeInheritanceContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeInheritanceContext) BasicType() IBasicTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasicTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasicTypeContext)
}

func (s *TypeInheritanceContext) Attributes() IAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *TypeInheritanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeInheritanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeInheritanceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitTypeInheritance(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) TypeInheritance() (localctx ITypeInheritanceContext) {
	localctx = NewTypeInheritanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, MojoParserRULE_typeInheritance)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2288)
		p.basicType(0)
	}
	p.SetState(2290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MojoParserAT {
		{
			p.SetState(2289)
			p.Attributes()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationIdentifierContext is an interface to support dynamic dispatch.
type IDeclarationIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUE_IDENTIFIER() antlr.TerminalNode
	KeywordAsIdentifierInDeclarations() IKeywordAsIdentifierInDeclarationsContext

	// IsDeclarationIdentifierContext differentiates from other interfaces.
	IsDeclarationIdentifierContext()
}

type DeclarationIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationIdentifierContext() *DeclarationIdentifierContext {
	var p = new(DeclarationIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_declarationIdentifier
	return p
}

func InitEmptyDeclarationIdentifierContext(p *DeclarationIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_declarationIdentifier
}

func (*DeclarationIdentifierContext) IsDeclarationIdentifierContext() {}

func NewDeclarationIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationIdentifierContext {
	var p = new(DeclarationIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_declarationIdentifier

	return p
}

func (s *DeclarationIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationIdentifierContext) VALUE_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MojoParserVALUE_IDENTIFIER, 0)
}

func (s *DeclarationIdentifierContext) KeywordAsIdentifierInDeclarations() IKeywordAsIdentifierInDeclarationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordAsIdentifierInDeclarationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordAsIdentifierInDeclarationsContext)
}

func (s *DeclarationIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitDeclarationIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) DeclarationIdentifier() (localctx IDeclarationIdentifierContext) {
	localctx = NewDeclarationIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, MojoParserRULE_declarationIdentifier)
	p.SetState(2294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserVALUE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2292)
			p.Match(MojoParserVALUE_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MojoParserKEYWORD_AND, MojoParserKEYWORD_AS, MojoParserKEYWORD_ATTRIBUTE, MojoParserKEYWORD_BREAK, MojoParserKEYWORD_CONST, MojoParserKEYWORD_CONTINUE, MojoParserKEYWORD_ELSE, MojoParserKEYWORD_ENUM, MojoParserKEYWORD_FALSE, MojoParserKEYWORD_FUNC, MojoParserKEYWORD_IMPORT, MojoParserKEYWORD_IN, MojoParserKEYWORD_INTERFACE, MojoParserKEYWORD_IS, MojoParserKEYWORD_MATCH, MojoParserKEYWORD_NOT, MojoParserKEYWORD_NULL, MojoParserKEYWORD_OR, MojoParserKEYWORD_PACKAGE, MojoParserKEYWORD_STRUCT, MojoParserKEYWORD_TRUE, MojoParserKEYWORD_TYPE, MojoParserKEYWORD_XOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2293)
			p.KeywordAsIdentifierInDeclarations()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelIdentifierContext is an interface to support dynamic dispatch.
type ILabelIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUE_IDENTIFIER() antlr.TerminalNode
	KeywordAsIdentifierInLabels() IKeywordAsIdentifierInLabelsContext

	// IsLabelIdentifierContext differentiates from other interfaces.
	IsLabelIdentifierContext()
}

type LabelIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelIdentifierContext() *LabelIdentifierContext {
	var p = new(LabelIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_labelIdentifier
	return p
}

func InitEmptyLabelIdentifierContext(p *LabelIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_labelIdentifier
}

func (*LabelIdentifierContext) IsLabelIdentifierContext() {}

func NewLabelIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelIdentifierContext {
	var p = new(LabelIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_labelIdentifier

	return p
}

func (s *LabelIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelIdentifierContext) VALUE_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MojoParserVALUE_IDENTIFIER, 0)
}

func (s *LabelIdentifierContext) KeywordAsIdentifierInLabels() IKeywordAsIdentifierInLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordAsIdentifierInLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordAsIdentifierInLabelsContext)
}

func (s *LabelIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitLabelIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) LabelIdentifier() (localctx ILabelIdentifierContext) {
	localctx = NewLabelIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, MojoParserRULE_labelIdentifier)
	p.SetState(2298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserVALUE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2296)
			p.Match(MojoParserVALUE_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MojoParserKEYWORD_AND, MojoParserKEYWORD_AS, MojoParserKEYWORD_ATTRIBUTE, MojoParserKEYWORD_BREAK, MojoParserKEYWORD_CONST, MojoParserKEYWORD_CONTINUE, MojoParserKEYWORD_ELSE, MojoParserKEYWORD_ENUM, MojoParserKEYWORD_FALSE, MojoParserKEYWORD_FOR, MojoParserKEYWORD_FUNC, MojoParserKEYWORD_IMPORT, MojoParserKEYWORD_IN, MojoParserKEYWORD_INTERFACE, MojoParserKEYWORD_IS, MojoParserKEYWORD_MATCH, MojoParserKEYWORD_NOT, MojoParserKEYWORD_NULL, MojoParserKEYWORD_OR, MojoParserKEYWORD_PACKAGE, MojoParserKEYWORD_RETURN, MojoParserKEYWORD_STRUCT, MojoParserKEYWORD_TRUE, MojoParserKEYWORD_TYPE, MojoParserKEYWORD_VAR, MojoParserKEYWORD_WHILE, MojoParserKEYWORD_XOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2297)
			p.KeywordAsIdentifierInLabels()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathIdentifierContext is an interface to support dynamic dispatch.
type IPathIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDeclarationIdentifier() []IDeclarationIdentifierContext
	DeclarationIdentifier(i int) IDeclarationIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsPathIdentifierContext differentiates from other interfaces.
	IsPathIdentifierContext()
}

type PathIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathIdentifierContext() *PathIdentifierContext {
	var p = new(PathIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_pathIdentifier
	return p
}

func InitEmptyPathIdentifierContext(p *PathIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_pathIdentifier
}

func (*PathIdentifierContext) IsPathIdentifierContext() {}

func NewPathIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathIdentifierContext {
	var p = new(PathIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_pathIdentifier

	return p
}

func (s *PathIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PathIdentifierContext) AllDeclarationIdentifier() []IDeclarationIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationIdentifierContext); ok {
			tst[i] = t.(IDeclarationIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *PathIdentifierContext) DeclarationIdentifier(i int) IDeclarationIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationIdentifierContext)
}

func (s *PathIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(MojoParserDOT)
}

func (s *PathIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, i)
}

func (s *PathIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPathIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PathIdentifier() (localctx IPathIdentifierContext) {
	localctx = NewPathIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, MojoParserRULE_pathIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2300)
		p.DeclarationIdentifier()
	}
	p.SetState(2305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MojoParserDOT {
		{
			p.SetState(2301)
			p.Match(MojoParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2302)
			p.DeclarationIdentifier()
		}

		p.SetState(2307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUE_IDENTIFIER() antlr.TerminalNode
	IMPLICIT_PARAMETER_NAME() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) VALUE_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MojoParserVALUE_IDENTIFIER, 0)
}

func (s *IdentifierContext) IMPLICIT_PARAMETER_NAME() antlr.TerminalNode {
	return s.GetToken(MojoParserIMPLICIT_PARAMETER_NAME, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, MojoParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2308)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MojoParserVALUE_IDENTIFIER || _la == MojoParserIMPLICIT_PARAMETER_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordAsIdentifierInDeclarationsContext is an interface to support dynamic dispatch.
type IKeywordAsIdentifierInDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_AND() antlr.TerminalNode
	KEYWORD_AS() antlr.TerminalNode
	KEYWORD_ATTRIBUTE() antlr.TerminalNode
	KEYWORD_BREAK() antlr.TerminalNode
	KEYWORD_CONST() antlr.TerminalNode
	KEYWORD_CONTINUE() antlr.TerminalNode
	KEYWORD_ELSE() antlr.TerminalNode
	KEYWORD_ENUM() antlr.TerminalNode
	KEYWORD_FALSE() antlr.TerminalNode
	KEYWORD_FUNC() antlr.TerminalNode
	KEYWORD_IMPORT() antlr.TerminalNode
	KEYWORD_IN() antlr.TerminalNode
	KEYWORD_INTERFACE() antlr.TerminalNode
	KEYWORD_IS() antlr.TerminalNode
	KEYWORD_MATCH() antlr.TerminalNode
	KEYWORD_NOT() antlr.TerminalNode
	KEYWORD_NULL() antlr.TerminalNode
	KEYWORD_OR() antlr.TerminalNode
	KEYWORD_PACKAGE() antlr.TerminalNode
	KEYWORD_STRUCT() antlr.TerminalNode
	KEYWORD_TRUE() antlr.TerminalNode
	KEYWORD_TYPE() antlr.TerminalNode
	KEYWORD_XOR() antlr.TerminalNode

	// IsKeywordAsIdentifierInDeclarationsContext differentiates from other interfaces.
	IsKeywordAsIdentifierInDeclarationsContext()
}

type KeywordAsIdentifierInDeclarationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordAsIdentifierInDeclarationsContext() *KeywordAsIdentifierInDeclarationsContext {
	var p = new(KeywordAsIdentifierInDeclarationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_keywordAsIdentifierInDeclarations
	return p
}

func InitEmptyKeywordAsIdentifierInDeclarationsContext(p *KeywordAsIdentifierInDeclarationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_keywordAsIdentifierInDeclarations
}

func (*KeywordAsIdentifierInDeclarationsContext) IsKeywordAsIdentifierInDeclarationsContext() {}

func NewKeywordAsIdentifierInDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordAsIdentifierInDeclarationsContext {
	var p = new(KeywordAsIdentifierInDeclarationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_keywordAsIdentifierInDeclarations

	return p
}

func (s *KeywordAsIdentifierInDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_AND() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_AND, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_AS() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_AS, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_ATTRIBUTE, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_BREAK() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_BREAK, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_CONST() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_CONST, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_CONTINUE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_CONTINUE, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_ELSE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_ELSE, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_ENUM() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_ENUM, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_FALSE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_FALSE, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_FUNC() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_FUNC, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_IMPORT() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IMPORT, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_IN() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IN, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_INTERFACE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_INTERFACE, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_IS() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IS, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_MATCH() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_MATCH, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_NOT() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_NOT, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_NULL() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_NULL, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_OR() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_OR, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_PACKAGE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_PACKAGE, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_STRUCT() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_STRUCT, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_TRUE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_TRUE, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_TYPE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_TYPE, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) KEYWORD_XOR() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_XOR, 0)
}

func (s *KeywordAsIdentifierInDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordAsIdentifierInDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordAsIdentifierInDeclarationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitKeywordAsIdentifierInDeclarations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) KeywordAsIdentifierInDeclarations() (localctx IKeywordAsIdentifierInDeclarationsContext) {
	localctx = NewKeywordAsIdentifierInDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, MojoParserRULE_keywordAsIdentifierInDeclarations)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2310)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&331344894) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordAsIdentifierInLabelsContext is an interface to support dynamic dispatch.
type IKeywordAsIdentifierInLabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_AND() antlr.TerminalNode
	KEYWORD_AS() antlr.TerminalNode
	KEYWORD_ATTRIBUTE() antlr.TerminalNode
	KEYWORD_BREAK() antlr.TerminalNode
	KEYWORD_CONST() antlr.TerminalNode
	KEYWORD_CONTINUE() antlr.TerminalNode
	KEYWORD_ELSE() antlr.TerminalNode
	KEYWORD_ENUM() antlr.TerminalNode
	KEYWORD_FALSE() antlr.TerminalNode
	KEYWORD_FOR() antlr.TerminalNode
	KEYWORD_FUNC() antlr.TerminalNode
	KEYWORD_IMPORT() antlr.TerminalNode
	KEYWORD_IN() antlr.TerminalNode
	KEYWORD_INTERFACE() antlr.TerminalNode
	KEYWORD_IS() antlr.TerminalNode
	KEYWORD_MATCH() antlr.TerminalNode
	KEYWORD_NOT() antlr.TerminalNode
	KEYWORD_NULL() antlr.TerminalNode
	KEYWORD_OR() antlr.TerminalNode
	KEYWORD_PACKAGE() antlr.TerminalNode
	KEYWORD_RETURN() antlr.TerminalNode
	KEYWORD_STRUCT() antlr.TerminalNode
	KEYWORD_TRUE() antlr.TerminalNode
	KEYWORD_TYPE() antlr.TerminalNode
	KEYWORD_VAR() antlr.TerminalNode
	KEYWORD_WHILE() antlr.TerminalNode
	KEYWORD_XOR() antlr.TerminalNode

	// IsKeywordAsIdentifierInLabelsContext differentiates from other interfaces.
	IsKeywordAsIdentifierInLabelsContext()
}

type KeywordAsIdentifierInLabelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordAsIdentifierInLabelsContext() *KeywordAsIdentifierInLabelsContext {
	var p = new(KeywordAsIdentifierInLabelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_keywordAsIdentifierInLabels
	return p
}

func InitEmptyKeywordAsIdentifierInLabelsContext(p *KeywordAsIdentifierInLabelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_keywordAsIdentifierInLabels
}

func (*KeywordAsIdentifierInLabelsContext) IsKeywordAsIdentifierInLabelsContext() {}

func NewKeywordAsIdentifierInLabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordAsIdentifierInLabelsContext {
	var p = new(KeywordAsIdentifierInLabelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_keywordAsIdentifierInLabels

	return p
}

func (s *KeywordAsIdentifierInLabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_AND() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_AND, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_AS() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_AS, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_ATTRIBUTE, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_BREAK() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_BREAK, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_CONST() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_CONST, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_CONTINUE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_CONTINUE, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_ELSE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_ELSE, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_ENUM() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_ENUM, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_FALSE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_FALSE, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_FOR() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_FOR, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_FUNC() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_FUNC, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_IMPORT() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IMPORT, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_IN() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IN, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_INTERFACE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_INTERFACE, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_IS() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_IS, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_MATCH() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_MATCH, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_NOT() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_NOT, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_NULL() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_NULL, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_OR() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_OR, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_PACKAGE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_PACKAGE, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_RETURN() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_RETURN, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_STRUCT() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_STRUCT, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_TRUE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_TRUE, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_TYPE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_TYPE, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_VAR() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_VAR, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_WHILE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_WHILE, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) KEYWORD_XOR() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_XOR, 0)
}

func (s *KeywordAsIdentifierInLabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordAsIdentifierInLabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordAsIdentifierInLabelsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitKeywordAsIdentifierInLabels(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) KeywordAsIdentifierInLabels() (localctx IKeywordAsIdentifierInLabelsContext) {
	localctx = NewKeywordAsIdentifierInLabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, MojoParserRULE_keywordAsIdentifierInLabels)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2312)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&536866814) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDocumentContext is an interface to support dynamic dispatch.
type IDocumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLINE_DOCUMENT() []antlr.TerminalNode
	LINE_DOCUMENT(i int) antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsDocumentContext differentiates from other interfaces.
	IsDocumentContext()
}

type DocumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocumentContext() *DocumentContext {
	var p = new(DocumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_document
	return p
}

func InitEmptyDocumentContext(p *DocumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_document
}

func (*DocumentContext) IsDocumentContext() {}

func NewDocumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DocumentContext {
	var p = new(DocumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_document

	return p
}

func (s *DocumentContext) GetParser() antlr.Parser { return s.parser }

func (s *DocumentContext) AllLINE_DOCUMENT() []antlr.TerminalNode {
	return s.GetTokens(MojoParserLINE_DOCUMENT)
}

func (s *DocumentContext) LINE_DOCUMENT(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserLINE_DOCUMENT, i)
}

func (s *DocumentContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *DocumentContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *DocumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DocumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DocumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitDocument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Document() (localctx IDocumentContext) {
	localctx = NewDocumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, MojoParserRULE_document)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2314)
		p.Match(MojoParserLINE_DOCUMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2315)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2316)
				p.Match(MojoParserLINE_DOCUMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFollowingDocumentContext is an interface to support dynamic dispatch.
type IFollowingDocumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFOLLOWING_LINE_DOCUMENT() []antlr.TerminalNode
	FOLLOWING_LINE_DOCUMENT(i int) antlr.TerminalNode
	AllEOL() []antlr.TerminalNode
	EOL(i int) antlr.TerminalNode

	// IsFollowingDocumentContext differentiates from other interfaces.
	IsFollowingDocumentContext()
}

type FollowingDocumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFollowingDocumentContext() *FollowingDocumentContext {
	var p = new(FollowingDocumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_followingDocument
	return p
}

func InitEmptyFollowingDocumentContext(p *FollowingDocumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_followingDocument
}

func (*FollowingDocumentContext) IsFollowingDocumentContext() {}

func NewFollowingDocumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FollowingDocumentContext {
	var p = new(FollowingDocumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_followingDocument

	return p
}

func (s *FollowingDocumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FollowingDocumentContext) AllFOLLOWING_LINE_DOCUMENT() []antlr.TerminalNode {
	return s.GetTokens(MojoParserFOLLOWING_LINE_DOCUMENT)
}

func (s *FollowingDocumentContext) FOLLOWING_LINE_DOCUMENT(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserFOLLOWING_LINE_DOCUMENT, i)
}

func (s *FollowingDocumentContext) AllEOL() []antlr.TerminalNode {
	return s.GetTokens(MojoParserEOL)
}

func (s *FollowingDocumentContext) EOL(i int) antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, i)
}

func (s *FollowingDocumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FollowingDocumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FollowingDocumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitFollowingDocument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) FollowingDocument() (localctx IFollowingDocumentContext) {
	localctx = NewFollowingDocumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, MojoParserRULE_followingDocument)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2322)
		p.Match(MojoParserFOLLOWING_LINE_DOCUMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2323)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2324)
				p.Match(MojoParserFOLLOWING_LINE_DOCUMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2329)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_assignmentOperator
	return p
}

func InitEmptyAssignmentOperatorContext(p *AssignmentOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_assignmentOperator
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(MojoParserEQUAL, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, MojoParserRULE_assignmentOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2330)
		p.Match(MojoParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INegatePrefixOperatorContext is an interface to support dynamic dispatch.
type INegatePrefixOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS() antlr.TerminalNode

	// IsNegatePrefixOperatorContext differentiates from other interfaces.
	IsNegatePrefixOperatorContext()
}

type NegatePrefixOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNegatePrefixOperatorContext() *NegatePrefixOperatorContext {
	var p = new(NegatePrefixOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_negatePrefixOperator
	return p
}

func InitEmptyNegatePrefixOperatorContext(p *NegatePrefixOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_negatePrefixOperator
}

func (*NegatePrefixOperatorContext) IsNegatePrefixOperatorContext() {}

func NewNegatePrefixOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NegatePrefixOperatorContext {
	var p = new(NegatePrefixOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_negatePrefixOperator

	return p
}

func (s *NegatePrefixOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *NegatePrefixOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MojoParserMINUS, 0)
}

func (s *NegatePrefixOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NegatePrefixOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NegatePrefixOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitNegatePrefixOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) NegatePrefixOperator() (localctx INegatePrefixOperatorContext) {
	localctx = NewNegatePrefixOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, MojoParserRULE_negatePrefixOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2332)
		p.Match(MojoParserMINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrowOperatorContext is an interface to support dynamic dispatch.
type IArrowOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RIGHT_ARROW() antlr.TerminalNode

	// IsArrowOperatorContext differentiates from other interfaces.
	IsArrowOperatorContext()
}

type ArrowOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowOperatorContext() *ArrowOperatorContext {
	var p = new(ArrowOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_arrowOperator
	return p
}

func InitEmptyArrowOperatorContext(p *ArrowOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_arrowOperator
}

func (*ArrowOperatorContext) IsArrowOperatorContext() {}

func NewArrowOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowOperatorContext {
	var p = new(ArrowOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_arrowOperator

	return p
}

func (s *ArrowOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowOperatorContext) RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(MojoParserRIGHT_ARROW, 0)
}

func (s *ArrowOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitArrowOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) ArrowOperator() (localctx IArrowOperatorContext) {
	localctx = NewArrowOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, MojoParserRULE_arrowOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2334)
		p.Match(MojoParserRIGHT_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeOperatorContext is an interface to support dynamic dispatch.
type IRangeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT_DOT() antlr.TerminalNode

	// IsRangeOperatorContext differentiates from other interfaces.
	IsRangeOperatorContext()
}

type RangeOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeOperatorContext() *RangeOperatorContext {
	var p = new(RangeOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_rangeOperator
	return p
}

func InitEmptyRangeOperatorContext(p *RangeOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_rangeOperator
}

func (*RangeOperatorContext) IsRangeOperatorContext() {}

func NewRangeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeOperatorContext {
	var p = new(RangeOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_rangeOperator

	return p
}

func (s *RangeOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeOperatorContext) DOT_DOT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT_DOT, 0)
}

func (s *RangeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitRangeOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) RangeOperator() (localctx IRangeOperatorContext) {
	localctx = NewRangeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, MojoParserRULE_rangeOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2336)
		p.Match(MojoParserDOT_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHalfOpenRangeOperatorContext is an interface to support dynamic dispatch.
type IHalfOpenRangeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT_DOT_LT() antlr.TerminalNode

	// IsHalfOpenRangeOperatorContext differentiates from other interfaces.
	IsHalfOpenRangeOperatorContext()
}

type HalfOpenRangeOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHalfOpenRangeOperatorContext() *HalfOpenRangeOperatorContext {
	var p = new(HalfOpenRangeOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_halfOpenRangeOperator
	return p
}

func InitEmptyHalfOpenRangeOperatorContext(p *HalfOpenRangeOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_halfOpenRangeOperator
}

func (*HalfOpenRangeOperatorContext) IsHalfOpenRangeOperatorContext() {}

func NewHalfOpenRangeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HalfOpenRangeOperatorContext {
	var p = new(HalfOpenRangeOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_halfOpenRangeOperator

	return p
}

func (s *HalfOpenRangeOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *HalfOpenRangeOperatorContext) DOT_DOT_LT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT_DOT_LT, 0)
}

func (s *HalfOpenRangeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HalfOpenRangeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HalfOpenRangeOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitHalfOpenRangeOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) HalfOpenRangeOperator() (localctx IHalfOpenRangeOperatorContext) {
	localctx = NewHalfOpenRangeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, MojoParserRULE_halfOpenRangeOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2338)
		p.Match(MojoParserDOT_DOT_LT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinaryOperatorContext is an interface to support dynamic dispatch.
type IBinaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RangeOperator() IRangeOperatorContext
	HalfOpenRangeOperator() IHalfOpenRangeOperatorContext
	Operator() IOperatorContext
	KEYWORD_AND() antlr.TerminalNode
	KEYWORD_OR() antlr.TerminalNode

	// IsBinaryOperatorContext differentiates from other interfaces.
	IsBinaryOperatorContext()
}

type BinaryOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryOperatorContext() *BinaryOperatorContext {
	var p = new(BinaryOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_binaryOperator
	return p
}

func InitEmptyBinaryOperatorContext(p *BinaryOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_binaryOperator
}

func (*BinaryOperatorContext) IsBinaryOperatorContext() {}

func NewBinaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryOperatorContext {
	var p = new(BinaryOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_binaryOperator

	return p
}

func (s *BinaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryOperatorContext) RangeOperator() IRangeOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeOperatorContext)
}

func (s *BinaryOperatorContext) HalfOpenRangeOperator() IHalfOpenRangeOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHalfOpenRangeOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHalfOpenRangeOperatorContext)
}

func (s *BinaryOperatorContext) Operator() IOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorContext)
}

func (s *BinaryOperatorContext) KEYWORD_AND() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_AND, 0)
}

func (s *BinaryOperatorContext) KEYWORD_OR() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_OR, 0)
}

func (s *BinaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitBinaryOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) BinaryOperator() (localctx IBinaryOperatorContext) {
	localctx = NewBinaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, MojoParserRULE_binaryOperator)
	p.SetState(2345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserDOT_DOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2340)
			p.RangeOperator()
		}

	case MojoParserDOT_DOT_LT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2341)
			p.HalfOpenRangeOperator()
		}

	case MojoParserDOT, MojoParserLT, MojoParserGT, MojoParserBANG, MojoParserQUESTION, MojoParserAND, MojoParserMINUS, MojoParserEQUAL, MojoParserPIPE, MojoParserSLASH, MojoParserPLUS, MojoParserSTAR, MojoParserPERCENT, MojoParserCARET, MojoParserTILDE, MojoParserOPERATOR_HEAD_OTHER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2342)
			p.Operator()
		}

	case MojoParserKEYWORD_AND:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2343)
			p.Match(MojoParserKEYWORD_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MojoParserKEYWORD_OR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2344)
			p.Match(MojoParserKEYWORD_OR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrefixOperatorContext is an interface to support dynamic dispatch.
type IPrefixOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Operator() IOperatorContext
	KEYWORD_NOT() antlr.TerminalNode

	// IsPrefixOperatorContext differentiates from other interfaces.
	IsPrefixOperatorContext()
}

type PrefixOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixOperatorContext() *PrefixOperatorContext {
	var p = new(PrefixOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_prefixOperator
	return p
}

func InitEmptyPrefixOperatorContext(p *PrefixOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_prefixOperator
}

func (*PrefixOperatorContext) IsPrefixOperatorContext() {}

func NewPrefixOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixOperatorContext {
	var p = new(PrefixOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_prefixOperator

	return p
}

func (s *PrefixOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixOperatorContext) Operator() IOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorContext)
}

func (s *PrefixOperatorContext) KEYWORD_NOT() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_NOT, 0)
}

func (s *PrefixOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPrefixOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PrefixOperator() (localctx IPrefixOperatorContext) {
	localctx = NewPrefixOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, MojoParserRULE_prefixOperator)
	p.SetState(2349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserDOT, MojoParserLT, MojoParserGT, MojoParserBANG, MojoParserQUESTION, MojoParserAND, MojoParserMINUS, MojoParserEQUAL, MojoParserPIPE, MojoParserSLASH, MojoParserPLUS, MojoParserSTAR, MojoParserPERCENT, MojoParserCARET, MojoParserTILDE, MojoParserOPERATOR_HEAD_OTHER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2347)
			p.Operator()
		}

	case MojoParserKEYWORD_NOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2348)
			p.Match(MojoParserKEYWORD_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixOperatorContext is an interface to support dynamic dispatch.
type IPostfixOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS_PLUS() antlr.TerminalNode
	MINUS_MINUS() antlr.TerminalNode
	ELLIPSIS() antlr.TerminalNode

	// IsPostfixOperatorContext differentiates from other interfaces.
	IsPostfixOperatorContext()
}

type PostfixOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixOperatorContext() *PostfixOperatorContext {
	var p = new(PostfixOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_postfixOperator
	return p
}

func InitEmptyPostfixOperatorContext(p *PostfixOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_postfixOperator
}

func (*PostfixOperatorContext) IsPostfixOperatorContext() {}

func NewPostfixOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixOperatorContext {
	var p = new(PostfixOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_postfixOperator

	return p
}

func (s *PostfixOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixOperatorContext) PLUS_PLUS() antlr.TerminalNode {
	return s.GetToken(MojoParserPLUS_PLUS, 0)
}

func (s *PostfixOperatorContext) MINUS_MINUS() antlr.TerminalNode {
	return s.GetToken(MojoParserMINUS_MINUS, 0)
}

func (s *PostfixOperatorContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(MojoParserELLIPSIS, 0)
}

func (s *PostfixOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitPostfixOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) PostfixOperator() (localctx IPostfixOperatorContext) {
	localctx = NewPostfixOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, MojoParserRULE_postfixOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2351)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-57)) & ^0x3f) == 0 && ((int64(1)<<(_la-57))&131) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperatorContext is an interface to support dynamic dispatch.
type IOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Operator_head() IOperator_headContext
	Operator_characters() IOperator_charactersContext
	Dot_operator_head() IDot_operator_headContext
	AllDot_operator_character() []IDot_operator_characterContext
	Dot_operator_character(i int) IDot_operator_characterContext

	// IsOperatorContext differentiates from other interfaces.
	IsOperatorContext()
}

type OperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperatorContext() *OperatorContext {
	var p = new(OperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_operator
	return p
}

func InitEmptyOperatorContext(p *OperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_operator
}

func (*OperatorContext) IsOperatorContext() {}

func NewOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorContext {
	var p = new(OperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_operator

	return p
}

func (s *OperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *OperatorContext) Operator_head() IOperator_headContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperator_headContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperator_headContext)
}

func (s *OperatorContext) Operator_characters() IOperator_charactersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperator_charactersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperator_charactersContext)
}

func (s *OperatorContext) Dot_operator_head() IDot_operator_headContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDot_operator_headContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDot_operator_headContext)
}

func (s *OperatorContext) AllDot_operator_character() []IDot_operator_characterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDot_operator_characterContext); ok {
			len++
		}
	}

	tst := make([]IDot_operator_characterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDot_operator_characterContext); ok {
			tst[i] = t.(IDot_operator_characterContext)
			i++
		}
	}

	return tst
}

func (s *OperatorContext) Dot_operator_character(i int) IDot_operator_characterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDot_operator_characterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDot_operator_characterContext)
}

func (s *OperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Operator() (localctx IOperatorContext) {
	localctx = NewOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, MojoParserRULE_operator)
	var _alt int

	p.SetState(2363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserLT, MojoParserGT, MojoParserBANG, MojoParserQUESTION, MojoParserAND, MojoParserMINUS, MojoParserEQUAL, MojoParserPIPE, MojoParserSLASH, MojoParserPLUS, MojoParserSTAR, MojoParserPERCENT, MojoParserCARET, MojoParserTILDE, MojoParserOPERATOR_HEAD_OTHER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2353)
			p.Operator_head()
		}
		p.SetState(2355)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2354)
				p.Operator_characters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MojoParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2357)
			p.Dot_operator_head()
		}
		p.SetState(2359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(2358)
					p.Dot_operator_character()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(2361)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperator_charactersContext is an interface to support dynamic dispatch.
type IOperator_charactersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOperator_character() []IOperator_characterContext
	Operator_character(i int) IOperator_characterContext

	// IsOperator_charactersContext differentiates from other interfaces.
	IsOperator_charactersContext()
}

type Operator_charactersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperator_charactersContext() *Operator_charactersContext {
	var p = new(Operator_charactersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_operator_characters
	return p
}

func InitEmptyOperator_charactersContext(p *Operator_charactersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_operator_characters
}

func (*Operator_charactersContext) IsOperator_charactersContext() {}

func NewOperator_charactersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Operator_charactersContext {
	var p = new(Operator_charactersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_operator_characters

	return p
}

func (s *Operator_charactersContext) GetParser() antlr.Parser { return s.parser }

func (s *Operator_charactersContext) AllOperator_character() []IOperator_characterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOperator_characterContext); ok {
			len++
		}
	}

	tst := make([]IOperator_characterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOperator_characterContext); ok {
			tst[i] = t.(IOperator_characterContext)
			i++
		}
	}

	return tst
}

func (s *Operator_charactersContext) Operator_character(i int) IOperator_characterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperator_characterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperator_characterContext)
}

func (s *Operator_charactersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Operator_charactersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Operator_charactersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitOperator_characters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Operator_characters() (localctx IOperator_charactersContext) {
	localctx = NewOperator_charactersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, MojoParserRULE_operator_characters)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(2365)

			if !(p.GetTokenStream().Get(p.GetTokenStream().Index()-1).GetTokenType() != MojoParserWS) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.GetTokenStream().Get(p.GetTokenStream().Index()-1).GetTokenType() != MojoParserWS", ""))
				goto errorExit
			}
			{
				p.SetState(2366)
				p.Operator_character()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2369)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperator_characterContext is an interface to support dynamic dispatch.
type IOperator_characterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Operator_head() IOperator_headContext
	OPERATOR_FOLLOWING_CHARACTER() antlr.TerminalNode

	// IsOperator_characterContext differentiates from other interfaces.
	IsOperator_characterContext()
}

type Operator_characterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperator_characterContext() *Operator_characterContext {
	var p = new(Operator_characterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_operator_character
	return p
}

func InitEmptyOperator_characterContext(p *Operator_characterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_operator_character
}

func (*Operator_characterContext) IsOperator_characterContext() {}

func NewOperator_characterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Operator_characterContext {
	var p = new(Operator_characterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_operator_character

	return p
}

func (s *Operator_characterContext) GetParser() antlr.Parser { return s.parser }

func (s *Operator_characterContext) Operator_head() IOperator_headContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperator_headContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperator_headContext)
}

func (s *Operator_characterContext) OPERATOR_FOLLOWING_CHARACTER() antlr.TerminalNode {
	return s.GetToken(MojoParserOPERATOR_FOLLOWING_CHARACTER, 0)
}

func (s *Operator_characterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Operator_characterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Operator_characterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitOperator_character(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Operator_character() (localctx IOperator_characterContext) {
	localctx = NewOperator_characterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, MojoParserRULE_operator_character)
	p.SetState(2373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserLT, MojoParserGT, MojoParserBANG, MojoParserQUESTION, MojoParserAND, MojoParserMINUS, MojoParserEQUAL, MojoParserPIPE, MojoParserSLASH, MojoParserPLUS, MojoParserSTAR, MojoParserPERCENT, MojoParserCARET, MojoParserTILDE, MojoParserOPERATOR_HEAD_OTHER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2371)
			p.Operator_head()
		}

	case MojoParserOPERATOR_FOLLOWING_CHARACTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2372)
			p.Match(MojoParserOPERATOR_FOLLOWING_CHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperator_headContext is an interface to support dynamic dispatch.
type IOperator_headContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SLASH() antlr.TerminalNode
	EQUAL() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	BANG() antlr.TerminalNode
	STAR() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	AND() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	CARET() antlr.TerminalNode
	TILDE() antlr.TerminalNode
	QUESTION() antlr.TerminalNode
	OPERATOR_HEAD_OTHER() antlr.TerminalNode

	// IsOperator_headContext differentiates from other interfaces.
	IsOperator_headContext()
}

type Operator_headContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperator_headContext() *Operator_headContext {
	var p = new(Operator_headContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_operator_head
	return p
}

func InitEmptyOperator_headContext(p *Operator_headContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_operator_head
}

func (*Operator_headContext) IsOperator_headContext() {}

func NewOperator_headContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Operator_headContext {
	var p = new(Operator_headContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_operator_head

	return p
}

func (s *Operator_headContext) GetParser() antlr.Parser { return s.parser }

func (s *Operator_headContext) SLASH() antlr.TerminalNode {
	return s.GetToken(MojoParserSLASH, 0)
}

func (s *Operator_headContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(MojoParserEQUAL, 0)
}

func (s *Operator_headContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MojoParserMINUS, 0)
}

func (s *Operator_headContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MojoParserPLUS, 0)
}

func (s *Operator_headContext) BANG() antlr.TerminalNode {
	return s.GetToken(MojoParserBANG, 0)
}

func (s *Operator_headContext) STAR() antlr.TerminalNode {
	return s.GetToken(MojoParserSTAR, 0)
}

func (s *Operator_headContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(MojoParserPERCENT, 0)
}

func (s *Operator_headContext) AND() antlr.TerminalNode {
	return s.GetToken(MojoParserAND, 0)
}

func (s *Operator_headContext) PIPE() antlr.TerminalNode {
	return s.GetToken(MojoParserPIPE, 0)
}

func (s *Operator_headContext) LT() antlr.TerminalNode {
	return s.GetToken(MojoParserLT, 0)
}

func (s *Operator_headContext) GT() antlr.TerminalNode {
	return s.GetToken(MojoParserGT, 0)
}

func (s *Operator_headContext) CARET() antlr.TerminalNode {
	return s.GetToken(MojoParserCARET, 0)
}

func (s *Operator_headContext) TILDE() antlr.TerminalNode {
	return s.GetToken(MojoParserTILDE, 0)
}

func (s *Operator_headContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(MojoParserQUESTION, 0)
}

func (s *Operator_headContext) OPERATOR_HEAD_OTHER() antlr.TerminalNode {
	return s.GetToken(MojoParserOPERATOR_HEAD_OTHER, 0)
}

func (s *Operator_headContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Operator_headContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Operator_headContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitOperator_head(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Operator_head() (localctx IOperator_headContext) {
	localctx = NewOperator_headContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, MojoParserRULE_operator_head)
	var _la int

	p.SetState(2377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserLT, MojoParserGT, MojoParserBANG, MojoParserQUESTION, MojoParserAND, MojoParserMINUS, MojoParserEQUAL, MojoParserPIPE, MojoParserSLASH, MojoParserPLUS, MojoParserSTAR, MojoParserPERCENT, MojoParserCARET, MojoParserTILDE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2375)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18005052660645888) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MojoParserOPERATOR_HEAD_OTHER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2376)
			p.Match(MojoParserOPERATOR_HEAD_OTHER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDot_operator_headContext is an interface to support dynamic dispatch.
type IDot_operator_headContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode

	// IsDot_operator_headContext differentiates from other interfaces.
	IsDot_operator_headContext()
}

type Dot_operator_headContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDot_operator_headContext() *Dot_operator_headContext {
	var p = new(Dot_operator_headContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_dot_operator_head
	return p
}

func InitEmptyDot_operator_headContext(p *Dot_operator_headContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_dot_operator_head
}

func (*Dot_operator_headContext) IsDot_operator_headContext() {}

func NewDot_operator_headContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dot_operator_headContext {
	var p = new(Dot_operator_headContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_dot_operator_head

	return p
}

func (s *Dot_operator_headContext) GetParser() antlr.Parser { return s.parser }

func (s *Dot_operator_headContext) DOT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, 0)
}

func (s *Dot_operator_headContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dot_operator_headContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dot_operator_headContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitDot_operator_head(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Dot_operator_head() (localctx IDot_operator_headContext) {
	localctx = NewDot_operator_headContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, MojoParserRULE_dot_operator_head)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2379)
		p.Match(MojoParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDot_operator_characterContext is an interface to support dynamic dispatch.
type IDot_operator_characterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	Operator_character() IOperator_characterContext

	// IsDot_operator_characterContext differentiates from other interfaces.
	IsDot_operator_characterContext()
}

type Dot_operator_characterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDot_operator_characterContext() *Dot_operator_characterContext {
	var p = new(Dot_operator_characterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_dot_operator_character
	return p
}

func InitEmptyDot_operator_characterContext(p *Dot_operator_characterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_dot_operator_character
}

func (*Dot_operator_characterContext) IsDot_operator_characterContext() {}

func NewDot_operator_characterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dot_operator_characterContext {
	var p = new(Dot_operator_characterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_dot_operator_character

	return p
}

func (s *Dot_operator_characterContext) GetParser() antlr.Parser { return s.parser }

func (s *Dot_operator_characterContext) DOT() antlr.TerminalNode {
	return s.GetToken(MojoParserDOT, 0)
}

func (s *Dot_operator_characterContext) Operator_character() IOperator_characterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperator_characterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperator_characterContext)
}

func (s *Dot_operator_characterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dot_operator_characterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dot_operator_characterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitDot_operator_character(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Dot_operator_character() (localctx IDot_operator_characterContext) {
	localctx = NewDot_operator_characterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, MojoParserRULE_dot_operator_character)
	p.SetState(2383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2381)
			p.Match(MojoParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MojoParserLT, MojoParserGT, MojoParserBANG, MojoParserQUESTION, MojoParserAND, MojoParserMINUS, MojoParserEQUAL, MojoParserPIPE, MojoParserSLASH, MojoParserPLUS, MojoParserSTAR, MojoParserPERCENT, MojoParserCARET, MojoParserTILDE, MojoParserOPERATOR_HEAD_OTHER, MojoParserOPERATOR_FOLLOWING_CHARACTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2382)
			p.Operator_character()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericLiteral() INumericLiteralContext
	StringLiteral() IStringLiteralContext
	BoolLiteral() IBoolLiteralContext
	NullLiteral() INullLiteralContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralContext) BoolLiteral() IBoolLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolLiteralContext)
}

func (s *LiteralContext) NullLiteral() INullLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, MojoParserRULE_literal)
	p.SetState(2389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserMINUS, MojoParserBINARY_LITERAL, MojoParserOCTAL_LITERAL, MojoParserDECIMAL_LITERAL, MojoParserPURE_DECIMAL_DIGITS, MojoParserHEXADECIMAL_LITERAL, MojoParserFLOAT_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2385)
			p.NumericLiteral()
		}

	case MojoParserSTATIC_STRING_LITERAL, MojoParserINTERPOLATED_STRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2386)
			p.StringLiteral()
		}

	case MojoParserKEYWORD_FALSE, MojoParserKEYWORD_TRUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2387)
			p.BoolLiteral()
		}

	case MojoParserKEYWORD_NULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2388)
			p.NullLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBoolLiteralContext is an interface to support dynamic dispatch.
type IBoolLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_TRUE() antlr.TerminalNode
	KEYWORD_FALSE() antlr.TerminalNode

	// IsBoolLiteralContext differentiates from other interfaces.
	IsBoolLiteralContext()
}

type BoolLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolLiteralContext() *BoolLiteralContext {
	var p = new(BoolLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_boolLiteral
	return p
}

func InitEmptyBoolLiteralContext(p *BoolLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_boolLiteral
}

func (*BoolLiteralContext) IsBoolLiteralContext() {}

func NewBoolLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolLiteralContext {
	var p = new(BoolLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_boolLiteral

	return p
}

func (s *BoolLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolLiteralContext) KEYWORD_TRUE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_TRUE, 0)
}

func (s *BoolLiteralContext) KEYWORD_FALSE() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_FALSE, 0)
}

func (s *BoolLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoolLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitBoolLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) BoolLiteral() (localctx IBoolLiteralContext) {
	localctx = NewBoolLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, MojoParserRULE_boolLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2391)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MojoParserKEYWORD_FALSE || _la == MojoParserKEYWORD_TRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullLiteralContext is an interface to support dynamic dispatch.
type INullLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEYWORD_NULL() antlr.TerminalNode

	// IsNullLiteralContext differentiates from other interfaces.
	IsNullLiteralContext()
}

type NullLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullLiteralContext() *NullLiteralContext {
	var p = new(NullLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_nullLiteral
	return p
}

func InitEmptyNullLiteralContext(p *NullLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_nullLiteral
}

func (*NullLiteralContext) IsNullLiteralContext() {}

func NewNullLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullLiteralContext {
	var p = new(NullLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_nullLiteral

	return p
}

func (s *NullLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NullLiteralContext) KEYWORD_NULL() antlr.TerminalNode {
	return s.GetToken(MojoParserKEYWORD_NULL, 0)
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) NullLiteral() (localctx INullLiteralContext) {
	localctx = NewNullLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, MojoParserRULE_nullLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2393)
		p.Match(MojoParserKEYWORD_NULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() IIntegerLiteralContext
	NegatePrefixOperator() INegatePrefixOperatorContext
	FLOAT_LITERAL() antlr.TerminalNode

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_numericLiteral
	return p
}

func InitEmptyNumericLiteralContext(p *NumericLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_numericLiteral
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *NumericLiteralContext) NegatePrefixOperator() INegatePrefixOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INegatePrefixOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INegatePrefixOperatorContext)
}

func (s *NumericLiteralContext) FLOAT_LITERAL() antlr.TerminalNode {
	return s.GetToken(MojoParserFLOAT_LITERAL, 0)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) NumericLiteral() (localctx INumericLiteralContext) {
	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, MojoParserRULE_numericLiteral)
	var _la int

	p.SetState(2403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2396)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserMINUS {
			{
				p.SetState(2395)
				p.NegatePrefixOperator()
			}

		}
		{
			p.SetState(2398)
			p.IntegerLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserMINUS {
			{
				p.SetState(2399)
				p.NegatePrefixOperator()
			}

		}
		{
			p.SetState(2402)
			p.Match(MojoParserFLOAT_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntegerLiteralContext is an interface to support dynamic dispatch.
type IIntegerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY_LITERAL() antlr.TerminalNode
	OCTAL_LITERAL() antlr.TerminalNode
	DECIMAL_LITERAL() antlr.TerminalNode
	PURE_DECIMAL_DIGITS() antlr.TerminalNode
	HEXADECIMAL_LITERAL() antlr.TerminalNode

	// IsIntegerLiteralContext differentiates from other interfaces.
	IsIntegerLiteralContext()
}

type IntegerLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerLiteralContext() *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_integerLiteral
	return p
}

func InitEmptyIntegerLiteralContext(p *IntegerLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_integerLiteral
}

func (*IntegerLiteralContext) IsIntegerLiteralContext() {}

func NewIntegerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_integerLiteral

	return p
}

func (s *IntegerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerLiteralContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(MojoParserBINARY_LITERAL, 0)
}

func (s *IntegerLiteralContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MojoParserOCTAL_LITERAL, 0)
}

func (s *IntegerLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MojoParserDECIMAL_LITERAL, 0)
}

func (s *IntegerLiteralContext) PURE_DECIMAL_DIGITS() antlr.TerminalNode {
	return s.GetToken(MojoParserPURE_DECIMAL_DIGITS, 0)
}

func (s *IntegerLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MojoParserHEXADECIMAL_LITERAL, 0)
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitIntegerLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) IntegerLiteral() (localctx IIntegerLiteralContext) {
	localctx = NewIntegerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, MojoParserRULE_integerLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2405)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&31) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STATIC_STRING_LITERAL() antlr.TerminalNode
	INTERPOLATED_STRING_LITERAL() antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) STATIC_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MojoParserSTATIC_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) INTERPOLATED_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MojoParserINTERPOLATED_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, MojoParserRULE_stringLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2407)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MojoParserSTATIC_STRING_LITERAL || _la == MojoParserINTERPOLATED_STRING_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEosContext is an interface to support dynamic dispatch.
type IEosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	EOL() antlr.TerminalNode

	// IsEosContext differentiates from other interfaces.
	IsEosContext()
}

type EosContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosContext() *EosContext {
	var p = new(EosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_eos
	return p
}

func InitEmptyEosContext(p *EosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_eos
}

func (*EosContext) IsEosContext() {}

func NewEosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosContext {
	var p = new(EosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_eos

	return p
}

func (s *EosContext) GetParser() antlr.Parser { return s.parser }

func (s *EosContext) SEMI() antlr.TerminalNode {
	return s.GetToken(MojoParserSEMI, 0)
}

func (s *EosContext) EOL() antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, 0)
}

func (s *EosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EosContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitEos(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Eos() (localctx IEosContext) {
	localctx = NewEosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, MojoParserRULE_eos)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2409)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MojoParserSEMI || _la == MojoParserEOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEovContext is an interface to support dynamic dispatch.
type IEovContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode
	EOL() antlr.TerminalNode

	// IsEovContext differentiates from other interfaces.
	IsEovContext()
}

type EovContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEovContext() *EovContext {
	var p = new(EovContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_eov
	return p
}

func InitEmptyEovContext(p *EovContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_eov
}

func (*EovContext) IsEovContext() {}

func NewEovContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EovContext {
	var p = new(EovContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_eov

	return p
}

func (s *EovContext) GetParser() antlr.Parser { return s.parser }

func (s *EovContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MojoParserCOMMA, 0)
}

func (s *EovContext) EOL() antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, 0)
}

func (s *EovContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EovContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EovContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitEov(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) Eov() (localctx IEovContext) {
	localctx = NewEovContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, MojoParserRULE_eov)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2411)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MojoParserCOMMA || _la == MojoParserEOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEosWithDocumentContext is an interface to support dynamic dispatch.
type IEosWithDocumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	FollowingDocument() IFollowingDocumentContext
	EOL() antlr.TerminalNode

	// IsEosWithDocumentContext differentiates from other interfaces.
	IsEosWithDocumentContext()
}

type EosWithDocumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosWithDocumentContext() *EosWithDocumentContext {
	var p = new(EosWithDocumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_eosWithDocument
	return p
}

func InitEmptyEosWithDocumentContext(p *EosWithDocumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_eosWithDocument
}

func (*EosWithDocumentContext) IsEosWithDocumentContext() {}

func NewEosWithDocumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosWithDocumentContext {
	var p = new(EosWithDocumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_eosWithDocument

	return p
}

func (s *EosWithDocumentContext) GetParser() antlr.Parser { return s.parser }

func (s *EosWithDocumentContext) SEMI() antlr.TerminalNode {
	return s.GetToken(MojoParserSEMI, 0)
}

func (s *EosWithDocumentContext) FollowingDocument() IFollowingDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *EosWithDocumentContext) EOL() antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, 0)
}

func (s *EosWithDocumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosWithDocumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EosWithDocumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitEosWithDocument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) EosWithDocument() (localctx IEosWithDocumentContext) {
	localctx = NewEosWithDocumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, MojoParserRULE_eosWithDocument)
	var _la int

	p.SetState(2423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserSEMI:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2413)
			p.Match(MojoParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserFOLLOWING_LINE_DOCUMENT {
			{
				p.SetState(2414)
				p.FollowingDocument()
			}
			{
				p.SetState(2415)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case MojoParserEOL, MojoParserFOLLOWING_LINE_DOCUMENT:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserFOLLOWING_LINE_DOCUMENT {
			{
				p.SetState(2419)
				p.FollowingDocument()
			}

		}
		{
			p.SetState(2422)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEovWithDocumentContext is an interface to support dynamic dispatch.
type IEovWithDocumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode
	FollowingDocument() IFollowingDocumentContext
	EOL() antlr.TerminalNode

	// IsEovWithDocumentContext differentiates from other interfaces.
	IsEovWithDocumentContext()
}

type EovWithDocumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEovWithDocumentContext() *EovWithDocumentContext {
	var p = new(EovWithDocumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_eovWithDocument
	return p
}

func InitEmptyEovWithDocumentContext(p *EovWithDocumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MojoParserRULE_eovWithDocument
}

func (*EovWithDocumentContext) IsEovWithDocumentContext() {}

func NewEovWithDocumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EovWithDocumentContext {
	var p = new(EovWithDocumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MojoParserRULE_eovWithDocument

	return p
}

func (s *EovWithDocumentContext) GetParser() antlr.Parser { return s.parser }

func (s *EovWithDocumentContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MojoParserCOMMA, 0)
}

func (s *EovWithDocumentContext) FollowingDocument() IFollowingDocumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFollowingDocumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFollowingDocumentContext)
}

func (s *EovWithDocumentContext) EOL() antlr.TerminalNode {
	return s.GetToken(MojoParserEOL, 0)
}

func (s *EovWithDocumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EovWithDocumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EovWithDocumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MojoParserVisitor:
		return t.VisitEovWithDocument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MojoParser) EovWithDocument() (localctx IEovWithDocumentContext) {
	localctx = NewEovWithDocumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, MojoParserRULE_eovWithDocument)
	var _la int

	p.SetState(2435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MojoParserCOMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2425)
			p.Match(MojoParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2429)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2426)
				p.FollowingDocument()
			}
			{
				p.SetState(2427)
				p.Match(MojoParserEOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MojoParserEOL, MojoParserFOLLOWING_LINE_DOCUMENT:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MojoParserFOLLOWING_LINE_DOCUMENT {
			{
				p.SetState(2431)
				p.FollowingDocument()
			}

		}
		{
			p.SetState(2434)
			p.Match(MojoParserEOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *MojoParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 83:
		var t *PatternContext = nil
		if localctx != nil {
			t = localctx.(*PatternContext)
		}
		return p.Pattern_Sempred(t, predIndex)

	case 108:
		var t *StringOperatorLiteralContext = nil
		if localctx != nil {
			t = localctx.(*StringOperatorLiteralContext)
		}
		return p.StringOperatorLiteral_Sempred(t, predIndex)

	case 109:
		var t *SuffixLiteralOperatorContext = nil
		if localctx != nil {
			t = localctx.(*SuffixLiteralOperatorContext)
		}
		return p.SuffixLiteralOperator_Sempred(t, predIndex)

	case 146:
		var t *Type_Context = nil
		if localctx != nil {
			t = localctx.(*Type_Context)
		}
		return p.Type__Sempred(t, predIndex)

	case 147:
		var t *BasicTypeContext = nil
		if localctx != nil {
			t = localctx.(*BasicTypeContext)
		}
		return p.BasicType_Sempred(t, predIndex)

	case 180:
		var t *Operator_charactersContext = nil
		if localctx != nil {
			t = localctx.(*Operator_charactersContext)
		}
		return p.Operator_characters_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *MojoParser) Pattern_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MojoParser) StringOperatorLiteral_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.GetTokenStream().Get(p.GetTokenStream().Index()-1).GetTokenType() != MojoParserWS

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MojoParser) SuffixLiteralOperator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.GetTokenStream().Get(p.GetTokenStream().Index()-1).GetTokenType() != MojoParserWS

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MojoParser) Type__Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MojoParser) BasicType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MojoParser) Operator_characters_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.GetTokenStream().Get(p.GetTokenStream().Index()-1).GetTokenType() != MojoParserWS

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
